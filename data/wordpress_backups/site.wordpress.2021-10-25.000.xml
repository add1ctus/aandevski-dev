<?xml version="1.0" encoding="UTF-8"?>
<!--
 This is a WordPress eXtended RSS file generated by WordPress as an export of your site.
 It contains information about your site's posts, pages, comments, categories, and other content.
 You may use this file to transfer that content from one site to another.
 This file is not intended to serve as a complete backup of your site.

 To import this information into a WordPress site follow these steps:
 1. Log in to that site as an administrator.
 2. Go to Tools: Import in the WordPress admin panel.
 3. Install the "WordPress" importer from the list.
 4. Activate & Run Importer.
 5. Upload this file using the form provided on that page.
 6. You will first be asked to map the authors in this export file to users
    on the site. For each author, you may choose to map to an
    existing user on the site or to create a new user.
 7. WordPress will then import each of the posts, pages, comments, categories, etc.
    contained in this file into your site.
-->
<!-- generator="WordPress.com" created="2021-10-25 09:16"-->
<rss version="2.0" xmlns:excerpt="http://wordpress.org/export/1.2/excerpt/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:wfw="http://wellformedweb.org/CommentAPI/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:wp="http://wordpress.org/export/1.2/">
  <channel>
<title>Мојот блог</title>
<link>https://aandevski.wordpress.com</link>
<description>А. Андевски</description>
<pubDate>Mon, 25 Oct 2021 09:16:27 +0000</pubDate>
<language>en</language>
<wp:wxr_version>1.2</wp:wxr_version>
<wp:base_site_url>http://wordpress.com/</wp:base_site_url>
<wp:base_blog_url>https://aandevski.wordpress.com</wp:base_blog_url>
<wp:author>
  <wp:author_id>55813594</wp:author_id>
  <wp:author_login>add1ctus</wp:author_login>
  <wp:author_email>a.andevski@gmail.com</wp:author_email>
  <wp:author_display_name><![CDATA[Александар]]></wp:author_display_name>
  <wp:author_first_name><![CDATA[Александар]]></wp:author_first_name>
  <wp:author_last_name><![CDATA[Андевски]]></wp:author_last_name>
</wp:author>
<wp:term>
  <wp:term_id>330108585</wp:term_id>
  <wp:term_taxonomy>nav_menu</wp:term_taxonomy>
  <wp:term_slug>navigation</wp:term_slug>
  <wp:term_name><![CDATA[Navigation]]></wp:term_name>
</wp:term>
<wp:term>
  <wp:term_id>4477</wp:term_id>
  <wp:term_taxonomy>nav_menu</wp:term_taxonomy>
  <wp:term_slug>social-menu</wp:term_slug>
  <wp:term_name><![CDATA[Social Menu]]></wp:term_name>
</wp:term>
<generator>http://wordpress.com/</generator>
<image>
		<url>http://s0.wp.com/i/buttonw-com.png</url>
		<title>Мојот блог</title>
		<link>https://aandevski.wordpress.com</link>
	</image>
	<item>
  <title>Hello world!</title>
  <link>https://aandevski.wordpress.com/2015/02/19/hello-world/</link>
  <pubDate>Thu, 19 Feb 2015 22:23:32 +0000</pubDate>
  <dc:creator>add1ctus</dc:creator>
  <guid isPermaLink="false">https://aandevski.wordpress.com/?p=5</guid>
  <description/>
  <content:encoded><![CDATA[Клише наслов, знам...
<blockquote>The first thing you need to decide when you build your blog is what you want to accomplish with it, and what it can do if successful. - Ron Dawson</blockquote>
Што сакам да постигнам со блогот, и што може да направи тој ако е успешен, немам никаква идеја. Знам што сакам да правам со него во моментов. Правам блог за сите ентузијасти на програмирање и алгоритми, и сите што се заинтересирани да научат нешто.

Во моментов волонтирам како „професор“ за алгоритми и податочни структури, бидејќи уживам во споделување на знаење. Допринесувам кон општеството, а во меѓувреме и своето знаење го надоградувам. Едно е кога знаеш да искористиш еден алгоритам, друго е кога треба да го упростиш и објасниш на некого што прв пат го гледа истиот. Но, бидејќи еден час неделно по претходно дефинирана програма не ми е доволно, се одлучив да разјаснувам алгоритми и тука.

Што поточно ќе пишувам? Најчесто ќе постирам анализи и свои решенија на задачи од натпреварите на кои учествувам (најчесто Codeforces и Topcoder), но исто така ќе пишувам и за нови работи кои штотуку сум ги научил.

За кого? Се надевам дека информациите би биле корисни за било кој. За почетниците кои со ова би научиле како да размислуваат и решаваат задачи, па до напредните програмери на кои можеби би нашле различен начин на решавање и размислување од нивниот.

Се гледаме во некој од наредните постови!]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>5</wp:post_id>
  <wp:post_date>2015-02-19 22:23:32</wp:post_date>
  <wp:post_date_gmt>2015-02-19 22:23:32</wp:post_date_gmt>
  <wp:post_modified>2015-02-20 13:24:44</wp:post_modified>
  <wp:post_modified_gmt>2015-02-20 13:24:44</wp:post_modified_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>hello-world</wp:post_name>
  <wp:status>publish</wp:status>
  <wp:post_parent>0</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>post</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <category domain="category" nicename="%d0%b4%d1%80%d1%83%d0%b3%d0%be"><![CDATA[Друго]]></category>
  <wp:postmeta>
    <wp:meta_key>_edit_last</wp:meta_key>
    <wp:meta_value><![CDATA[55813594]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>geo_public</wp:meta_key>
    <wp:meta_value><![CDATA[0]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_publicize_pending</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
</item>
<item>
  <title>Codeforces Round #292</title>
  <link>https://aandevski.wordpress.com/2015/02/20/codeforces-round-292/</link>
  <pubDate>Fri, 20 Feb 2015 01:17:32 +0000</pubDate>
  <dc:creator>add1ctus</dc:creator>
  <guid isPermaLink="false">https://aandevski.wordpress.com/?p=7</guid>
  <description/>
  <content:encoded><![CDATA[За прв пост на овој блог ќе го искористам неодамнешниот Codeforces натпревар. По кратката посета на прва дивизија (само еден натпревар, каде не решив ништо), за овој натпревар повторно бев во втората. Со други зборови, прелесна прва задача и многу страшни кодови за читање при хакирање туѓи решенија.

Успеав да решам 3 задачи и да стигнам до 53-тото место, моето најголемо достигнување досега на Codeforces. Релативно лесни задачи, со исклучок на последните две кои едвај имаа 50 точни решенија (двете задачи заедно). Без да одолговлекувам многу, ова беа моите решенија.<!--more-->
<h1>A - Drazil and Date</h1>
<a href="http://codeforces.com/contest/515/problem/A" target="_blank">Текст од задачата</a>

Во задачата се работи за Drazil кој тврди дека од точка (0,0) до точка (a,b) има стигнато за S чекори (се работи за Декартов координатен систем). Тој може да се движи само во 4 насоки (горе, доле, лево, десно) Вашата задача е да проверите дали тоа е вистина или не (да испечатите "yes" или "no").

Стандардно за прва задача, решението беше доста просто. Бидејќи имаме само 4 насоки на движење, секогаш најкраткиот пат до (a,b) ќе е |a| + |b| (збир на апсолутните вредности на овие два броја). Доколку S е помало од |a| + |b|, знаеме дека не може да се стигне до таа точка. Доколку S е еднакво, тогаш најкраткиот пат е решението. Но доколку S е поголемо, тогаш Drazil би требало да оди напред/назад неколку чекори за да заврши на (a,b) после S чекори. За да го направи ова, потребни му се парен број на преостанати чекори (S - (|a| + |b|) ), бидејќи во спротивно нема да може да го направи напред/назад движењето и ќе остане на некое друго поле, а не на (a,b).

Така да решението беше : доколку s&gt;= |a| + |b| и (s - (|a| + |b|))%2==0, печатиме "Yes". Во спротивно, "No".

<a href="http://codeforces.com/contest/515/submission/9885156" target="_blank">Решение во C++</a>
<h1>B - Drazil and his happy friends</h1>
<a href="http://codeforces.com/contest/515/problem/B" target="_blank">Текст од задачата</a>

За оваа задача немав идеја при првото читање, туку и се вратив на неа по решавање на третата. Во проблемот нашиот лик има N машки и M женски пријатели (нумерирани од 0 до M или N, највеќе 100), од кои некои се среќни, а некои тажни. Тој решава да ги направи сите среќни така што секој ден (почнувајќи од 0) тој ги поканува (i%n)-тото момче и (i%m)-тата девојка заедно на вечера. Доколку една од овие две личности е среќна, и другата станува среќна (и така остануваат среќни засекогаш). Но доколку не е никој од нив среќен, си остануваат несреќни. Од вас се бара да откриете дали со овој план сите ќе станат среќни (не е битно по колку дена).

Мојата грешка во натпреварот е што претпоставив дека brute-force решение нема да заврши за 2 секунди. Се испостави дека можеме да ги симулираме деновите еден по еден до некоја голема бројка (пример, милион дена), следејќи ги правилата. По тоа, доволно беше само да ги проверите сите пријатели (максимум 200), да проверите дали се сите среќни. Печатиме "Yes" доколку се, во спротивно "No".

[caption id="attachment_9" align="alignright" width="301"]<a href="https://aandevski.files.wordpress.com/2015/02/screenshot_2.png"><img class="wp-image-9 size-full" src="https://aandevski.files.wordpress.com/2015/02/screenshot_2.png" alt="Пример за граф со 2 машки и 4 женски" width="301" height="139" /></a> Пример за граф со 2 машки и 4 женски[/caption]

Моето решение беше малку поинакво. Доколку бројот на момчиња и девојчиња е ист, секогаш истите парови ќе се повторуваат. Но, доколку бројот е различен, тогаш ќе имаме повеќе различни парови (момче 1 може да излезе со девојка 1, па следниот пат со девојка 3, итн). Според ова направив граф, каде што темињата се машките и женските пријатели, а има врска помеѓу нив доколку некогаш би излегле на вечера. За да утврдам дали би излегле некогаш на вечера морав да употребам brute-force симулација, но за разлика од горенаведената, мојата симулација требаше да се изврши само за N*M дена за да ги добијам сите можни парови. Со добиениот граф, се што преостануваше е да извршам пребарување низ него (користев DFS во овој случај), започнувајќи од сите пријатели што се среќни и проширувајќи се кон сите поврзани темиња. На крајот само останува да провериме дали се сите среќни и да го испечатиме резултатот.

<a href="http://codeforces.com/contest/515/submission/9895082" target="_blank">Решение во C++</a>
<h1>C - Drazil and factorial</h1>
<a href="http://codeforces.com/contest/515/problem/C" target="_blank">Текст од задачата</a>

Вообичаено третата задача е многу потешка, но не и на овој натпревар. Имаме дефинирано функција F(x) како производ од факториелите на неговите цифри. На пример, F(135) = 1! * 3! * 5!. За оние што не знаат што е факториел, тоа е производ на сите броеви од 1 до тој број. Пример, 5! = 1 * 2 * 3 * 4 * 5.

Сега, назад на задачата. За даден број A, потребно беше да го најдеме најголемиот можен број X така што F(A) = F(X). При тоа, не смееме да ги користиме цифрите 0 и 1 во X.

За да добиеме најголем број, треба да го добиеме најголемиот можен број на цифри. Така да потребно е сите факториели на броевите 2-9 да ги разложиме на што помали факториели. Бидејќи нема многу комбинации, ова можете да го пресметате и со лист и пенкало. Пресметките се следни:
<ul>
	<li>9! = 7! * 3! * 3! * 2!</li>
	<li>8! = 7! * 2! * 2! * 2!</li>
	<li>6! = 5! * 3!</li>
	<li>4! = 3! * 2! * 2!</li>
</ul>
Останатите броеви не можат да се разложат.

Кога веќе го знаеме ова, потребно беше само да го прочитаме бројот (што јас го направив со char, за да не мора да ги вадам цифрите од бројот една по една) и секоја цифра од горенаведената листа да ја разложиме на повеќе помали цифри. Бидејќи само цифрите 2, 3, 5 и 7 се појавуваат, можеме само да броиме која цифра колку пати ќе треба да ја има во резултатот. Потоа само треба да го испечатиме резултатот, со тоа што прво ги печатиме сите цифри 7, па 5, па 3 и на крајот 2 (за да добиеме што е можно поголем број).

<a href="http://codeforces.com/contest/515/submission/9891225" target="_blank">Решение во C++</a>
<h1>D - Drazil and tiles</h1>
<a href="http://codeforces.com/contest/515/problem/D" target="_blank">Текст од задачата</a>

Како и вообичаено, не успеав да ја решам 4тата задача, и овој пат заради лоша претпоставка. Имаме NxM табла која треба да ја пополниме со 1x2 коцки (замислете домино коцки). При тоа, на некои полиња (означени со *), не треба да ставиме коцка. Нашата задача е да провериме дали е тоа возможно, и на колку начина. Доколку постои само еден распоред на коцките, го печатиме распоредот, во спротивно (доколку има повеќе од еден начин или пак нема ниту еден), печатиме "Not unique".

[caption id="attachment_13" align="alignleft" width="159"]<a href="https://aandevski.files.wordpress.com/2015/02/screenshot_31.png"><img class="size-full wp-image-13" src="https://aandevski.files.wordpress.com/2015/02/screenshot_31.png" alt="Трите начина да ставиме коцка на некое поле од работ." width="159" height="166" /></a> Трите начина да ставиме коцка на некое поле од работ.[/caption]

На сите полиња кои се наоѓаат на работ на таблата можат да се стават коцки на 3 различни начина. На сите полиња од средина пак можеме да ставиме коцки на 4 начина, и 2 начина за ќошевите. Така да секогаш имаме повеќе начини за решавање. Но, благодарение на полињата означени со * (каде што не смееме да ставиме коцка), постојат полиња каде што имаме само еден начин на поставување. Во некој случај, доколку ставиме коцка на такво поле, се створаат нови полиња со само еден начин на поставување (бидејќи вториот им сме го покриле). Така продолжуваме се додека не стигнеме до полна табла. Доколку во некој момент немаме полиња со еден начин на поставување, печатиме "Not unique".

Пристапот за решавање е greedy (а мојата претпоставка беше дека greedy нема да даде точен одговор). И во оваа задача правиме граф, каде што секое поле е теме во графот и е поврзано со неговите соседни полиња. Правиме додатна низа каде што за секое поле бележиме со колку други полиња е поврзано (колку начини на поставување на коцка постојат). И за крај правиме queue во кој ги ставаме сите полиња кои имаат само едно соседно поле. Потоа, се додека има полиња во queue, ги вадиме едно по едно, и за сите негови соседни полиња им го намалуваме бројот на поврзани полиња за еден (и ги додаваме во queue доколку е потребно). Кога ќе стигнеме до празен queue, проверуваме дали сите полиња се покриени. Доколку не се, нема решение.

Оваа задача сеуште ја немам решено, а петата ја немам ни прочитано. Се надевам дека ќе ги решам во блиска иднина и ќе го изменам постот.]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>7</wp:post_id>
  <wp:post_date>2015-02-20 01:17:32</wp:post_date>
  <wp:post_date_gmt>2015-02-20 01:17:32</wp:post_date_gmt>
  <wp:post_modified>2015-03-22 13:07:02</wp:post_modified>
  <wp:post_modified_gmt>2015-03-22 12:07:02</wp:post_modified_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>codeforces-round-292</wp:post_name>
  <wp:status>publish</wp:status>
  <wp:post_parent>0</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>post</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <category domain="post_tag" nicename="ad-hoc"><![CDATA[Ad hoc]]></category>
  <category domain="category" nicename="codeforces"><![CDATA[codeforces]]></category>
  <category domain="post_tag" nicename="dfs"><![CDATA[DFS]]></category>
  <category domain="post_tag" nicename="%d0%bc%d0%b0%d1%82%d0%b5%d0%bc%d0%b0%d1%82%d0%b8%d0%ba%d0%b0"><![CDATA[Математика]]></category>
  <wp:postmeta>
    <wp:meta_key>_edit_last</wp:meta_key>
    <wp:meta_value><![CDATA[55813594]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>geo_public</wp:meta_key>
    <wp:meta_value><![CDATA[0]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_publicize_pending</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_facebook</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_google_plus</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_twitter</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_linkedin</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_tumblr</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_path</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
</item>
<item>
  <title>CF292B</title>
  <link>https://aandevski.wordpress.com/2015/02/20/codeforces-round-292/screenshot_2/</link>
  <pubDate>Fri, 20 Feb 2015 01:09:52 +0000</pubDate>
  <dc:creator>add1ctus</dc:creator>
  <guid isPermaLink="false">http://aandevski.files.wordpress.com/2015/02/screenshot_2.png</guid>
  <description/>
  <content:encoded><![CDATA[Пример за граф со 2 машки и 4 женски]]></content:encoded>
  <excerpt:encoded><![CDATA[Пример за граф со 2 машки и 4 женски]]></excerpt:encoded>
  <wp:post_id>9</wp:post_id>
  <wp:post_date>2015-02-20 01:09:52</wp:post_date>
  <wp:post_date_gmt>2015-02-20 01:09:52</wp:post_date_gmt>
  <wp:post_modified>2015-02-20 01:10:17</wp:post_modified>
  <wp:post_modified_gmt>2015-02-20 01:10:17</wp:post_modified_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>screenshot_2</wp:post_name>
  <wp:status>inherit</wp:status>
  <wp:post_parent>7</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>attachment</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <wp:attachment_url>https://aandevski.files.wordpress.com/2015/02/screenshot_2.png</wp:attachment_url>
  <wp:postmeta>
    <wp:meta_key>_wp_attachment_image_alt</wp:meta_key>
    <wp:meta_value><![CDATA[Пример за граф со 2 машки и 4 женски]]></wp:meta_value>
  </wp:postmeta>
</item>
<item>
  <title>CF292D</title>
  <link>https://aandevski.wordpress.com/2015/02/20/codeforces-round-292/screenshot_3/</link>
  <pubDate>Fri, 20 Feb 2015 01:13:48 +0000</pubDate>
  <dc:creator>add1ctus</dc:creator>
  <guid isPermaLink="false">http://aandevski.files.wordpress.com/2015/02/screenshot_3.png</guid>
  <description/>
  <content:encoded><![CDATA[Два начина (црвено и сино) да се стави коцка врз црното поле.]]></content:encoded>
  <excerpt:encoded><![CDATA[Два начина (црвено и сино) да се стави коцка врз црното поле.]]></excerpt:encoded>
  <wp:post_id>11</wp:post_id>
  <wp:post_date>2015-02-20 01:13:48</wp:post_date>
  <wp:post_date_gmt>2015-02-20 01:13:48</wp:post_date_gmt>
  <wp:post_modified>2015-02-20 01:14:13</wp:post_modified>
  <wp:post_modified_gmt>2015-02-20 01:14:13</wp:post_modified_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>screenshot_3</wp:post_name>
  <wp:status>inherit</wp:status>
  <wp:post_parent>7</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>attachment</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <wp:attachment_url>https://aandevski.files.wordpress.com/2015/02/screenshot_3.png</wp:attachment_url>
  <wp:postmeta>
    <wp:meta_key>_wp_attachment_image_alt</wp:meta_key>
    <wp:meta_value><![CDATA[Два начина (црвено и сино) да се стави коцка врз црното поле.]]></wp:meta_value>
  </wp:postmeta>
</item>
<item>
  <title>CF292D</title>
  <link>https://aandevski.wordpress.com/2015/02/20/codeforces-round-292/screenshot_3-2/</link>
  <pubDate>Fri, 20 Feb 2015 01:16:47 +0000</pubDate>
  <dc:creator>add1ctus</dc:creator>
  <guid isPermaLink="false">http://aandevski.files.wordpress.com/2015/02/screenshot_31.png</guid>
  <description/>
  <content:encoded><![CDATA[Трите начина да ставиме коцка на некое поле од работ.]]></content:encoded>
  <excerpt:encoded><![CDATA[Трите начина да ставиме коцка на некое поле од работ.]]></excerpt:encoded>
  <wp:post_id>13</wp:post_id>
  <wp:post_date>2015-02-20 01:16:47</wp:post_date>
  <wp:post_date_gmt>2015-02-20 01:16:47</wp:post_date_gmt>
  <wp:post_modified>2015-02-20 01:17:10</wp:post_modified>
  <wp:post_modified_gmt>2015-02-20 01:17:10</wp:post_modified_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>screenshot_3-2</wp:post_name>
  <wp:status>inherit</wp:status>
  <wp:post_parent>7</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>attachment</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <wp:attachment_url>https://aandevski.files.wordpress.com/2015/02/screenshot_31.png</wp:attachment_url>
  <wp:postmeta>
    <wp:meta_key>_wp_attachment_image_alt</wp:meta_key>
    <wp:meta_value><![CDATA[Трите начина да ставиме коцка на некое поле од работ.]]></wp:meta_value>
  </wp:postmeta>
</item>
<item>
  <title>Мендо - Бонбони</title>
  <link>https://aandevski.wordpress.com/2015/02/20/%d0%bc%d0%b5%d0%bd%d0%b4%d0%be-%d0%b1%d0%be%d0%bd%d0%b1%d0%be%d0%bd%d0%b8/</link>
  <pubDate>Fri, 20 Feb 2015 13:19:00 +0000</pubDate>
  <dc:creator>add1ctus</dc:creator>
  <guid isPermaLink="false">https://aandevski.wordpress.com/?p=16</guid>
  <description/>
  <content:encoded><![CDATA[Вообичаено при барање на решение на некој проблем или задача, размислувам за повеќе начини на решавање, дури и да не се очигледни. Понекогаш и ќе се изненадите колку различни проблеми можете да претставите како некој вид на граф, каква релација можете да најдете со динамичко програмирање или на какви задачи може greedy да даде точен резултат. Едно од нештата на кое не ми текнува вообичаено се бројните системи и како може тие да се искористат за упростување на некоја задача.

Една таква задача е <a href="http://mendo.mk/Task.do?id=44">Бонбони</a>, од регионалниот натпревар по програмирање од 2010. Во задачата имаме двајца браќа, Нино и Тино, на кои нивната тетка треба да им купи бонбони. Проблемот е во следново : таа има купено само еден пакет од N бонбони кој треба да го даде на Нино. За да не ги разочара децата, мора да купи и додатни пакети за Тино, така да Нино и Тино имаат еднаков број на бонбони.<!--more-->

Секако, оваа задача би била прелесна на овој начин. Додатното ограничување што ја прави оваа задача интересна е тоа што можете да купувате само пакети со број на бонбони - степен на 3. Така да можеме да користиме само пакети со 1, 3, 9, 27, 81, 243 бонбони итн.. (множиме со 3). На пример, доколку Нино има 12 бонбони, единственото решение е да се купат пакети со 3 и 9 бонбони за Тино (и двата броја се степен на 3). Друг пример би бил со 17 бонбони, каде што на Нино би требало да му додадеме пакети од 1 и 9 бонбони, а на Тино пакет од 27 бонбони, така да тие би имале еднаков број.
<h1>Бројни системи</h1>
Со промените во програмите секоја година, веќе и не сум сигурен кои ученици имаат учено за бројни системи, а кои не, па решив да објаснам во случај некој да ги нема сретнато. Доколку знаете што се бројни системи, можете да прескокнете до наредниот дел, каде ги користиме за решавање на задачата.

Сите знаеме дека компјутерите работат само со броевите 0 и 1, кои внатре во деловите се претставени како висока или ниска струја (волтажа, поточно). Така да кога компјутерот на пример треба да пресмета збир на два броја, тој треба тие два броја од нашиот декаден систем (со 10 цифри, од 0 до 9) да го претвори во бинарен броен систем (со 2 цифри, 0 и 1).

И двата бројни системи се позициони бројни системи, што значи дека редоследот на броевите е важен, и секоја цифра има различна тежина. Така да броевите 21 и 12 се различни, иако имаат исти цифри.

На пример, бројот 123 би можеле да го претставиме како 1 * 100 + 2 * 10 + 3 * 1, што е исто еднакво како 123. Доколку броевите 100, 10 и 1 ги претставиме како степен со основа 10 (зошто 10? бидејќи како што рековме, декадниот систем има 10 цифри), тогаш овој број би бил 1 * 10<sup>2</sup> + 2 * 10<sup>1</sup> + 3 * 10<sup>0</sup>. Го приметувате шаблонот? Почнувајќи од десно со тежина 10<sup>0</sup>, секоја наредна цифра има поголема тежина за 1 степен. 4-тата цифра би имала степен 10<sup>3</sup>, 5-тата цифра степен 10<sup>4</sup>, итн..

На ист начин функционираат сите други бројни системи. На пример, доколку сакаме да го претставиме бројот 5 во бинарниот систем, тоа би изгледало вака: 1 * 2<sup>2</sup> + 0 * 2<sup>1</sup> + 1 * 2<sup>0</sup>. За да претвориме некој број од декаден во друг броен систем, го делиме бројот со основата на новиот броен систем и го запишуваме остатокот.

5 / 2 = 2 и остаток 1
2 / 2 = 1 и остаток 0
1 / 2 = 0 и остаток 1

Кога стигнеме до бројот 0, завршуваме со делењето, и го запишуваме остатокот, во обратен редослед (во овој случај, од доле - нагоре). Така да бројот 5 во декадниот систем може да се запише како 101. Истово правило важи за било кој броен систем како окталниот (со основа 8), хексадецималниот (со основа 16) итн.

Собирањето на два броја се врши на ист начин. Можеме да ги ставиме двата броја еден врз друг (порамнето од десна страна), и почнувајќи од десната страна да ги собираме цифрите кои се една врз друга. Притоа, доколку на пример работиме со бинарниот броен систем, и треба да собереме 1 + 1, не смееме да запишеме 2  (бидејќи бројниот систем работи само со 0 и 1), туку запишуваме 0, и 1 го додаваме во колоната лево (го паметиме).
<h1>Назад на задачата</h1>
Сега кога веќе знаеме како работат бројните системи, како може нив да ги искористиме во задачата? Клучна забелешка е фактот дека пакетите со бонбони кои можеме да ги купиме секогаш содржат 3<sup>x</sup> бонбони, каде што x е некој произволен број. Доколку ги претставиме пакетите во броен систем со основа 3, тогаш пакетите 1, 3, 9, 27 би изгледале вака :

1<sub>(декаден)</sub> = 1<sub>(основа 3)</sub>
3<sub>(декаден)</sub> = 10<sub>(основа 3)</sub>
9<sub>(декаден)</sub> = 100<sub>(основа 3)</sub>
27<sub>(декаден)</sub> = 1000<sub>(основа 3)</sub>

Приметуваме дека секој број има 1 како прва цифра, и сите останати се 0. Се што преостанува е како да го искористиме ова. Знаеме дека Нино веќе има добиено некој број на бонбони, што можеби и не може да се претстави со прва цифра 1 и останати 0 во овој броен систем. На пример, бројот 17 (примерот ставен заедно со задачата) е 122 во систем со основа 3. Но бидејќи ние на Тино не можеме да му земаме само бонбони кои имаат 1 и 0 како цифри, и не можеме да земеме два или повеќе исти пакета, знаеме дека бројот 122 не можеме да го добиеме никогаш.

Првото нешто што е потребно е да му дадеме на Нино неколку пакети, така да добиеме број само со цифри 0 и 1, за да можеме на Тино да му ја дадеме истата количина. Почнувајќи од десната страна, треба да се ослободиме од двојките во тој број. Го додаваме бројот 1 (пакет со една бонбона) на 122 за да се ослободиме од двојката десно.

122
+001
-------
200

Сега имаме двојка на третата позиција, така да треба да го додадеме бројот 100 (пакет од 9 бонбони) за да се ослободиме и од таа двојка.

200
+100
-------
1000

Значи откако ќе му дадеме на Нино пакет со 1 и 9 бонбони, тој има 27 бонбони. Се што преостанува е да го изедначиме тој број за Тино, или да му го дадеме пакетот со 27 бонбони, и со ова е решена задачата.
<h1>Пишување на кодот</h1>
Според објаснетиот начин на решавање, ние би требало да го претвориме N во број со основа 3, да го зачуваме во некоја низа цифра по цифра, па тогаш да му додаваме други броеви со основа 3 (и да запишуваме кои сме ги додале), па да го претвориме резултатот назад во декаден броен систем за да го испечатиме. Дали можеме поефикасно од тоа?

Клучна забелешка тука е дека запишувањето на броеви во основа 3 и нивното собирање се врши на ист начин - од десно кон лево. Така да наместо да го претвораме бројот па после да вршиме собирање, ние можеме во исто време да ги правиме и двете работи.

Како го делиме бројот N со 3 и добиваме остаток, тој остаток не го запишуваме, туку веднаш го користиме. Доколку остатокот е 2, значи имаме двојка од која треба да се ослободиме, и му додаваме на Нино пакет кој има 1 на таа позиција. Доколку остатокот е 1, тогаш треба и на Тино да му додадеме пакет кој има 1 на таа позиција (за да имаат и двајцата ист број на бонбони). И доколку остатокот е 0, тогаш на никого не даваме пакет (бидејќи ќе имаат ист број на бонбони на таа позиција). Притоа е важно правилото за собирање на броеви, каде што рековме дека доколку некој број ги надминува границите (на пример кога на некоја двојка додадеме 1, станува 3), не запишуваме 3, туку запишуваме 0 и паметиме 1 за следната цифра. Така да секогаш кога остатокот е 2, му даваме пакет на Нино, но на бројот што го делиме додаваме +1. Исто како што претворањето на број во друг броен систем се врши со делење се додека не стигнеме до 0, исто така и овој алгоритам работи се додека бројот не стигне до 0.

За да паметиме кој пакет на кого го имаме дадено, најпрактично е да користиме вектор. Доколку не сте запознаени со вектори, ви препорачувам да го прочитате <a href="http://mendo.mk/Lecture.do?id=19">ова</a> (на кратко, векторите во програмирање се нешто налик низи, само со променлива големина и додатни функции). Се што преостанува е да ги сортираме двата вектора и да ги испечатиме на крајот.

<a href="http://pastebin.com/zNVKd0pH">Решение во C++</a>]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>16</wp:post_id>
  <wp:post_date>2015-02-20 14:19:00</wp:post_date>
  <wp:post_date_gmt>2015-02-20 13:19:00</wp:post_date_gmt>
  <wp:post_modified>2015-03-22 13:07:51</wp:post_modified>
  <wp:post_modified_gmt>2015-03-22 12:07:51</wp:post_modified_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>%d0%bc%d0%b5%d0%bd%d0%b4%d0%be-%d0%b1%d0%be%d0%bd%d0%b1%d0%be%d0%bd%d0%b8</wp:post_name>
  <wp:status>publish</wp:status>
  <wp:post_parent>0</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>post</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <category domain="post_tag" nicename="%d0%bc%d0%b0%d1%82%d0%b5%d0%bc%d0%b0%d1%82%d0%b8%d0%ba%d0%b0"><![CDATA[Математика]]></category>
  <category domain="category" nicename="%d0%bc%d0%b5%d0%bd%d0%b4%d0%be"><![CDATA[мендо]]></category>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_google_plus</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_facebook</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_twitter</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_linkedin</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_tumblr</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_path</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_rest_api_published</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_rest_api_client_id</wp:meta_key>
    <wp:meta_value><![CDATA[-1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_edit_last</wp:meta_key>
    <wp:meta_value><![CDATA[55813594]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>geo_public</wp:meta_key>
    <wp:meta_value><![CDATA[0]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_publicize_pending</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
</item>
<item>
  <title>Topcoder SRM 650</title>
  <link>https://aandevski.wordpress.com/2015/02/20/topcoder-srm-650/</link>
  <pubDate>Fri, 20 Feb 2015 18:49:32 +0000</pubDate>
  <dc:creator>add1ctus</dc:creator>
  <guid isPermaLink="false">https://aandevski.wordpress.com/?p=24</guid>
  <description/>
  <content:encoded><![CDATA[Последниот натпревар на кој учествував е Topcoder SRM 650 во прва дивизија, каде што целта ми е да ја решам првата задача (од трите вкупно), со што скоро секогаш добивам рејтинг (освен ако не ја решам премногу споро). За среќа, овој натпревар имаше невообиачено лесна задача, но затоа втората (само 12 точни решенија) и третата (само едно точно решение - Endagorion од Русија) беа претешки. Заради тежината на првата задача, успеав да ја решам за неполни 12 минути со кое го освоив 76-тото место, што е мојот најголем успех на Topcoder (и ми донесе повеќе од 100 рејтинг!!!). Да не одложувам повеќе, ова е објаснувањето на задачата која ја решив.<!--more-->
<h1>250 - Taro filling a string</h1>
<a href="http://community.topcoder.com/stat?c=problem_statement&amp;pm=13669&amp;rd=16314">Текст од задачата</a>

Во задачата се збори за некој стринг од должина N, кој е исполнет само со карактери A и B. Не ни е даден целиот стринг, туку само буквите на неколку места (на пример, за стринг со должина 10 карактера, вас можат само да ви кажат дека 4тата буква е А). Максималната должина на стрингот е 1,000,000,000, и највеќе 50 букви ќе ви се веќе откриени. Од вас се бара да ги пополните останатите букви, така да го минимизирате бројот на исти букви една до друга. Така да доколку ни е даден стрингот A__B, лош стринг е AABB, а добар стринг е ABAB. Во некои случаи (како на пример A_BA_) е неизбежно да имаме две исти букви една до друга, така да треба да го минимизираме тој број (тука решението е ABBAB или AABAB). Но во задачата не ни се бара да го испечатиме стрингот како резултат, туку да испечатиме колку различни начини има за оптимално пополнување на стрингот, по модул 1,000,000,007 (да го испечатиме остатокот при делење на резултатот со овој број).

Задачата можеме да ја поделиме на повеќе подпроблеми - полиња измеѓу две дадени букви. Пример за стрингот <span style="color:#3366ff;">__</span>A<span style="color:#ff0000;">__</span>BA<span style="color:#00ff00;">_</span>, имаме 3 различни такви полиња (означени со 3 различни бои). Потребно е да најдеме за секое такво поле колку различни начина имаме на оптимално пополнување, и потоа сите броеви да ги помножиме, со што би го добиле резултатот.

Прво нешто што можеме да заклучиме е дека полињата од лево и десно секогаш имаат само еден начин за оптимално пополнување, каде што нема ни една буква една до друга. Така да за __A, мора да пополниме со ABA. Исто така и A_ мора да пополниме со BAB. Другите решенија не се оптимални. Кога тие ги решиме, остануваат само полињата ограничени од две страни, како A__B. Кај нив имаме 4 случаи :
<ul>
	<li>Двете букви од страна се исти и имаме непарен број на празни места</li>
	<li>Двете букви од страна се различни и имаме парен број на празни места</li>
	<li>Двете букви од страна се различни и имаме непарен број на празни места</li>
	<li>Двете букви од страна се исти и имаме парен број на празни места</li>
</ul>
За првите два случаја секогаш имаме само еден начин на оптимално пополнување. За првиот случај, за A_A оптималното е ABA. За A___A оптималното е ABABA. Исто и за вториот, A__B има единствено решение ABAB и B____A има единствено решение BABABA.

Така да остануваат два случаи. Доклку земеме за пример A_B од третиот случај, двете можности се ABB и AAB, што значи дека мора да имаме најмалку еден пар исти букви што се заедно. Истото се случува и кај четвртиот пример со пример A__A, каде што валидните решенија се AABA, ABBA, ABAA, сите со по еден пар исти букви. Секако, постои и решението AAAA, но тоа не е оптималното во овој случај. Со 1 празно место имавме 2 можни пара, со 2 празни места 3 можни пара, итн. Така да за секое поле со X празни места од третиот и четврт случај, имаме можни X+1 начини за оптимално пополнување.

Така да потребно е низите да ги сортираме прво, и потоа да ги изминуваме сите парови, мерејќи го местото меѓу нив и проверувајќи дали имаат само 1 начин или повеќе. Доколку имаме повеќе начини, ги додаваме во производот. Важно е при секое додавање да направиме и модул на производот, за да не добиеме преголем број кој би излегол надвор од опсегот на long long.

<a href="http://community.topcoder.com/stat?c=problem_solution&amp;rm=325209&amp;rd=16314&amp;pm=13669&amp;cr=23148678">Решение во C++</a>]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>24</wp:post_id>
  <wp:post_date>2015-02-20 19:49:32</wp:post_date>
  <wp:post_date_gmt>2015-02-20 18:49:32</wp:post_date_gmt>
  <wp:post_modified>2015-03-22 13:08:33</wp:post_modified>
  <wp:post_modified_gmt>2015-03-22 12:08:33</wp:post_modified_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>topcoder-srm-650</wp:post_name>
  <wp:status>publish</wp:status>
  <wp:post_parent>0</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>post</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <category domain="post_tag" nicename="ad-hoc"><![CDATA[Ad hoc]]></category>
  <category domain="post_tag" nicename="%d1%81%d1%82%d1%80%d0%b8%d0%bd%d0%b3%d0%be%d0%b2%d0%b8"><![CDATA[Стрингови]]></category>
  <category domain="category" nicename="topcoder"><![CDATA[Topcoder]]></category>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_path</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_tumblr</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_linkedin</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_twitter</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_google_plus</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_facebook</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_edit_last</wp:meta_key>
    <wp:meta_value><![CDATA[55813594]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_publicize_pending</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>geo_public</wp:meta_key>
    <wp:meta_value><![CDATA[0]]></wp:meta_value>
  </wp:postmeta>
</item>
<item>
  <title>Мендо - Училишен натпревар 2015</title>
  <link>https://aandevski.wordpress.com/2015/02/20/%d0%bc%d0%b5%d0%bd%d0%b4%d0%be-%d1%83%d1%87%d0%b8%d0%bb%d0%b8%d1%88%d0%b5%d0%bd-%d0%bd%d0%b0%d1%82%d0%bf%d1%80%d0%b5%d0%b2%d0%b0%d1%80-2015/</link>
  <pubDate>Fri, 20 Feb 2015 19:43:54 +0000</pubDate>
  <dc:creator>add1ctus</dc:creator>
  <guid isPermaLink="false">https://aandevski.wordpress.com/?p=27</guid>
  <description/>
  <content:encoded><![CDATA[<strong>Едит</strong>: Имав грешка во втората задача, поправено.

По 7 години натпреварување, ова ми е првата година како не учествувам на циклус натпревари по информатика. Иако не учествував, не можев да не ги разгледам задачите и да пробам да ги решам. Генерално интересен натпревар, со интересни задачи (посебно третата, која бараше неколку внимателни обзервации), кои сепак не бараа некое напредно знаење од алгоритми, само креативност. Ова беа моите решенија за првите 4 задачи. Последната задача е напишана како <a href="https://aandevski.wordpress.com/2015/02/22/%D0%BC%D0%B5%D0%BD%D0%B4%D0%BE-%D0%B2%D0%B5%D0%BB%D0%BE%D1%81%D0%B8%D0%BF%D0%B5%D0%B4%D1%81%D0%BA%D0%B0-%D0%BF%D0%B0%D1%82%D0%B5%D0%BA%D0%B0/">посебен пост</a>.<!--more-->
<h1>Пуфи и Стојче</h1>
<h4><a href="http://mendo.mk/Task.do?competition=218&amp;id=532">Текст од задачата</a></h4>
Генерално лесна задача, каде што ни се дадени 3 броја и ние треба да ги собереме и да видиме колку треба да се додаде на тој број за да биде делив со 3. Потребни ни беа 3 променливи, и го проверуваме остатокот на нивниот збир при делење со 3 (со модул). Потребни ни беа 3 if-а.
<ul>
	<li>Доколку остатокот е 0, веќе е делив бројот со 3, не додаваме ништо</li>
	<li>Доколку остатокот е 1, треба да додадеме уште 2 за да добиеме број делив со 3</li>
	<li>Доколку остатокот е 2, треба да додадеме уште 1 за да добиеме број делив со 3</li>
</ul>
<a href="http://pastebin.com/ZuUy5Qyd">Решение во C++</a>

Исто така можеше ова да се реши и со печатење на следнава формула:
(3-(x+y+z)%3)%3
<h1>Бакшиш</h1>
<a href="http://mendo.mk/Task.do?competition=218&amp;id=528">Текст од задачата</a>

Навидум лесна задача, но има доста простор за грешки. Клучна забелешка е тоа што имаме само 100 милисекунди за пресметување на одговорот, и со броеви од 1 до 2,000,000,000, не смееме да користиме било какви циклуси, туку мора математички да го пресметаме резултатот.

Еден начин да го направиме тоа е да ги најдеме опсегот во кој треба да пресметаме колку броеви деливи со 5 има. Од двете страни опсегот го ограничуваме според процентот на бакшишот - 5% и 10%. Но од десната страна, доколку бакшишот е поголем од буџетот што го имаме, тогаш десната граница ни е буџетот.

Доста простор за грешка има при пресметување на бакшишот, кој треба да е помеѓу 5% и 10% <strong>од вкупната сума</strong>, а не од износот на сметката. Да разјасниме. Доколку бакшишот е 5% од вкупната сума, тогаш во формулата

цена на сметка + бакшиш = вкупна сума

заменуваме

цена на сметка + 5/100 вкупна сума = вкупна сума
цена на сметка = вкупна сума - 5/100 вкупна сума
цена на сметка = 95/100 вкупна сума
цена на сметка = 19/20 вкупна сума
цена на сметка / (19/20) = вкупна сума
20 * цена на сметка / 19 = вкупна сума

Со последната формула знаеме колку е вкупната сума што треба да ја платиме при 5% бакшиш. На ист начин ја добиваме и формулата за сумата при 10% бакшиш, што изнесува 10 * цена на сметка / 9. Ги запишуваме овие два броја во две посебни променливи, притоа заокружувајќи го првиот број кон следбеникот (со ceil), а вториот кон претходникот (со floor), и го споредуваме вториот број со буџетот кој го имаме. Доколку буџетот е помал, тогаш вториот број е еднаков на буџетот.

Сега кога го имаме опсегот, за да го пресметаме резултатот прво е потребно да ги заокружиме двата броја на некој број делив со 5. Доколку првиот број не е делив со 5, треба да го зголемиме за да биде делив со 5 (слично нешто како првата задача?), т.е. да му додадеме 5-(X%5) (каде што X е тој број). Додека кај вториот број, потребно е да го намалиме (за да не надминеме 10% бакшиш или буџет), т.е. да му одземеме X%5.

Доколку сме ги запишале двата броја во mincena и makscena променливите, сега за печатење на решението, имаме 2 случаја :
<ul>
	<li>mincena&gt;makscena. Во овој случај буџетот не ни дозволува да платиме никаков бакшиш, така да печатиме 0.</li>
	<li>mincena&lt;=makscena. Во овој случај можеме да платиме барем еден бакшиш. Со makscena-mincena ќе го добиеме бројот на различни вредности измеѓу овие 2 броја, но бидејќи ни се потребни само вредностите деливи со 5, го делиме овој број со 5 и додаваме 1 (за да ја броиме и првата вредност во опсегот).</li>
</ul>
<a href="http://pastebin.com/FcwTUaMs">Решение во C++</a>
<h1>Електрични светилки</h1>
<a href="http://mendo.mk/Task.do?competition=218&amp;id=529">Текст од задачата</a>

Мојата омилена задача во овој натпревар. Имаме N светилки нумерирани од 1 до N кои можат да се вклучени или исклучени. Се внесува нивната почетна состојба, ние треба да ги исклучиме сите. За да го направиме тоа, имаме N прекинувачи, каде што i-тиот прекинувач ги гаси сите светилки деливи со i (прекинувач 2 ги гаси светилките 2,4,6...).

Потребни све 2 клучни забелешки тука :
<ul>
	<li>Доколку притиснеме еден ист прекинувач два пати, исто како да не сме го притиснале. Така да за секој прекинувач треба само еднаш да провериме дали сме го притиснале или не.</li>
	<li>Бидејќи нема броеви помали од X кои се деливи со X, знаеме дека кога ќе го притиснеме X-тиот прекинувач дека само ќе ја смениме X-тата светилка и можеби некои поголеми од X (но никогаш помали!)</li>
</ul>
Според ова можеме да почнеме од најмалата светилка / најмалиот прекинувач, и една по една да ги менуваме доколку има потреба. При тоа, доколку го притиснеме X-тиот прекинувач, треба да ја извршиме промената и за целата низа од X до N за сите броеви деливи со X.

<a href="http://pastebin.com/y18Sytg3">Решение во C++</a>
<h1>Роденденски прослави</h1>
<a href="http://mendo.mk/Task.do?competition=218&amp;id=530">Текст од задачата</a>

Или погрешно ја имам сфатено задачата, или не заслужува да е 4та задача со 90 поени. Имаме N пријатели и дадени нивни родендени (ден и месец). Треба да провериме во кој месец ќе има највеќе прослави. Доколку има двајца или повеќе родени на ист датум, се брои како една прослава (слават заедно).

Прво решение кое би им текнало на сите е да изброиме кој месец највеќе пати се појавува и да го испечатиме. Доколку има повеќе месеци со ист број на родендени, ги печатиме сите. Но проблемот е во тоа што родендени од ист датум се бројат како еден, така да треба да забележуваме кои датуми се веќе изброени.

Тоа можеме да го направиме со boolean матрица со димензии [31][12] (денови и месеци), каде што ќе забележуваме true/false дали во некој ден сме веќе избројале роденден. При внесување на броевите, проверуваме за секој дали е веќе прочитан. Доколку е прочитан, не правиме ништо, но доколку не е, тогаш го зголемуваме бројачот за тој месец и го бележиме како прочитан.

На крајот само треба да ги испечатиме месеците со најголем број на родендени. Заради големиот број на внесени броеви (600,000), пожелно е да се користи scanf наместо cin, или пак ios_base::sync_with_stdio(false); за да работи побрзо scanf-от.

<a href="http://pastebin.com/0kTmnVyB">Решение во C++</a>]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>27</wp:post_id>
  <wp:post_date>2015-02-20 20:43:54</wp:post_date>
  <wp:post_date_gmt>2015-02-20 19:43:54</wp:post_date_gmt>
  <wp:post_modified>2015-03-22 13:09:27</wp:post_modified>
  <wp:post_modified_gmt>2015-03-22 12:09:27</wp:post_modified_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>%d0%bc%d0%b5%d0%bd%d0%b4%d0%be-%d1%83%d1%87%d0%b8%d0%bb%d0%b8%d1%88%d0%b5%d0%bd-%d0%bd%d0%b0%d1%82%d0%bf%d1%80%d0%b5%d0%b2%d0%b0%d1%80-2015</wp:post_name>
  <wp:status>publish</wp:status>
  <wp:post_parent>0</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>post</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <category domain="post_tag" nicename="ad-hoc"><![CDATA[Ad hoc]]></category>
  <category domain="post_tag" nicename="%d0%bc%d0%b0%d1%82%d0%b5%d0%bc%d0%b0%d1%82%d0%b8%d0%ba%d0%b0"><![CDATA[Математика]]></category>
  <category domain="category" nicename="%d0%bc%d0%b5%d0%bd%d0%b4%d0%be"><![CDATA[мендо]]></category>
  <wp:postmeta>
    <wp:meta_key>_publicize_pending</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_rest_api_published</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_rest_api_client_id</wp:meta_key>
    <wp:meta_value><![CDATA[-1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_facebook</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_google_plus</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_twitter</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_linkedin</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_tumblr</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_path</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_edit_last</wp:meta_key>
    <wp:meta_value><![CDATA[55813594]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>geo_public</wp:meta_key>
    <wp:meta_value><![CDATA[0]]></wp:meta_value>
  </wp:postmeta>
</item>
<item>
  <title>Мендо - Велосипедска патека</title>
  <link>https://aandevski.wordpress.com/2015/02/22/%d0%bc%d0%b5%d0%bd%d0%b4%d0%be-%d0%b2%d0%b5%d0%bb%d0%be%d1%81%d0%b8%d0%bf%d0%b5%d0%b4%d1%81%d0%ba%d0%b0-%d0%bf%d0%b0%d1%82%d0%b5%d0%ba%d0%b0/</link>
  <pubDate>Sat, 21 Feb 2015 23:26:29 +0000</pubDate>
  <dc:creator>add1ctus</dc:creator>
  <guid isPermaLink="false">https://aandevski.wordpress.com/?p=32</guid>
  <description/>
  <content:encoded><![CDATA[<em>Note to self: Не ги потценувај задачите од училишни натпревари, читај и решавај внимателно</em>

Во споредба со тежината на првите 4 задачи (обични ad hoc задачки), оваа е значително потешка и бара знаење од динамичко програмирање (доколку не сте запознаени, можете да почнете од <a href="http://mendo.mk/wiki/attach/%D0%9C%D0%B0%D1%82%D0%B5%D1%80%D0%B8%D1%98%D0%B0%D0%BB%D0%B8%20%D0%97%D0%B0%20%D0%9F%D0%BE%D0%B4%D0%B3%D0%BE%D1%82%D0%BE%D0%B2%D0%BA%D0%B0/DinamickoProgramiranje1.pdf">тука</a> - внимание, напредна материја!). 0-1 knapsack проблем, да бидам попрецизен. Бидејќи решението е доста поопширно, решив да го ставам во посебен пост наместо да го едитирам стариот.<!--more-->

Во <a href="http://mendo.mk/Task.do?id=531">оваа задача</a> имаме дадено патека со должина M метри, на која што имаме поставени канделабри за осветлување. Канделабрите имаат 3 параметри:
<ul>
	<li>Xi - Растојание од почетокот на патеката</li>
	<li>Ci - Дневна потрошувачка во денари</li>
	<li>Ri - Радиус на осветлување</li>
</ul>
Од вас се бара со буџет од K денари дневно да осветлите што поголем дел од патеката. Потребно е да се испечати должината на осветлениот пат и должината на најдолгиот сегмент од патот каде патеката не е осветлена.

Првото нешто кое може да ве збуни и да доведе до погрешни одговори доколку не го расчистите веднаш се вредностите со кои работиме. Се работи за далечини помеѓу две точки, кои ги претставуваме со затворени интервали ([a,b] значи дека е осветлен патот помеѓу точките a и b). За полесно решавање можеме да ја замислиме патеката како низа од полиња, сите долги по 1 метар.

[caption id="attachment_33" align="alignnone" width="600"]<a href="https://aandevski.files.wordpress.com/2015/02/untitled-1.png"><img class="wp-image-33 size-full" src="https://aandevski.files.wordpress.com/2015/02/untitled-1.png" alt="Untitled-1" width="600" height="200" /></a> Пример за патека со должина 4[/caption]

Од тука можеме да заклучиме дека секоја патека ги осветлува полињата од Xi-Ri до Xi+Ri-1, вклучувајќи ги и тие полиња. Но притоа, треба да внимаваме да не излеземе надвор од опсегот (да осветлиме полиња помали од 0 или пак поголеми од должината на патеката).

При првото читање на задачата не приметив дека осветлените делови од канделабрите нема никогаш да се поклопуваат, што ја правеше задачата многу потешка. Но, бидејќи во задачата нема да се поклопуваат две светла никогаш, тогаш единственото нешто што е потребно е да избереме кои канделабри ќе се пуштени а кои не, така да го максимизираме бројот на осветлени полиња. Бирање на канделабри со greedy пристап според односот <strong>број на осветлени полиња/цена</strong> нема да работи, како што покажуваат дадените тест примери. Од друга страна пак, доколку ги пробаме сите комбинации со битмаски, се работи за 2<sup>100</sup> комбинации, за чија проверка би биле потребни нешто повеќе од 394 трилиони века (доколку пресметуваме со 100 милиони операции во секунда), што е значително повеќе од временското ограничување од 1 секунда. :)

Оваа задача е варијација на 0-1 knapsack проблемот (проблем со ранец каде што секој предмет се појавува еднаш). Во овој случај, предметите се канделабрите, нивните вредности се бројот на полиња кои ги осветлуваат, волуменот е цената а капацитетот на ранецот е буџетот со кој располагаме. Правиме матрица DP[][], каде што DP[x][y] означува број на осветлени полиња при користење на првите x канделабри и буџет y.

Доколку бараме колку полиња ќе се осветлат со првите x канделабри и буџет y, тогаш имаме еден од овие два избора (го бираме поголемото):
<ul>
	<li>Ја користиме x-тата канделабра. Вредноста на овој израз е бројот на полиња осветлени од x-тата канделабра + бројот на полиња осветлени со канделабрите од 1 до x-1 при буџет y-Ci[x] DP[x][y] = osvetleni_polinja + DP[x-1][y-Ci[x]]</li>
	<li>Не ја користиме x-тата канделабра. Вредноста на овој израз е бројот на полиња осветлени со канделабрите од 1 до x-1 при буџет y. DP[x][y] = DP[x-1][y]</li>
</ul>
Тргнувајќи од DP[n][budget], каде што n е бројот на канделабри и budget е буџетот со кој располагаме, рекурзивно ги откриваме помалите вредности кои ни се потребни за да го добиеме резултатот.

Бидејќи во задачата исто така се бара и најдолгиот дел од патеката што не е осветлен, мораме да знаеме кои канделабри сме ги одбрале за да го добиеме решението. Затоа правиме додатна boolean матрица iskoristeno[n][budget], каде iskoristeno[x][y] е true само доколку со буџет y сме ја избрале x-тата канделабра.

Потоа ја претставуваме патеката со низа од int или boolean вредности, osvetleno, каде што osvetleno[i]=1 (или true) доколку i-тото поле е осветлено. Изминувајќи ја матрицата iskoristeno во обратен редослед (од буџет budget до буџет 0), проверуваме кои канделабри ги имаме искористено и според тоа ја пополнуваме низата osvetleno. Се што преостанува е да го најдеме најдолгиот интервал од 0 или false елементи во низата, и да го испечатиме нивниот број заедно со бројот на осветлени полиња.

<a href="http://pastebin.com/AM0nN5Jt">Решение во C++</a>]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>32</wp:post_id>
  <wp:post_date>2015-02-22 00:26:29</wp:post_date>
  <wp:post_date_gmt>2015-02-21 23:26:29</wp:post_date_gmt>
  <wp:post_modified>2015-03-22 13:09:42</wp:post_modified>
  <wp:post_modified_gmt>2015-03-22 12:09:42</wp:post_modified_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>%d0%bc%d0%b5%d0%bd%d0%b4%d0%be-%d0%b2%d0%b5%d0%bb%d0%be%d1%81%d0%b8%d0%bf%d0%b5%d0%b4%d1%81%d0%ba%d0%b0-%d0%bf%d0%b0%d1%82%d0%b5%d0%ba%d0%b0</wp:post_name>
  <wp:status>publish</wp:status>
  <wp:post_parent>0</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>post</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <category domain="post_tag" nicename="%d0%b4%d0%b8%d0%bd%d0%b0%d0%bc%d0%b8%d1%87%d0%ba%d0%be-%d0%bf%d1%80%d0%be%d0%b3%d1%80%d0%b0%d0%bc%d0%b8%d1%80%d0%b0%d1%9a%d0%b5"><![CDATA[Динамичко програмирање]]></category>
  <category domain="category" nicename="%d0%bc%d0%b5%d0%bd%d0%b4%d0%be"><![CDATA[мендо]]></category>
  <wp:postmeta>
    <wp:meta_key>_publicize_pending</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_rest_api_published</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_rest_api_client_id</wp:meta_key>
    <wp:meta_value><![CDATA[-1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_facebook</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_google_plus</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_twitter</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_linkedin</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_tumblr</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_path</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
</item>
<item>
  <title>Untitled-1</title>
  <link>https://aandevski.wordpress.com/2015/02/22/%d0%bc%d0%b5%d0%bd%d0%b4%d0%be-%d0%b2%d0%b5%d0%bb%d0%be%d1%81%d0%b8%d0%bf%d0%b5%d0%b4%d1%81%d0%ba%d0%b0-%d0%bf%d0%b0%d1%82%d0%b5%d0%ba%d0%b0/untitled-1/</link>
  <pubDate>Sat, 21 Feb 2015 22:51:53 +0000</pubDate>
  <dc:creator>add1ctus</dc:creator>
  <guid isPermaLink="false">http://aandevski.files.wordpress.com/2015/02/untitled-1.png</guid>
  <description/>
  <content:encoded><![CDATA[]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>33</wp:post_id>
  <wp:post_date>2015-02-21 23:51:53</wp:post_date>
  <wp:post_date_gmt>2015-02-21 22:51:53</wp:post_date_gmt>
  <wp:post_modified>2015-02-21 23:51:53</wp:post_modified>
  <wp:post_modified_gmt>2015-02-21 22:51:53</wp:post_modified_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>untitled-1</wp:post_name>
  <wp:status>inherit</wp:status>
  <wp:post_parent>32</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>attachment</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <wp:attachment_url>https://aandevski.files.wordpress.com/2015/02/untitled-1.png</wp:attachment_url>
</item>
<item>
  <title>CodeChef February LunchTime</title>
  <link>https://aandevski.wordpress.com/2015/02/22/codechef-february-lunchtime/</link>
  <pubDate>Sun, 22 Feb 2015 15:48:57 +0000</pubDate>
  <dc:creator>add1ctus</dc:creator>
  <guid isPermaLink="false">https://aandevski.wordpress.com/?p=36</guid>
  <description/>
  <content:encoded><![CDATA[Мразам временски зони. Додека Codeforces натпреварите се во слична временска зона со нашата, неретко се случува да седам до 5 сабајле за да учествувам во Topcoder SRM натпревар. Заради тоа и некогаш ги мразев Topcoder натпреварите, се додека не учествував во CodeChef LunchTime. Причината? Станување во 6:15 сабајле за да решавам задачи.

Lunchtime е натпревар наменет за сите оние кои би сакале да учествуваат на IOI (задачите се приближно на тоа ниво, со исклучок на една лесна задача). Завршив 114-то од 1355 учесника, решавајќи ги само првите две задачи (при што втората не поминуваше целосно заради некоја грешка со min функцијата). Од другите две задачи кои не ги решив, едната беше математичка (типично за CodeChef), каде што се бараше работа со огромни броеви (потребно беше разложување), додека другата беше со декомпозиција на дрва (дури и текстот на задачата не ми беше разбирлив при прво читање, и не ја отворив подоцна, иако беше сменет текстот во текот на натпреварот). И двете беа решени од само 25 учесника.

Да ги разгледаме задачите кои успеав да ги решам:<!--more-->
<h1>Lucky four</h1>
<h4><a href="http://www.codechef.com/LTIME21/problems/LUCKFOUR">Текст од задачата</a></h4>
Стандардно како и секаде, првата задача е полесна за да се намали бројот на учесници со 0 поени (да ги мотивира сите да решаваат). Во оваа задача имавме дадено N броеви, и за секој број потребно беше да изброиме колку пати се појавува цифрата 4 во него и да испечатиме. За целосни поени, задачата мораше да работи со 100,000 броеви во опсегот од 1 до 1,000,000,000. Стандардно временско ограничување од 1 секунда.

Грешка што неискусните „решавачи на проблеми“ би ја направиле е да го читаат бројот како integer вредност. Во тој случај, потребно е цело време да го делиме бројот со 10 и да го проверуваме остатокот за да ги провериме сите цифри. Со 100,000 10-цифрени броеви овој пристап и не е најоптималниот. Подобро решение е внесување на броевите како string-ови, и проверување на стрингот карактер по карактер.

Секако, ние правиме ист број на проверки и во двата случаи (мора да ги провериме сите цифри), но сепак проверката if(input[i]=='4') работи многу побрзо од делење на големи броеви. Просто за кодирање, го читаме бројот, проверуваме колку пати се појавува '4' во него со for циклус и печатиме.

<a href="http://www.codechef.com/viewsolution/6336555">Решение во C++</a>
<h1>The Warehouse</h1>
<h4><a href="http://www.codechef.com/LTIME21/problems/WPROB">Текст од задачата</a></h4>
На оваа задача потрошив значително повеќе време од нормално само за да ја упростам. Очигледно ненаспиено решавање на задачи не е најдобрата идеја, бидејќи потрошив 20-тина минути само читајќи го текстот повторно и повторно, без никаков напредок.

Имаме магацин на некоја фабрика за маици која произведува само црвени, зелени и сини маици, означени со r, g или b. N (нумерирани од 1 до N) маици се произволно наместени во низа и нашата цел е да ги наместиме така да го минимизираме бројот на соседни маици со различни бои за најкратко време. Притоа дозволено е да користиме една од овие 3 операции:
<ul>
	<li>Маицата со реден број <strong>X</strong> ја ставаме на почетокот на низата за <strong>X-1</strong> секунди</li>
	<li>Маицата со реден број <strong>X</strong> ја поместуваме на лево, после <strong>Y</strong> маицата за<strong> X-Y-1</strong> секунди</li>
	<li>Маицата со реден број <strong>X</strong> ја поместуваме на десно, после <strong>Y</strong> маицата за <strong>Y-X</strong> секунди</li>
</ul>
За даден стринг кој го означува почетниот редослед, најдете го најбрзото можно решение (најмалку секунди).

Интересно е како успеаа претерано проста задача да ја направат комплицирана само со текстот кој ја опишува. Минимизација на бројот на соседни маици со различни бои се всушност добива кога сите маици од иста боја ги ставиме една до друга. На пример, од RRGBRB да добиеме RRRGBB. Исто така доколку внимателно ги размислите операциите кои ни се дозволени, можеме да приметиме дека всушност ни е дозволено маиците да ги преместуваме лево и десно колку сакаме, каде што за 1 поместување се губи 1 секунда.

Имаме 6 различни начини на подредување на маиците според боите:
<ul>
	<li>Црвени, Сини, Зелени</li>
	<li>Црвени, Зелени, Сини</li>
	<li>Сини, Црвени, Зелени</li>
	<li>Сини, Зелени, Црвени</li>
	<li>Зелени, Црвени, Сини</li>
	<li>Зелени, Сини, Црвени</li>
</ul>
Ги пробуваме сите 6 начина и наоѓаме за кое подредување е потребно најмалку време и го печатиме тоа време.

Да го земеме за пример првиот редослед. Ги гледаме маиците една по една од почетокот на низата (го изминуваме стрингот буква по буква). Чуваме посебни бројачи кои ни означуваат која маица колку пати сме ја сретнале досега. Да замислиме низа brojac. Доколку добиеме црвена маица, тогаш таа треба да се помести во лево за brojac[sini] + brojac[zeleni] места за да биде на почетокот на стрингот (заедно со другите црвени маици). Доколку добиеме сина маица, треба да се помести во лево за brojac[zeleni] места за да биде во средина на стрингот (заедно со другите сини маици). Зелените маици треба да се на крајот, така да доколку добиеме таква маица, не ја поместуваме воопшто.

[caption id="attachment_37" align="alignnone" width="600"]<a href="https://aandevski.files.wordpress.com/2015/02/untitled-11.png"><img class="size-full wp-image-37" src="https://aandevski.files.wordpress.com/2015/02/untitled-11.png" alt="Црвената маица ја поместуваме за 2 места (brojac[sini]+brojac[zeleni])" width="600" height="200" /></a> Црвената маица ја поместуваме за 2 места (brojac[sini]+brojac[zeleni])[/caption]Во оваа задача само се бара најкраткото време на поместување, така да нема потреба да ги заменуваме маиците во стрингот, доволно е само да ги броиме секундите. Доколку изминеме i маици, знаеме дека тие секогаш ќе се подредени.

За секој внесен стринг (може до 10 стринга да се внесат), ги проверуваме сите 6 комбинации и го печатиме времето на најбрзата.

<a href="http://www.codechef.com/viewsolution/6336477">Решение во C++</a>]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>36</wp:post_id>
  <wp:post_date>2015-02-22 16:48:57</wp:post_date>
  <wp:post_date_gmt>2015-02-22 15:48:57</wp:post_date_gmt>
  <wp:post_modified>2015-03-22 13:10:34</wp:post_modified>
  <wp:post_modified_gmt>2015-03-22 12:10:34</wp:post_modified_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>codechef-february-lunchtime</wp:post_name>
  <wp:status>publish</wp:status>
  <wp:post_parent>0</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>post</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <category domain="post_tag" nicename="brute-force"><![CDATA[Brute force]]></category>
  <category domain="category" nicename="codechef"><![CDATA[CodeChef]]></category>
  <category domain="post_tag" nicename="%d1%81%d1%82%d1%80%d0%b8%d0%bd%d0%b3%d0%be%d0%b2%d0%b8"><![CDATA[Стрингови]]></category>
  <wp:postmeta>
    <wp:meta_key>_publicize_pending</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_rest_api_published</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_rest_api_client_id</wp:meta_key>
    <wp:meta_value><![CDATA[-1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_facebook</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_google_plus</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_twitter</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_linkedin</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_tumblr</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_path</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
</item>
<item>
  <title>Untitled-1</title>
  <link>https://aandevski.wordpress.com/2015/02/22/codechef-february-lunchtime/untitled-1-2/</link>
  <pubDate>Sun, 22 Feb 2015 15:43:52 +0000</pubDate>
  <dc:creator>add1ctus</dc:creator>
  <guid isPermaLink="false">http://aandevski.files.wordpress.com/2015/02/untitled-11.png</guid>
  <description/>
  <content:encoded><![CDATA[]]></content:encoded>
  <excerpt:encoded><![CDATA[Црвената маица ја поместуваме за 2 места (brojac[sini]+brojac[zeleni])]]></excerpt:encoded>
  <wp:post_id>37</wp:post_id>
  <wp:post_date>2015-02-22 16:43:52</wp:post_date>
  <wp:post_date_gmt>2015-02-22 15:43:52</wp:post_date_gmt>
  <wp:post_modified>2015-02-22 16:44:19</wp:post_modified>
  <wp:post_modified_gmt>2015-02-22 15:44:19</wp:post_modified_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>untitled-1-2</wp:post_name>
  <wp:status>inherit</wp:status>
  <wp:post_parent>36</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>attachment</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <wp:attachment_url>https://aandevski.files.wordpress.com/2015/02/untitled-11.png</wp:attachment_url>
</item>
<item>
  <title>USACO February Contest</title>
  <link>https://aandevski.wordpress.com/2015/02/23/usaco-february-contest/</link>
  <pubDate>Mon, 23 Feb 2015 16:31:35 +0000</pubDate>
  <dc:creator>add1ctus</dc:creator>
  <guid isPermaLink="false">https://aandevski.wordpress.com/?p=42</guid>
  <description/>
  <content:encoded><![CDATA[Интересно нешто кај американските државни натпревари е тоа што се отворени за сите учесници од целиот свет. Имаат 3 месечни натпревари и додатен US Open натпревар, според чии резултати ги покануваат најдобрите 16-24 ученици на 10-дневен тренинг камп каде што се избираат претставниците за Интернационалната Олимпијада по Информатика (ИОИ). Ова е интересно доколку сакате да видите колкави шанси би имале да ги претставувате САД на ИОИ, така да се одлучив да учествувам на овој натпревар.

Натпреварот е поделен во 3 дивизии(Bronze, Silver, Gold). Вашиот прв натпревар е во Bronze дивизијата. Промоција во наредната дивизија зависи од вашиот резултат во натпреварите. Системот е направен така да можат да даваат многу тешки задачи на најјаките кандидати за да се изберат најдобрите за кампот, но сепак постојат и лесни задачи за да ги мотивира почетниците.

Сега, за натпреварот. Бидејќи ги пропуштив првите 2 месечни натпревари (во Декември и Јануари), сега започнувам во бронзената дивизија, каде што задачите беа прилично лесни. Успеав за нешто помалку од еден час да ги решам сите задачи (натпреварот трае 4 часа), кои поминаа 100% (резултатите ги добивате веднаш одкако ќе пратите решение). Да ги погледнеме задачите.<!--more-->
<h1>Censoring</h1>
<h4><a href="http://pastebin.com/6TmFLkyQ">Текст од задачата</a></h4>
Во задачата имаме дадено некој стринг S со максимална должина од 100,000 карактери и друг стринг T со максимална должина од 100 карактери. Потребно е да ги избришеме сите појавувања на стрингот T во стрингот S и да го испечатиме резултатот. На пример, доколку S="abcdef" T="cd", резултатот ќе е "abef". Временското ограничување е 2 секунди.

Интересно нешто е што при бришење на една инстанца на стрингот T, може да се појави друга. На пример, S="abccddef" T="cd". Кога ќе го избришеме стрингот "cd" кој се наоѓа на позициите 4 и 5(доколку броиме од 1), ќе го добиеме стрингот "abcdef", каде што повторно го имаме стрингот T. Исто и тука резултатот ќе е "abef".

Заради тоа е потребно секогаш кога ќе избришеме некој дел од стрингот да се вратиме назад во стрингот наместо да продолжиме да бараме од истата позиција. Ова може да се изведе со готови функции:

<code> while( (position=input.find(censor)) != string::npos)
input.erase(position,censor.size());
</code>

Но ова пребарување секогаш започнува од почетокот на стрингот. Да кажеме дека имаме стринг од 100,000 карактери каде што во првите 50,000 карактери не се појавува стрингот T, а во втората половина стрингот T се појавува многу пати. При секое бришење на некој стринг T, овој алгоритам ќе започне да бара од почеток, што ќе ја зголеми временската сложеност многу.

Затоа е потребно да направиме наше пребарување, каде што доколку избришеме некој стринг, потребно е да се вратиме само Т.size()-1 места назад, што е доволно да провериме дали бришењето на стрингот создало некои нови стрингови. За додатна оптимизација (иако програмот би поминал и на овој начин за 2 секунди), можеме да ги зачуваме должините на стринговите во посебни променливи наместо да ги проверуваме секогаш. Доколку одиме со овој пристап, тогаш мораме должината на стрингот S да ја намалуваме секогаш кога бришеме букви од него.

<a href="http://pastebin.com/WM3m2dVG">Решение во C++</a>
<h1>COW</h1>
<a href="http://pastebin.com/ENCu8xv2">Текст од задачата</a>

Повторно работиме со стрингови. Овој пат, имаме дадено стринг со максимум должина 10,000 кој се состои од буквите C, O и W. Потребно е да пронајдеме колку пати се појавува зборот COW во тој стринг. Притоа, треба да ги броиме сите комбинации на буквите C, O и W (кои се во тој редослед), без разлика и да има други букви измеѓу нив. На пример, во стрингот <strong>C</strong>W<strong>OW</strong> зборот COW се појавува еднаш. Во стрингот CCOOWW зборот се појавува 8 пати:
<ul>
	<li><span style="color:#ff0000;"><strong>C</strong></span>C<span style="color:#ff0000;"><strong>O</strong></span>O<span style="color:#ff0000;"><strong>W</strong></span>W</li>
	<li><span style="color:#ff0000;"><strong>C</strong></span>C<span style="color:#ff0000;"><strong>O</strong></span>OW<strong><span style="color:#ff0000;">W</span></strong></li>
	<li><span style="color:#ff0000;"><strong>C</strong></span>CO<strong><span style="color:#ff0000;">OW</span></strong>W</li>
	<li><span style="color:#ff0000;"><strong>C</strong></span>CO<span style="color:#ff0000;"><strong>O</strong></span>W<span style="color:#ff0000;"><strong>W</strong></span></li>
	<li><span style="color:#000000;">C</span><span style="color:#ff0000;"><strong>C</strong><strong>O</strong></span>O<span style="color:#ff0000;"><strong>W</strong></span>W</li>
	<li>C<span style="color:#ff0000;"><strong>C</strong><strong>O</strong></span>OW<span style="color:#ff0000;"><strong>W</strong></span></li>
	<li>C<span style="color:#ff0000;"><strong>C</strong></span>O<span style="color:#ff0000;"><strong>O</strong><strong>W</strong></span>W</li>
	<li>C<span style="color:#ff0000;"><strong>C</strong></span>O<span style="color:#ff0000;"><strong>O</strong></span>W<span style="color:#ff0000;"><strong>W</strong></span></li>
</ul>
За да го добиеме резултатот, го изминуваме стрингот буква по буква, и ги бележиме следниве променливи:
<ul>
	<li>c : Колку букви C сме поминале од почетокот на стрингот</li>
	<li>co : Колку различни комбинации CO би имале доколку следната буква е O</li>
	<li>result : Колку различни комбинации COW имаме добиено до сега</li>
</ul>
Третата точка е резултатот кој го печатиме, а сега ќе видиме зошто ни се потребни првите 2. Доколку на i-тата позиција е внесена буквата W, треба да знаеме колку зборови формира таа. За тоа ни е потребно да знаеме колку букви C и O сме веќе поминале во интервалот [1..i-1]. Но за тие букви мора да знаеме колку пати буквата C е пред буквата О. Пример, во стринговите OCW и COW, кога ќе стигнеме до 3тата позиција и во двата случаја имаме по една буква C и O изминато, но само во вториот случај имаме збор COW. Така да потребно е да знаеме колку комбинации на буквите CO (во тој редослед) сме поминале. Секогаш кога сретнеме буква W, result променливата ја зголемуваме за co. Тоа ни е втората променлива.

Втората променлива можеме да ја добиеме со истата теорија. Доколку сретнеме буква O на i-тата позиција, тогаш треба да знаеме колку комбинации CO можеме да постигнеме со таа буква. Одговорот е бројот на буквите C кои се веќе поминати во интервалот [1..i-1]. Така да секогаш кога ќе сретнеме буква O, променливата co ја зголемуваме за c.

Првата променлива е јасна сама по себе. Секогаш кога ќе сретнеме буква C, променливата ја зголемуваме за еден.

<a href="http://pastebin.com/jv0iEX4g">Решение во C++</a>
<h1>Cow hopscotch</h1>
<h4><a href="http://pastebin.com/r4ZgJrP9">Текст од задачата</a></h4>
<h4></h4>
Додека првите две задачи ги решив со ad hoc, третата бараше основни алгоритми. Во овој случај, требаше да знаете теорија на графови и DFS (или пребарување по широчина). Имате дадено матрица (со максимални димензии 15х15) која се содржи од црвени и сини полиња (означени со R или B карактери). Постои игра во која што се движите од горниот лев агол кон долниот десен агол, така да:
<ul>
	<li>Доколку се наоѓате на колона X, смеете да скокнете само кон сите колони поголеми од X</li>
	<li>Доколку се наоѓате на редицата X, смеете да скокнете само кон сите редици поголеми од X</li>
	<li>Смеете да скокнете само на полиња со различна боја од полето на кое стоите</li>
</ul>
Така да мора секогаш да се движиме во таа насока (доле, десно), и да скокаме наизменично помеѓу црвени и сини полиња. Од вас се бара да го најдете бројот на начини (различни патови) за да стигнете од почетокот до крајот на оваа матрица.

Доколку имате веќе решавано задачи со DFS, решението е просто. Доколку се наоѓате на точка x,y, следниот чекор го правите на било која точка a,b каде:
<ul>
	<li>a &gt; x</li>
	<li>b &gt; y</li>
	<li>boja[x][y] != boja[a][b]</li>
</ul>
При тоа не водиме евиденција на тоа кои полиња се посетени (бидејќи за да најдеме број на различни начини да стигнеме до крајот, треба исти полиња да посетуваме повеќе пати), и секогаш кога стигнеме до крајот, го зголемуваме резултатот за 1. Тоа може да го направиме со глобална променлива или пак да го враќаме рекурзивно резултатот. Било кој начин ќе работи добро, во прашање е личен вкус. Јас го избрав вториот начин.

<a href="http://pastebin.com/VR3ENRdr">Решение во C++</a>]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>42</wp:post_id>
  <wp:post_date>2015-02-23 17:31:35</wp:post_date>
  <wp:post_date_gmt>2015-02-23 16:31:35</wp:post_date_gmt>
  <wp:post_modified>2015-03-22 13:11:06</wp:post_modified>
  <wp:post_modified_gmt>2015-03-22 12:11:06</wp:post_modified_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>usaco-february-contest</wp:post_name>
  <wp:status>publish</wp:status>
  <wp:post_parent>0</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>post</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <category domain="post_tag" nicename="brute-force"><![CDATA[Brute force]]></category>
  <category domain="post_tag" nicename="dfs"><![CDATA[DFS]]></category>
  <category domain="post_tag" nicename="%d1%81%d1%82%d1%80%d0%b8%d0%bd%d0%b3%d0%be%d0%b2%d0%b8"><![CDATA[Стрингови]]></category>
  <category domain="category" nicename="usaco"><![CDATA[USACO]]></category>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_facebook</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_google_plus</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_twitter</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_linkedin</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_tumblr</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_path</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_rest_api_published</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_rest_api_client_id</wp:meta_key>
    <wp:meta_value><![CDATA[-1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_publicize_pending</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_edit_last</wp:meta_key>
    <wp:meta_value><![CDATA[55813594]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>geo_public</wp:meta_key>
    <wp:meta_value><![CDATA[0]]></wp:meta_value>
  </wp:postmeta>
</item>
<item>
  <title>Codeforces Round #293</title>
  <link>https://aandevski.wordpress.com/2015/02/27/codeforces-round-293/</link>
  <pubDate>Fri, 27 Feb 2015 17:33:53 +0000</pubDate>
  <dc:creator>add1ctus</dc:creator>
  <guid isPermaLink="false">https://aandevski.wordpress.com/?p=45</guid>
  <description/>
  <content:encoded><![CDATA[Невообичаен натпревар за Codeforces. 6 задачи, 150 минути, само за втора дивизија. Бидејќи влегов во првата дивизија минатиот натпревар, не учествував овој пат, но сепак ги разгледав задачите. Првите три задачи беа невообичаени за Codeforces натпревар, кои не бараа познавање од напредни алгоритми туку само имаа незгодни имплементации или бараа многу оптимизации. Од останатите задачи (кои сеуште ги немам решено), четвртата се базираше на динамичко и веројатност додека последните две беа ad hoc решенија.<!--more-->
<h1>А - Vitaly and Strings</h1>
<a href="http://codeforces.com/problemset/problem/518/A">Текст од задачата</a>

За дадени два стринга s и t со иста должина кои се состојат само од мали латинични букви, каде што s е лексикографски помал стринг од t, да се најде дали постои некој стринг измеѓу тие два (лексикографски помал од s но поголем од t), и доколку постои да се испечати.

Лексикографско споредување на два стринга се врши буква по буква, од првата буква. Доколку првата буква на првиот стринг е поголема од првата буква на вториот стринг, тогаш првиот стринг е лексикографски поголем. (baa &gt; aaa). Доколку првите две букви се еднакви, се споредуваат вторите две букви. (aba &gt; aaa). Така се споредува додека не стигнеме до крајот на некој стринг. Доколку немаат различни букви, тогаш стринговите се еднакви и лексикографски.

Доколку имаме некој даден стринг (пример, abc), наредниот лексикографски стринг е кога последната буква ја зголемуваме за 1. Во овој случај, abd е следниот стринг. Доколку пак буквата што треба да ја зголемиме е z (пример, abz), тогаш таа буква ја ставаме да е a, и ја зголемуваме следната буква (во тој пример, добиваме aca).

За да нема стрингови помеѓу стринговите s и t, тогаш s мора да е претходник на t (наредниот лексикографски стринг на s да е t). Така да само е потребно да го провериме овој услов. Доколку наредниот стринг на s е t, тогаш не постои таков стринг. Во спротивно, го печатиме наредниот стринг.

Зголемувањето на стрингот го правиме рекурзивно со функција која ја повикуваме на последната буква, која ја зголемуваме за 1. Доколку последната буква е 'z', тогаш ја ставаме да е еднаква на 'a' функцијата ја повикуваме на следната буква. Кога ќе го зголемиме стрингот, само ги споредуваме и печатиме резултат.

<a href="http://codeforces.com/contest/518/submission/10022971">Решение во C++</a>
<h1>B - Tanya and postcard</h1>
<a href="http://codeforces.com/problemset/problem/518/B">Текст од задачата</a>

Повторно стрингови. Тања има дадено порака (string s), и весник (string t). Потребно е со сечење на буквите од весникот да ја добие саканата порака. Доколку искористи буква од весникот, и таа е со точната големина, таа се радува, но доколку буквата е со погрешна големина (пример - се бара мала буква, а таа има само голема во весникот), таа е тажна. Од вас се бара да проверите колку пати таа ќе е тажна, а колку пати ќе се радува. Потребно е да се максимизира колку пати ќе се радува.

За броење на буквите користиме мапи. Потребни ни е да броиме колку пати се појавува секоја буква во двата стринга посебно. Едниот бројач е case sensitive, каде што разликуваме големи од мали букви, а во вториот бројач ги броиме исто (пример, имаме еден бројач за 'a' и 'A'). Така да потребни ни се вкупно 4 мапи, од тип &lt;char, int&gt;. Двете case sensitive мапи ги пополнуваме со буквите кои ги читаме од стрингот, а за другите две мапи ги претвораме сите букви во мали букви.

Кога веќе ги имаме изброено буквите, тогаш прво проверуваме колку букви можеме да искористиме од весникот за стрингот со потребната големина, а потоа и со погрешна големина, и за двете чуваме посебни бројачи.

<a href="http://codeforces.com/contest/518/submission/10054805">Решение во C++</a>
<h1>C - Anya and smartphone</h1>
<a href="http://codeforces.com/problemset/problem/518/C">Текст од задачата</a>

Имаме смартфон со n апликации, од кои секоја има своја икона на екранот. Екранот може да прикаже најмногу k апликации во исто време. Доколку има повеќе од k апликации, тогаш тој ги поделува според страници така што првите k апликации се на првата страница, вторите k апликации на втората, итн. Сите апликации се нумерирани од 1 до n и ни е даден нивниот првобитен редослед. Но нивниот редослед се менува со текот на користење, така што кога ќе пуштиме некоја апликација, таа се поместува едно место понапред (бидејќи е почесто користена).

На нас ни е дадена првобитната листа на апликации, и редоследот во кој ќе ги пуштаме (можно е една апликација да ја пуштиме повеќе пати). Треба да изброиме со колку допира ќе се изврши тоа. За секоје менување на страница ни треба 1 допир и за пуштање на апликација 1 допир. Кога ќе завршиме со користење на една апликација, повторно се враќаме на првата страница.

На прв поглед многу лесна задача за brute force имплементација. Секогаш кога некоја апликација ќе се пушти, проверуваме на која позиција е (за да знаеме на која страница е, колку допири ни се потребни за неа). Потоа проверуваме која апликација е пред неа, и им ги заменуваме местата. Проблемот во ова е што имаме можни 100,000 апликации и 100,000 пуштања на истите, така да доколку користиме линеарно пребарување и секогаш се отвора последната апликација, тогаш сложеноста на овој алгоритам може да достигне до 20,000,000,000 операции, нешто што не е изводливо во една секунда.

Затоа чуваме две низи : една што ни покажува на која позиција која апликација стои, и друга што ни покажува која апликација на која позиција е. Така да кога прочитаме некоја апликација, можеме веднаш да провериме на која позиција е и да изброиме колку допири треба (при делење со k), да видиме која апликација се наоѓа на едно место пред неа во низата за позиции и да го смениме местото на двете апликации во двете низи.

<a href="http://codeforces.com/contest/518/submission/10054893">Решение во C++</a>]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>45</wp:post_id>
  <wp:post_date>2015-02-27 18:33:53</wp:post_date>
  <wp:post_date_gmt>2015-02-27 17:33:53</wp:post_date_gmt>
  <wp:post_modified>2015-03-10 12:01:16</wp:post_modified>
  <wp:post_modified_gmt>2015-03-10 11:01:16</wp:post_modified_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>codeforces-round-293</wp:post_name>
  <wp:status>publish</wp:status>
  <wp:post_parent>0</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>post</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <category domain="category" nicename="codeforces"><![CDATA[codeforces]]></category>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_facebook</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_google_plus</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_twitter</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_linkedin</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_tumblr</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_path</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_rest_api_published</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_rest_api_client_id</wp:meta_key>
    <wp:meta_value><![CDATA[-1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_publicize_pending</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
</item>
<item>
  <title>Topcoder SRM 651</title>
  <link>https://aandevski.wordpress.com/2015/03/01/topcoder-srm-651/</link>
  <pubDate>Sun, 01 Mar 2015 14:38:26 +0000</pubDate>
  <dc:creator>add1ctus</dc:creator>
  <guid isPermaLink="false">https://aandevski.wordpress.com/?p=50</guid>
  <description/>
  <content:encoded><![CDATA[Вчера се одржа 651-виот Topcoder SRM натпревар, кој за жал помина како unrated заради технички проблеми (голем дел од натпреварувачите не можеа да пратат решенија). Како резултат на тоа, сите решаваа помалку од 1 час (додека да излезе соопштението дека овој натпревар е unrated) и никој не се ни обиде да ги реши последните две задачи (со исклучок на Petr, чие решение на втората задача беше неточно). Да ја разгледаме првата задача.<!--more-->
<h1>250 - Robot on moon</h1>
<a href="http://pastebin.com/UdAJ9ieA">Текст од задачата</a>

Имаме дадено char мапа од некое поле на месечината (максимум големина 50 х 50), каде што со 'S' е означена почетната точка на роботот, '.' означува празно место и '#' означува некоја препрека преку која не може да поминеме. Можеме да се движиме во 4 насоки (нагоре, надоле, лево, десно), но исто така и можеме да излеземе надвор од полето (при што роботот умира веднаш).

Роботот се движи така што од нашата планета му даваме инструкции за движење во форма на стринг кој се состои од буквите U, D, L, R (што ги означува четирите насоки). Пример, со стринг "UUUR", роботот ќе се движи три пати нагоре (за едно поле), па едно поле десно. Проблемот е во тоа што при пренесување на стрингот може да се случи и губење на податоци, така да некоја буква од стрингот не стигне до роботот. Вашата задача е да ја најдете должината на најдолгиот стринг кој можете да го пратите, при тоа да сте сигурни дека роботот нема да излезе од полето при пратење на инструкциите при губење на било кои букви. Заради разјаснување проверете ги тест примерите дадени во текстот на задачата.

Лесна задача за прва дивизија на која потрошив време поради скептичност дека решението што го имав нема да работи. Клучната забелешка беше во тоа дека доколку од една страна на роботот имаме препрека, тогаш можеме да направиме неограничен стринг кој оди само во таа насока.

Така за примерот:
<code>....
S..#</code>

Можеме да се движиме во десно колку сакаме, бидејќи никогаш нема да излеземе надвор од полето. Во такви случаи (кога од една страна на S имаме #), враќаме -1. Во останатите случаи (кога не сме ограничени од препрека во ни една насока), смееме да се движиме само колку што имаме место до крајот на полето.

За примерот:
<code>
.....
..S..
.#...
</code>

би постоело неограничено решение со стринговите "LDDDD..." или "DLLLLL...", но заради губењето на податоци, можеби ќе ја изгубиме првата буква и со тоа би излегле надвор од полето, така да тие стрингови не се валидни. Во овој случај можеме да бидеме сигурни дека нема да излеземе од полето само доколку се движиме 2 пати на лево, 2 пати на десно, и по еднаш нагоре и надоле. Во овој случај, дури и да ги изгубиме сите букви освен една насока, повторно не би излегле надвор од полето. Можете да приметите дека бројот на движења лево и десно (вкупно 4 во овој пример) е еднакво на ширината на полето - 1 додека бројот на движења нагоре и надоле (вкупно 2 во овој пример) е еднакво на должината на полето - 1. Така да за поле со големина x * y, резултатот е x+y-2

Како решение, само е потребно да ја најдеме локацијата на S со обично изминување на матрицата (2 for циклуса), и потоа да провериме дали во иста редица или колона има барем еден знак '#'. Доколку има, враќаме -1, во спротивно, враќаме x+y-2.

<a href="http://pastebin.com/5SKBrEG1">Решение во C++</a>]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>50</wp:post_id>
  <wp:post_date>2015-03-01 15:38:26</wp:post_date>
  <wp:post_date_gmt>2015-03-01 14:38:26</wp:post_date_gmt>
  <wp:post_modified>2015-03-10 12:01:51</wp:post_modified>
  <wp:post_modified_gmt>2015-03-10 11:01:51</wp:post_modified_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>topcoder-srm-651</wp:post_name>
  <wp:status>publish</wp:status>
  <wp:post_parent>0</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>post</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <category domain="category" nicename="topcoder"><![CDATA[Topcoder]]></category>
  <wp:postmeta>
    <wp:meta_key>_publicize_pending</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_rest_api_published</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_rest_api_client_id</wp:meta_key>
    <wp:meta_value><![CDATA[-1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_facebook</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_google_plus</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_twitter</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_linkedin</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_tumblr</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_path</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
</item>
<item>
  <title>Мендо - Регионален натпревар 2015</title>
  <link>https://aandevski.wordpress.com/2015/03/02/%d0%bc%d0%b5%d0%bd%d0%b4%d0%be-%d1%80%d0%b5%d0%b3%d0%b8%d0%be%d0%bd%d0%b0%d0%bb%d0%b5%d0%bd-%d0%bd%d0%b0%d1%82%d0%bf%d1%80%d0%b5%d0%b2%d0%b0%d1%80-2015/</link>
  <pubDate>Mon, 02 Mar 2015 19:48:34 +0000</pubDate>
  <dc:creator>add1ctus</dc:creator>
  <guid isPermaLink="false">https://aandevski.wordpress.com/?p=53</guid>
  <description/>
  <content:encoded><![CDATA[Иако сеуште нема официјални информации за тоа кој се ќе учествува на државниот натпревар, би сакал да им честитам на сите што ќе бидат изберени. За останатите, не се разочарувајте. Побогати сте со една година искуство и можеби некое ново пријателство, кое многу значи (од лично искуство - сум имал натпревари со 0 поени). Искористете го ова како мотивација да вежбате и научите нешто ново, за да успеете наредниот натпревар. Знаењето кое ќе го стекнете ќе ви е многу корисно и за во иднина, не само за натпреварите (како студент можам да ви кажам дека со добри резултати на натпревариве можете да добивате супер оценки по програмирање на факултет).

За жал никој ја немаше решено последната задача, но би сакал исто така да ги спомнам Марија и Дамјан, единствените што успеаа да ја решат четвртата задача. Честитки! А сега, да ги разгледаме задачите...<!--more-->
<h1>Штрајк</h1>
<a href="http://mendo.mk/Task.do?id=533">Текст од задачата</a>

Во задачата ни се откриени само две работи: колку седмици трае регуларното полугодие (секогаш 18), и колку денови траел штрајкот (внесен како N, од 0 до 30). Кога завршува штрајкот, може веднаш да се започне со одработување на изгубените денови во сабота, а кога ќе поминат првобитните 18 седмици, тогаш ги обработуваме изгубените денови 6 дена во седмица.

Да решаваме чекор по чекор. За да знаеме колку денови ќе се одработат во првите 18 седмици, потребно е да знаеме кога сме започнале со одработување саботи. Доколку го поделиме бројот N со 5, ќе знаеме колку седмици имаме изгубено целосно (каде што сеуште траел штрајкот и не можеме да учиме во сабота). Така да можеме да одработиме 18-N/5 саботи. Доколку овој број е поголем или еднаков од бројот на изгубени денови (доколку 18-N/5 &gt;= N), тогаш можеме да ги одработиме сите изгубени денови во саботите кои се дел од школската година. Во тој случај, печатиме 0 (бидејќи нема да се продолжи школската година).

Во вториот случај, и покрај одработување саботи, сеуште имаме настава која треба да се одржи на крајот на школската година. Со N-(18-N/5) можеме да провериме уште колку денови треба да се одработат. Бидејќи работиме по 6 дена во седмица тогаш со (N-(18-N/5))/6 можеме да добиеме колку дополнителни седмици ќе се потребни за одработување. При тоа, треба да внимаваме на едно нешто: дури и да имаме само 1 додатен ден за одработување, тоа се брои како цела седмица (така да бројот што ќе го добиеме треба да го заокружиме на најблискиот број поголем од добиениот). За тоа ја користиме ceil функцијата и делиме со 6.0 наместо 6 (за да добиеме резултат како децимален број). Го печатиме добиениот број.

<a href="http://pastebin.com/8PsJGNd3">Решение во C++</a>
<h1>Булевар</h1>
<a href="http://mendo.mk/Task.do?id=538">Текст од задачата</a>

Малите броеви ни дозволуваат brute force решение. Правиме две низи од тип boolean кои ни ги означуваат парцелите на двете страни на булеварот. Ставаме true доколку можеме да ставиме нова зграда таму, во спротивно false. На почетокот сите вредности се true. Ги внесуваме зградите една по една и проверуваме на која страна се наоѓаат. Да замислиме дека зградите се подредени на овој начин:

<code>1 2
3 4
5 6
7 8
9</code>

За дадена зграда X, таа се наоѓа од левата страна доколку X%2==1, во спротивно се наоѓа од десната страна. За да откриеме на која позиција на таа страна се наоѓа, го делиме бројот со 2. Додатно, доколку зградата е од десната страна, одземаме еден од бројот (бидејќи почнуваме да броиме од нулта позиција). Сега кога веќе знаеме на која страна и на која позиција е зградата, треба да ги означиме сите полиња од позиција-м до позиција+м како зафатени на таа страна.

Кога веќе знаеме кои полиња се слободни, само е потребно да додадеме нови згради на слободните полиња. При тоа, секогаш кога ставиме нова зграда на позиција X, го зголемуваме бројачот за 1 и позициите од X до X+M ги означуваме како зафатени. Истото го правиме за двете страни. На десната страна имаме вкупно n/2 парцели, но на левата страна има n/2+n%2 парцели (доколку има непарен број на парцели, тогаш левата страна ќе има една парцела повеќе). Го печатиме бројачот.

<a href="http://pastebin.com/ZwArQYtZ">Решение во C++</a>
<h1>Топки</h1>
<a href="http://mendo.mk/Task.do?id=539">Текст од задачата</a>

Неколку клучни забелешки:
<ul>
	<li>Бидејќи веќе имаме сортирана низа, заради најмалку додавања на топки потребно е децата од левата страна да имаат повеќе топки од децата на десната страна, така да првите m%n деца ќе имаат n/m+1 топки, а останатите ќе имаат n/m топки на крајот</li>
	<li>Бидејќи ќе имаме повеќе топки од потребно на левата страна и помалку од потребно на десната страна, секогаш даваме топки од лево кон десно</li>
	<li>Потребно е да го минимизираме растојанието на додавањата. Пример, доколку додаваме од позициите 1 и 2 кон позициите 3 и 4, тогаш се додава 1-&gt;3 и 2-&gt;4.</li>
</ul>
Можеме да направиме queue од парови каде што ќе ги ставаме сите топки што ги имаме и ќе забележуваме на која позиција се наоѓаат, внесувајќи дете по дете од левата страна. Веднаш искористуваме колку топки ни се потребни и ги задржуваме на таа позиција, а останатите ги оставаме во queue. Доколку немаме вишок топки останато, детето го вадиме од queue. Доколку имаме некое дете кое има помалку топки од потребното, тогаш земаме топки од првото дете од лева страна кое има вишок топки (првиот член во queue), се додека немаме доволно топки. Секогаш при земањето на вишок топки ги бришеме децата кои снемале вишок топки од queue.

За да додадеме топки од дете X до дете Y, потребно е да направиме Y-X додавања. Го наоѓаме најголемиот број Y-X за сите додавања што ќе ги направиме, и го печатиме најголемиот број.

Задачата би можела да се реши и без queue, така што ќе водиме евиденција кое е детето најлево што има вишок топки.

<a href="http://pastebin.com/H0PrqWFx">Решение во C++</a>
<h1>Монитор</h1>
<a href="http://mendo.mk/Task.do?id=534">Текст од задачата</a>

Да замислиме дека имаме некоја функција F(x,y) = број на линии во правоаголник кој започнува од точките x,y и завршува во точките x+k,y+k. Ја проверуваме оваа вредност за сите x,y од 0,0 до n-k,m-k и го печатиме најмалиот број. Во најлош случај би требало да направиме највеќе 100,000,000 проверки, кои се изводливи во 1 секунда. Проблемот е во наоѓање на бројот на линии во тој замислен правоаголник, бидејќи ако тоа трае повеќе време, кога ја вршиме проверката 100,000,000 пати, лесно можеме да го надминеме временскиот лимит.

Клучот тука е меморизација - да пресметаме само еднаш колку линии имаме и да ги запишеме резултатите во некои променливи. Бидејќи се работи за највеќе 20,000 линии, тоа не би зафатило ни 1MB меморија, што е изводливо (меморискиот лимит е 64MB). На кој начин го правиме тоа?

Во низа ver[n] можеме да ги запишеме бројот на расипани линии, така што ver[x] = број на расипани колони од 0 до x. Исто така правиме за хоризонталните линии со низа hor[m], каде што hor[x] = број на расипани редови од 0 до x. Доколку првиот ред ни е расипан, тогаш hor[0]=1, во спротивно, hor[0]=0. Истото важи и за вертикалните линии. Преостанатиот дел од низата можеме да го пополниме на следниов начин:
<ul>
	<li>Доколку x-тиот ред/колона е расипан, тогаш ver/hor[x]=ver/hor[x-1]+1</li>
	<li>Доколку x-тиот ред/колона не е расипан, тогаш ver/hor[x]=ver/hor[x-1]</li>
</ul>
Со ова можеме лесно да го добиваме бројот на линии во било кој правоаголник. Број на вертикални линии измеѓу колоните a и b е ver[b]-ver[a-1]. Така да F(x,y) = ver[x+k-1]-ver[x-1] + hor[y+k-1] - hor[y-1]. Ги проверуваме сите точки и печатиме најмал резултат на F(x,y).

<a href="http://pastebin.com/xhd3LebQ">Решение во C++</a>
<h1>Автопат</h1>
<a href="http://mendo.mk/Task.do?id=537">Текст од задачата</a>

Да замислиме граф со K темиња, означени од 1 до K каде што секое теме означува контролна точка. Две темиња се поврзани доколку го знаеме растојанието помеѓу нив. Бидејќи се работи за можни 10,000 полиња, не можеме графот да го претставиме како матрица и мора да користиме вектор од вектор од парови, каде што во вектор[x] ги имаме сите темиња поврзани со x, каде што првиот член на парот е бројот на поврзаното теме а вториот член на парот е далечината.

Доколку темето a е поврзано со b и темето c е поврзано со b, тогаш можеме да го откриеме патот помеѓу a и c. Така да треба да го изминеме графот со почеток од темето t1. Доколку успееме да стигнеме до t2, можеме да го добиеме решението. Во спротивно, печатиме -1. Тоа може да се постигне со DFS. Чуваме низа dalecini која означува колку е растојанието на секое теме од темето t1, исто така и низа poseteno која означува за која точка знаеме растојание.

Го започнуваме DFS-то од точката t1, и притоа го правиме следново. Доколку ја посетиме точката X од точката Y, тогаш растојанието на точката Y (растојанието на X го веќе имаме) е:
<ul>
	<li>dalecini[X] + растојание од X до Y (доколку Y &gt; X)</li>
	<li>dalecini[X] - растојание од X до Y (доколку X &gt; Y)</li>
</ul>
Притоа вреди да се спомне дека за сите точки помали од t1, далечината ќе е негативен број. За да го спречиме печатењето на негативен резултат доколку t1 е поголемо од t2, ги заменуваме двете променливи во тој случај. Кога полето t2 е посетено, DFS-то може да прекине и го печатиме резултатот. Но доколку DFS-то ги помине сите можни точки и сеуште не е точката t2 посетена, тогаш печатиме -1.

<a href="http://pastebin.com/2tf7EeYm">Решение во C++</a>]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>53</wp:post_id>
  <wp:post_date>2015-03-02 20:48:34</wp:post_date>
  <wp:post_date_gmt>2015-03-02 19:48:34</wp:post_date_gmt>
  <wp:post_modified>2015-03-22 13:05:34</wp:post_modified>
  <wp:post_modified_gmt>2015-03-22 12:05:34</wp:post_modified_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>%d0%bc%d0%b5%d0%bd%d0%b4%d0%be-%d1%80%d0%b5%d0%b3%d0%b8%d0%be%d0%bd%d0%b0%d0%bb%d0%b5%d0%bd-%d0%bd%d0%b0%d1%82%d0%bf%d1%80%d0%b5%d0%b2%d0%b0%d1%80-2015</wp:post_name>
  <wp:status>publish</wp:status>
  <wp:post_parent>0</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>post</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <category domain="post_tag" nicename="ad-hoc"><![CDATA[Ad hoc]]></category>
  <category domain="post_tag" nicename="dfs"><![CDATA[DFS]]></category>
  <category domain="category" nicename="%d0%bc%d0%b5%d0%bd%d0%b4%d0%be"><![CDATA[мендо]]></category>
  <category domain="post_tag" nicename="greedy"><![CDATA[Greedy]]></category>
  <wp:postmeta>
    <wp:meta_key>_publicize_pending</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_rest_api_published</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_rest_api_client_id</wp:meta_key>
    <wp:meta_value><![CDATA[-1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_facebook</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_google_plus</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_twitter</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_linkedin</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_tumblr</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_path</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
</item>
<item>
  <title>Мендо - Селфи</title>
  <link>https://aandevski.wordpress.com/2015/03/08/%d0%bc%d0%b5%d0%bd%d0%b4%d0%be-%d1%81%d0%b5%d0%bb%d1%84%d0%b8/</link>
  <pubDate>Sun, 08 Mar 2015 14:27:13 +0000</pubDate>
  <dc:creator>add1ctus</dc:creator>
  <guid isPermaLink="false">https://aandevski.wordpress.com/?p=56</guid>
  <description/>
  <content:encoded><![CDATA[Бидејќи овие неколку дена не учествував во онлајн натпревари (всушност и немаше многу), решив да објаснам една малку потешка задача од вообичаено, Селфи од МОИ 2014. Идејата за оваа задача ја добив уште на натпреварот, но добив само 30 од 100 поени заради недоволна оптимизација и губење на прецизност. Идејата на задачата не е толку тешка, колку што е тешка имплементацијата (решението е скоро 200 линии код), така да не би ја препорачал задачата за почетници.<!--more-->

<a href="http://mendo.mk/Task.do?id=480">Линк до задачата</a>

Прво нешто што треба да знаеме е што е потребно за некој број да е „селфи број“? Текстот ни кажува дека цифрите 0,1 и 8 се симетрични сами со себе, додека 5 и 2 се заемно симетрични. Така да, доколку некој број содржи друга цифра освен овие, тој не е е селфи број. Доколку бројот се состои само од тие цифри, тогаш тој треба да е палиндром - со една забелешка. Доколку од една страна на бројот имаме 2, од друга страна треба да имаме 5 (или обратно). Така да иако бројот 8228 е палиндром, не го броиме како селфи број, додека броевите 8258 и 8528 ги броиме.

Постојат две brute force решенија (кои сами по себе би го надминале временскиот лимит):
<ul>
	<li>Проверување на сите броеви од p до k (еден по еден) дали се селфи броеви</li>
	<li>Генерирање на сите селфи броеви и проверување кои се во опсегот [p,k]</li>
</ul>
Со првото решение може да имаме вкупно 1,000,000,000,000,000,000 броеви за тестирање, што е крајно неоптимизирано, доколку земете во предвид дека треба да ги вадите цифрите една по една од секој од тие броеви.

Доколку ги генерираме сите броеви кои се состојат од цифрите 0,1,2,5,8, долги помеѓу 1 и 18 цифри тогаш треба да генерираме вкупно 6,657,201 броеви. Но сепак бидејќи на нас ни се потребни само палиндроми, можеме да ги генерираме броевите долги помеѓу 1 и 9 цифри и да ги пресликуваме за да добиваме броеви од 1 до 18 цифри. Така да вкупниот број на броеви што треба да ги генерираме е 120,852, што и не е толку голем број. Доколку ги исклучиме сите броеви што почнуваат со 0, овој број се намалува уште повеќе. Голема разлика од првобитните 1,000,000,000,000,000,000 што требаше да ги проверуваме, но сепак не е доволно оптимизирано бидејќи треба секоја комбинација да ја проверуваме дали е поголема од P и помала од K.

За додатна оптимизација може да се употреби динамичко програмирање, кое ќе елиминира многу броеви кои треба да се генерираат. Да погледнеме колку селфи броеви има со N цифри:

<code>
1 цифра - 3 броја (0, 1, 8)
2 цифри - 4 броја (11, 25, 52, 88)
3 цифри - 12 броја (101, 111, 181, 205, 215, 285, 502, 512, 582, 808, 818, 888)
4 цифри - 20 броја
5 цифри - 60 броја
...</code>

Секако, не ги броев сите 60 5-цифрени броја рачно, туку има начин како да ги добиеме (за сите броеви освен 1 и 2 цифрените). Доколку имаме селфи броеви со 2 цифри, тогаш можеме да добиеме 3 цифрени селфи броеви така што во средината ќе додадеме една од цифрите 0, 1 или 8. Бидејќи можеме 3 броја да добиеме од секој број, тогаш <strong>број на</strong> <strong>3-цифрени броеви = број на 2-цифрени броеви * 3</strong>. Истото важи за сите непарни броеви на цифри (добивање на 5-цифрени од 4-цифрени, итн). Доколку пак имаме 2-цифрени броеви и сакаме да ги добиеме сите 4-цифрени селфи броеви, тогаш тоа може да се постигне со додавање на еден од овие броеви во средина на бројот: 00, 11, 25, 52, 88. Бидејќи имаме 5 различни броеви добиено, тогаш <strong>број на 4-цифрени броеви = број на 2-цифрени броеви * 5</strong>. Истото важи за сите парни броеви на цифри.

Според ова, со просто динамичко програмирање можеме да ја генерираме низата:


[code language="cpp"]

dp[2]=4;
for(int i=3;i&amp;lt;19;i++)
    if(i%2==0)
        dp[i]=dp[i-2]*5;
    else
        dp[i]=dp[i-1]*3;

[/code]


Така да, на пример, кога би се внеле броевите p=20 и k=123,456,789,123,456,789, тогаш ние само треба да ги пронајдеме сите 2-цифрени и 18-цифрени селфи броеви. Бројот на сите останати селфи броеви е збирот на сите броеви од dp[3] до dp[17]. Тука најлош случај би било кога треба да се генерираат сите 17 и 18 цифрени броеви, за што треба да ги генерираме сите комбинации од 8 и 9 цифри (кои би ги пресликале). Тоа се вкупно 59,049 9-цифрени броеви и 32,768 8-цифрени броеви. Но бидејќи при пресликување на 8-цифрените броеви добиваме 16-цифрени броеви, потребно е на сите да им додаваме по една цифра во средина (0, 1 или 8), така да имаме вкупно 98,304 проверки на 8-цифрени броеви, вкупно 157,353.

Сега, кога ја знаеме идејата доаѓа вистинскиот проблем: имплементацијата. За запишување на броевите имаме неколку избора:
<ul>
	<li>Long long integer - Лесно е да се провери дали некој број е помеѓу границите p и k, но споро се генерираат броевите (многу множење и делење).</li>
	<li>String - Спора проверка на броеви (цифра по цифра почнувајќи од лево), но побрзо генерирање на броевите (само додаваме и одземаме букви од стрингот)</li>
	<li>Vector&lt;int&gt; - Исто така имаме спора проверка на броеви, но брзо генерирање. Бидејќи ја имаме опцијата pop_back() за бришење на последната цифра и никаде не претвораме char во int или обратно, овој метод е најдобар.</li>
</ul>
Со цел полесно пишување и снаоѓање во кодот, го поделуваме на повеќе функции:
<ul>
	<li>int broj_na_palindromi (int n) - Враќа колку n-цифрени селфи броеви постојат во дадено ограниичување. Ги генерира сите n/2 цифрени комбинации што не започнуваат со 0</li>
	<li>int mirror (vector&lt;int&gt; &amp;v) - Зема вектор со n/2 цифри и го пресликува за да добие селфи број. Проверува дали тој селфи број е во ограничувањата. Доколку треба да проверува селфи броеви со непарен број на цифри, ги додава цифрите 0, 1 или 8 во броевите. Враќа број на селфи броеви што се во ограничувањата (0 или 1 за парни броеви, од 0 до 3 за непарни)</li>
	<li>bool test(vector&lt;int&gt; &amp;v) - Проверува дали добиениот број од mirror е во ограничувањата или не. Враќа true или false.</li>
	<li>int brojNaCifri (long long n) - Проста функција за проверка колку цифри има некој број</li>
</ul>
Функцијата broj_na_palindromi се имплементира рекурзивно, така што ги генерира сите 1-цифрени комбинации, па на нив додава броеви за да направи 2-цифрени комбинации, итн додека не стигнеме до n-цифрена комбинација. За да не подаваме параметри на секое рекурзивно повикување, можеме да направиме еден глобален вектор кој ќе го користиме со таа функција.

Функцијата mirror е доста проста за имплементација. Додаваме цифри на крајот на векторот, повикуваме test функција и ги тргаме од крајот на векторот по проверката. Доколку треба да генерираме броеви со непарен број на цифри, тогаш ќе тестираме и пресликуваме 3 пати, така што додаваме една од цифите 0,1 или 8 на крајот па тогаш ги пресликуваме сите цифри освен последната.

За функцијата test потребно е да имаме уште 2 глобални вектора што го означуваат опсегот. На пример, доколку треба да ги пресметаме броевите од 20 до 1200, тогаш ги генерираме броевите во опсегот [20,99] и [1000,1200], а останатите ги добиваме со динамичко програмирање. Доколку опсегот е претставен со векторите limit1 и limit2, тогаш векторот v треба да е помал од limit2 ама поголем од limit1.

Функцијата за број на цифри е проста функција каде што го делиме бројот со 10 и броиме колку пати сме го поделиле. При тоа важно е бројот 0 да го броиме како број со 1 цифра.

Кога веќе ги знаеме сите функции, останува само main функцијата да се напише. Ги читаме броевите a и b, ги запишуваме нивните броеви на цифри во посебин променливи и ја пополнуваме низата DP. Го додаваме збирот од DP[cifria+1] до DP[cifrib-1] во резултатот. Сега имаме два избора:
<ul>
	<li>cifria==cifrib - Во тој случај limit1=a и limit2=b, само е потребно да ги пополниме векторите и да повикаме функција.</li>
	<li>cifria!=cifrib - Во тој случај ја повикуваме функцијата 2 пати, прво за limit1=a, limit2=10<sup>cifria-1</sup>-1, а после за limit1=10<sup>cifrib-1</sup>, limit2=b</li>
</ul>
Одкога ќе го додадеме резултатот од функцијата во резултатот, го печатиме резултатот.

<a href="http://pastebin.com/x0y6EEAk">Решение во C++</a>]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>56</wp:post_id>
  <wp:post_date>2015-03-08 15:27:13</wp:post_date>
  <wp:post_date_gmt>2015-03-08 14:27:13</wp:post_date_gmt>
  <wp:post_modified>2015-03-22 13:04:22</wp:post_modified>
  <wp:post_modified_gmt>2015-03-22 12:04:22</wp:post_modified_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>%d0%bc%d0%b5%d0%bd%d0%b4%d0%be-%d1%81%d0%b5%d0%bb%d1%84%d0%b8</wp:post_name>
  <wp:status>publish</wp:status>
  <wp:post_parent>0</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>post</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <category domain="post_tag" nicename="brute-force"><![CDATA[Brute force]]></category>
  <category domain="post_tag" nicename="%d0%b4%d0%b8%d0%bd%d0%b0%d0%bc%d0%b8%d1%87%d0%ba%d0%be-%d0%bf%d1%80%d0%be%d0%b3%d1%80%d0%b0%d0%bc%d0%b8%d1%80%d0%b0%d1%9a%d0%b5"><![CDATA[Динамичко програмирање]]></category>
  <category domain="category" nicename="%d0%bc%d0%b5%d0%bd%d0%b4%d0%be"><![CDATA[мендо]]></category>
  <wp:postmeta>
    <wp:meta_key>_publicize_pending</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_rest_api_published</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_rest_api_client_id</wp:meta_key>
    <wp:meta_value><![CDATA[-1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_facebook</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_google_plus</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_twitter</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_linkedin</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_tumblr</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_path</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
</item>
<item>
  <title>TopCoder SRM 652</title>
  <link>https://aandevski.wordpress.com/2015/03/09/topcoder-srm-652/</link>
  <pubDate>Mon, 09 Mar 2015 21:09:04 +0000</pubDate>
  <dc:creator>add1ctus</dc:creator>
  <guid isPermaLink="false">https://aandevski.wordpress.com/?p=66</guid>
  <description/>
  <content:encoded><![CDATA[Уште еден (најверојатно) unrated натпревар за TopCoder. Успеав да ја решам првата задача (која впрочем беше тешка за разбирање но имаше многу интересно решение) и со тоа да завршам на 328-мото место од ~530 натпреварувачи во првата дивизија. Како и вообичаено, втората задача беше решена од едвај 30 учесника, додека третата немаше ниту едно испратено решение. Да ја разгледаме првата задача.<!--more-->
<h1>250 - The permutation game</h1>
<a href="http://pastebin.com/nnszYXfK">линк од задачата</a>

Изгубив добри 15 минути да сфатам што се всушност случува во задачата и што се бара. Имено, станува збор за игра која ја играат двајца. Имате дадено број N. Првиот играч бира број X, па потоа вториот играч треба да направи пермутација на броевите од 1 до N (пермутација е било кое подредување на броевите така што ниту еден број не се појавува повеќе од еднаш). Потоа, таа пермутација се применува на бројот X пати, почнувајќи од бројот 1.

[caption id="attachment_67" align="alignleft" width="92"]<a href="https://aandevski.files.wordpress.com/2015/03/untitled.png"><img class="size-full wp-image-67" src="https://aandevski.files.wordpress.com/2015/03/untitled.png" alt="5 извршени пермутации на 3,1,2, почнувајќи од 1" width="92" height="214" /></a> 5 извршени пермутации на 3,1,2, почнувајќи од 1[/caption]

Да разгледаме како изгледа тоа:

Можеме за пример да ја избереме пермутацијата 3,1,2 (N=3), и да ја извршиме 5 пати (X=5).

Бидејќи се почнува од бројот 1, при првото извршување го добиваме првиот број во пермутацијата, 3. Со второто извршување го добиваме третиот број во пермутацијата, 2. Со следното извршување се добива 1, па 3, за на крајот да го добиеме бројот 2, кој е резултатот.

Во задачата на вас ви е даден број N, големината на пермутацијата. Од вас се бара да го најдете најмалиот број X, така што резултатот ќе изнесува 1 за секоја можна пермутација.

Сега, кога веќе ја разбравме конечно задачата, можеме да преминеме на нејзиното решавање. Еден од советите кои најчесто ги давам е секогаш гледајте да ја упростите задачата што повеќе пред да почнете да пишувате код. Доколку во задачата се бара да тестираме N!, не мора да значи дека ние ќе ги тестираме нив. Начинот на кој доаѓаме до идеи за упростување е со решавање на неколку тест примери рачно и барање на некои повторувања / идеи., вештина која најдобро се стекнува со континуирано вежбање. Оваа задача е добар пример за тоа.

Првата забелешка е дека за била која пермутација, доколку бројот 1 е првиот број во пермутацијата, тогаш тој број нема никогаш да се смени за било колку извршувања. Тоа е така бидејќи бројот 1 се наоѓа на позицијата 1. Лесно е да се види дека кога некој број се наоѓа на својата позиција, никогаш нема да се поместиме од таа позиција. Но да видиме што се случува кога некој друг број се наоѓа на својата позиција. На пример доколку бројот 2 се наоѓа на својата позиција, ние воопшто не можеме да стигнеме до тој број. Така да на пример во пермутацијата 3,2,4,1 ние никогаш нема да го посетиме бројот 2, туку само ќе шетаме помеѓу позициите 1,3 и 4. Исто така и за пример 3,2,1,4, ние никогаш нема да стигнеме до позициите 2 и 4(бидејќи се наоѓа ист број на иста позиција), туку само ќе шетаме помеѓу броевите 1 и 3.

Со анализа на некој пример каде што имаме пермутација со N бројки (од кои ниту една не се наоѓа на својата позиција), тогаш можеме да приметиме дека се потребни N извршување за да се вратиме назад на почетната позиција, 1. Но доколку имаме K броеви кои се на својата позиција (освен бројот 1), тогаш е потребно N-K извршувања за да добиеме 1 како резултат.

Така да на пример за N=4, знаеме дека постојат 4 типа на пермутации : каде што сите се на свое место, или каде што 2,3 или 4 броја не се на своето место. Бидејќи рековме дека за пермутацијата каде што сите се на свое место секогаш е резултатот 1, таа нема да ја броиме. Од тука произлегува правилото дека за N броеви, имаме N-1 типа на пермутации кои ќе ги нумерираме од 2 до N (според бројот на броеви што не се на своето место). Да не заборавиме, тој број на пермутацијата исто значи и колку извршувања треба за да се вратиме на почетната позиција.

На нас ни е потребно да откриеме колку најмалку извршувања се потребни, така што сите пермутации би резултирале со 1. Бидејќи знаеме дека пермутацијата со 2 исти има резултат 1 на секои две извршувања, пермутацијата со 3 исти има резултат 1 на секои три извршувања, итн, на нас ни е потребно да најдеме број кој е делив со сите броеви од 2 до N. Или со други зборови, решението е НЗС на сите броеви од 2 до N по модул 100,000,007.

Доколку ја решавате задачата во втората дивизија (и имате N максимум 30), тогаш можете да пресметате НЗС на било кој начин. Но доколку пресметувате НЗС на 100,000 броеви, тогаш е потребна додатна оптимизација. Да се занимаваме малку со математика...

Прости броеви се броеви кои имаат само 2 делитела: 1 и самиот тој број. Пример за прости броеви се 2, 5, 7, 11, 13 и 17. Има бесконечно многу прости броеви. Интересно својство на простите броеви е што секој број може да се разложи на производ од прости броеви. Така на пример бројот 8 = 2 * 2 * 2 и бројот 18 = 2 * 3 * 3. Како можеме да го искористиме ова за НЗС? Да ги разгледаме внимателно овие броеви:

<code>
8 = 2 * 2 = 2<sup>3</sup>
18 = 2 * 3 * 3 = 2 * 3<sup>2</sup> </code>

Овие два броја можат да се добијат од броевите 2 и 3. Притоа, најголемиот степен на бројот 2 е 3, а најголемиот степен на бројот 3 е 2. Доколку ги помножиме броевите со нивните најголеми степени, 2<sup>3</sup> * 3<sup>2</sup> = 72, што е НЗС на броевите 8 и 18. Истото може да се примени и со повеќе броеви, при што ги разложуваме сите и го гледаме најголемиот степен на секој прост број.

Но сепак, доколку разложуваме 100,000 броеви, тоа би траело многу време. Да видиме за пример бројот 2 колкав степен има во различни броеви. Првата забелешка е дека во сите непарни броеви, степенот на 2 е 0 (бидејќи не се деливи со 2). Кај другите броеви, тоа е некој број поголем или еднаков на 1. Доколку ги испишете броевите од 2 до 18, можете да приметите дека степенот 2k е присутен само кај броевите помеѓу 2<sup>k</sup> и 2<sup>k+1</sup> (без да го вклучиме бројот 2<sup>k+1</sup>). Така да за броевите од 2 до 18, најголемиот степен е 2<sup>4</sup>, кој се појавува кај броевите 16 и 18 (двата поголеми или еднакви на 2<sup>4</sup>). Истото важи и за било кој друг број. Така да, знаеме дека за сите броеви од 1 до N, можеме да го добиемо степенот k за бројот x така што ќе го најдеме најголемиот x<sup>k</sup> кој е помал или еднаков на N.

Според овој заклучок, за да ги добиеме степените на сите прости броеви, треба да ги степенуваме се додека не стигнеме до број поголем од N. Но за тоа, прво е потребно да ги генерираме сите прости броеви помали од N, што се постигнува најлесно со Ератостеново сито.

[code language="cpp"]
    vector&amp;lt;int&amp;gt; prosti;
    bool eProst[100000];
    
    memset(eProst,true,100000);
    eProst[0]=eProst[1]=false;

    
    for(int i=2;i&amp;lt;100000;i++)
        if(eProst[i])
        {
            prosti.push_back(i);
            for(int k=i+i;k&amp;lt;100000;k+=i)
                eProst[k]=false;
        }
[/code]

Што ни преостанува е за сите прости броеви, да го најдеме најголемиот степен на тој прост број што е помал од N и да го додадеме во резултатот. Притоа ставаме модул за секое додавање, за да не направиме overflow на променливата.

[code language="cpp"]
long long result=1;

for(int i=0;i&amp;lt;prosti.size() &amp;amp;&amp;amp; prosti[i]&amp;lt;=N;i++)
{
    long long temp=prosti[i];
    while(temp&amp;lt;=N)
        temp*=prosti[i];
    result*=(temp/prosti[i])%MOD;
    result%=MOD;
}
[/code]

По извршување на овој код, во променливата result го имаме резултатот, со што е решена задачата.

Успеавме да стигнеме од проверка на 100,000 пермутации (доколку ве интересира колку различни пермутации има - бројот има  456,574 цифри) до проверка на ~9,500 броеви (толку прости броеви има помали од 100,000) во 20 линии код.]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>66</wp:post_id>
  <wp:post_date>2015-03-09 22:09:04</wp:post_date>
  <wp:post_date_gmt>2015-03-09 21:09:04</wp:post_date_gmt>
  <wp:post_modified>2015-03-22 13:03:49</wp:post_modified>
  <wp:post_modified_gmt>2015-03-22 12:03:49</wp:post_modified_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>topcoder-srm-652</wp:post_name>
  <wp:status>publish</wp:status>
  <wp:post_parent>0</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>post</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <category domain="post_tag" nicename="%d0%bc%d0%b0%d1%82%d0%b5%d0%bc%d0%b0%d1%82%d0%b8%d0%ba%d0%b0"><![CDATA[Математика]]></category>
  <category domain="category" nicename="topcoder"><![CDATA[Topcoder]]></category>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_facebook</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_google_plus</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_twitter</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_linkedin</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_tumblr</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_path</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_rest_api_published</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_rest_api_client_id</wp:meta_key>
    <wp:meta_value><![CDATA[-1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_publicize_pending</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
</item>
<item>
  <title>Untitled</title>
  <link>https://aandevski.wordpress.com/2015/03/09/topcoder-srm-652/untitled/</link>
  <pubDate>Mon, 09 Mar 2015 19:51:55 +0000</pubDate>
  <dc:creator>add1ctus</dc:creator>
  <guid isPermaLink="false">http://aandevski.files.wordpress.com/2015/03/untitled.png</guid>
  <description/>
  <content:encoded><![CDATA[]]></content:encoded>
  <excerpt:encoded><![CDATA[5 извршени пермутации на 3,1,2, почнувајќи од 1]]></excerpt:encoded>
  <wp:post_id>67</wp:post_id>
  <wp:post_date>2015-03-09 20:51:55</wp:post_date>
  <wp:post_date_gmt>2015-03-09 19:51:55</wp:post_date_gmt>
  <wp:post_modified>2015-03-09 20:52:21</wp:post_modified>
  <wp:post_modified_gmt>2015-03-09 19:52:21</wp:post_modified_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>untitled</wp:post_name>
  <wp:status>inherit</wp:status>
  <wp:post_parent>66</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>attachment</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <wp:attachment_url>https://aandevski.files.wordpress.com/2015/03/untitled.png</wp:attachment_url>
</item>
<item>
  <title>CodeFu Seasonal: 2015 Winter</title>
  <link>https://aandevski.wordpress.com/2015/03/16/codefu-seasonal-2015-winter/</link>
  <pubDate>Mon, 16 Mar 2015 22:40:18 +0000</pubDate>
  <dc:creator>add1ctus</dc:creator>
  <guid isPermaLink="false">https://aandevski.wordpress.com/?p=74</guid>
  <description/>
  <content:encoded><![CDATA[Изминатава недела немаше многу натпревари. Освен CodeChef March Challenge и HackerRank Weekly Challenge (кои траеа помеѓу 5 и 10 дена), се одржа и првиот CodeFu натпревар за оваа година, Winter Seasonal. За оние кои не се запознаени со CodeFu, се работи за македонски натпревар наменет за студентите (но сепак отворен за сите). Има 3 онлајн натпревари годишно (Winter, Summer и Autumn seasonal), но исто така го има главниот CodeFu натпревар кој се состои од 2 онлајн квалификациони рунди и офлајн финале со најдобрите 32 натпреварувачи.

Натпреварот го започнав супер и успеав да пратам точно решение на првите 3 задачи во првите 15-20 минути од почетокот на натпреварот (веројатно како последица од учеството на TopCoder и Codeforces натпревари, каде што времето е клучно за добивање поени), пред било кој друг. Но нажалост тука и застанав, потрошувајќи ги следните час и половина поправајќи погрешни идеи за четвртата задача. Успеав да го добијам 18-тото место(кое го делев заедно со уште 6 учесника) од вкупно 62 учесника. Ова беа моите решенија на првите 3 задачи:<!--more-->
<h1>100 - LargestPart</h1>
<a href="http://codefu.mk/codefu2015winter.html?subpage=problem&amp;problemid=2145">Линк до задачата (потребно е да се логирате)</a>

Мислам дека станува збор за задача која не е потребно да се објаснува и е ставена за да ги тестира основните познавања од програмирање на натпреварувачот (ако земеме во обзир дека вакви задачи би се паѓале и на колоквиуми од прв семестар). Бидејќи секогаш имаме број на елементи во низа кој е делив со 3, потребно беше само да ги провериме збировите на елементите во низата од овие три интервали (доколку N е големината на низата, а низата ја индексираме од 0):
<ul>
	<li>од 0 до N/3-1</li>
	<li>од N/3 до N*2/3-1</li>
	<li>од N*2/3 до N-1</li>
</ul>
Го чуваме збирот на сите 3 интервали во посебни променливи, и ги споредуваме. Враќаме резултат.


[code language="cpp"]
string getLargest(vector&lt;int&gt; array)
    {
        int sum[3]={0,0,0};
        for(int i=0;i&lt;array.size()/3;i++)
            sum[0]+=array[i];
        for(int i=array.size()/3;i&lt;array.size()*2/3;i++)
            sum[1]+=array[i];
        for(int i=array.size()*2/3;i&lt;array.size();i++)
            sum[2]+=array[i];
        if(sum[0]&gt;sum[1] &amp;&amp; sum[0]&gt;sum[2])
            return &quot;First&quot;;
        if(sum[1]&gt;sum[0] &amp;&amp; sum[1]&gt;sum[2])
            return &quot;Second&quot;;
        if(sum[2]&gt;sum[1] &amp;&amp; sum[2]&gt;sum[0])
            return &quot;Third&quot;;
      return &quot;Ambiguous&quot;;
  }
[/code]

<h2>200 - Backwards Compatible</h2>
<a href="http://codefu.mk/codefu2015winter.html?subpage=problem&amp;problemid=2146">Линк до задачата</a>

За оваа задача веќе е потребно некое размислување. Клучната забелешка е ограничувањето на задачата. Со највеќе 50 лаптопи/полначи, не се потребни големи оптимизации за да ја решите задачата. Решението е greedy избор.

Да замислиме дека имаме 2 лаптопа, A и B, при што лаптопот A е понов лаптоп. Сите полначи кои што се компатибилни со лаптопот B се компатибилни и со лаптопот A, но обратното не важи. Така да за да ја решиме задачата почнуваме од најстарите лаптопи, што е всушност greedy изборот.

Доколку имаме повеќе полначи компатибилни со еден лаптоп, кој го избираме? Одговорот е било кој, а сега ќе видиме зошто. Да замислиме дека имаме полначи A и B кои се компатибилни со некој лаптоп X. Заради greedy изборот, ние сме сигурни дека лаптопот X е најстариот лаптоп кој го имаме (кој сеуште нема пронајдено полнач). Доколку и двата полначи A и B се компатибилни со X, тогаш тие се компатибилни со било кој друг лаптоп (бидејќи сите други лаптопи се понови од X), така да и да избереме било кој полнач, резултатот нема да се смени.

Фактот дека имаме 2 вектора наместо 2 низи ни ја прави оваа задача полесна. Наместо да внимаваме кои полначи сме ги веќе искористиле, можеме едноставно да ги избришеме од векторот. Така да почнувајќи од најстариот, за сите лаптопи еден по еден наоѓаме некој полнач и ги бришеме од векторот (дури и да не најдеме компатибилен полнач). При тоа, секогаш кога ќе најдеме компатибилен полнач, и него го бришеме од векторот на полначи. Задачата прекинува кога некој од векторите ќе е празен.


[code language="cpp"]
int countMaxMatches(vector&lt;int&gt; laptops, vector&lt;int&gt; chargers)
    {
        int rez=0;
        sort(laptops.begin(),laptops.end());
        while(!laptops.empty() &amp;&amp; !chargers.empty())
        {
            int currentlaptop=laptops[0];
            for(int i=0;i&lt;chargers.size();i++)
                if(currentlaptop&gt;=chargers[i])
                {
                    rez++;
                    chargers.erase(chargers.begin()+i);
                    break;
                }
            laptops.erase(laptops.begin()+0);
        }
      return rez;
  }
[/code]

<h1>300 - Merging</h1>
<a href="http://codefu.mk/codefu2015winter.html?subpage=problem&amp;problemid=2147">Линк до задачата</a>

Изненадно за мене, оваа задача беше помалку пати решена од 4тата задача, но беше значително полесна (веројатно текстот бил збунувачки за некои од натпреварувачите). Бидејќи станува збор за 50 компании, можеме да провериме за сите дали може нејзиното име да се искористи за главната компанија. Повторно се користи greedy за да ја направиме таа проверка.

Да го разгледаме првиот тест пример со компаниите 10, 7, 1, 3, 7 и 5. Прво нешто што можеме да заклучиме е дека компанијата со 10 вработени може да стане главна компанија така што сите други компании ги спојуваме со неа една по една. Но дали може другите компании да се искористат? Да ја земеме за пример компанијата 5, која може да стане главна на овој начин:
<ul>
	<li>Ја спојуваме со компанијата 1. Сега има 6 вработени.</li>
	<li>Ја спојуваме со компанијата 3. Сега има 9 вработени.</li>
	<li>Ја спојуваме со компанијата 7. Сега има 16 вработени.</li>
	<li>Ја спојуваме со компанијата 7. Сега има 23 вработени.</li>
	<li>Ја спојуваме со компанијата 10. Има 33 вработени, веќе сите компании се споени во една.</li>
</ul>
Можете да приметите дека спојувањето се врши во растечки редослед (иако постојат и други редоследи кои би дале точен одговор). За некоја компанија X знаеме дека таа секогаш ќе остане со своето име доколку ја спојуваме со сите компании кои имаат помалку од X вработени. Така да за секоја компанија наместо да претпоставиме дека има X вработени на почетокот, можеме да претпоставиме дека има вработени колку збирот на сите компании помали од X + X.

Потоа ни преостанува да ги додаваме поголемите компании една по една, така што секогаш ја земаме најмалата достапна компанија. Доколку најмалата достапна компанија е поголема од нашата изберена компанија, тогаш знаеме дека не постои начин нашата изберена компанија да стане главна.

Бидејќи секогаш ја избираме најмалата компанија, можеме да ја сортираме низата и линеарно да ја изминуваме. Секогаш кога ќе стигнеме до крајот на низата (сме ги поминале сите компании), додаваме +1 на резултатот. Знаеме дека првата компанија нема никогаш да е главна (бидејќи нема помали компании од неа) и последната секогаш ќе е главна, така да тие две не мора да ги тестираме.


[code language="cpp"]
int countNames(vector&lt;int&gt; companies)
    {
        sort(companies.begin(),companies.end());
        int rez=0;
        int sum[companies.size()];
        sum[0]=companies[0];
        for(int i=1;i&lt;companies.size();i++)
            sum[i]=sum[i-1]+companies[i];
        for(int i=1;i&lt;companies.size()-1;i++)
            {
                bool valid=true;
                int currentsum=sum[i];
                for(int j=i+1;j&lt;companies.size();j++)
                {
                    if(currentsum&gt;=companies[j])
                        currentsum+=companies[j];
                    else
                    {
                        valid=false;
                        break;
                    }
                }
                if(valid)
                    rez++;
            }
      return rez;
  }
[/code]


Тоа беа решенијата на задачите кои успеав да ги решам на натпреварот. Ќе го надополнам постот со останатите 2 задачи кога/доколку успеам да ги решам.]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>74</wp:post_id>
  <wp:post_date>2015-03-16 23:40:18</wp:post_date>
  <wp:post_date_gmt>2015-03-16 22:40:18</wp:post_date_gmt>
  <wp:post_modified>2015-04-16 21:44:26</wp:post_modified>
  <wp:post_modified_gmt>2015-04-16 20:44:26</wp:post_modified_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>codefu-seasonal-2015-winter</wp:post_name>
  <wp:status>publish</wp:status>
  <wp:post_parent>0</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>post</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <category domain="post_tag" nicename="ad-hoc"><![CDATA[Ad hoc]]></category>
  <category domain="category" nicename="codefu"><![CDATA[CodeFu]]></category>
  <category domain="post_tag" nicename="greedy"><![CDATA[Greedy]]></category>
  <wp:postmeta>
    <wp:meta_key>_rest_api_client_id</wp:meta_key>
    <wp:meta_value><![CDATA[-1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_rest_api_published</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_publicize_pending</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
</item>
<item>
  <title>HackerRank Weekly Challenge - Week 14</title>
  <link>https://aandevski.wordpress.com/2015/03/21/hackerrank-weekly-challenge-week-14/</link>
  <pubDate>Sat, 21 Mar 2015 12:28:36 +0000</pubDate>
  <dc:creator>add1ctus</dc:creator>
  <guid isPermaLink="false">https://aandevski.wordpress.com/?p=92</guid>
  <description/>
  <content:encoded><![CDATA[Катастрофална недела со натпревари. Изненадно тешки задачи на последниве Codeforces и TopCoder натпревари (интересен факт: никој од Македонија не успеја да ја реши првата задача од првата дивизија од било кој од овие натпревари). Еден натпревар на кој успеав да извадам некој резултат е HackerRank Weekly Challenge, решавајќи 3 од 5 задачи (од кои една не помина целосно нажалост). Да ги разгледаме задачите:<!--more-->
<h1>Largest Permutation</h1>
<a href="https://www.hackerrank.com/challenges/largest-permutation">Линк до задачата</a>

Задачата се решаваше со greedy. Заради природата на лексикографското споредување (почнуваме да ги споредуваме елементите од првиот), мора секогаш да се осигураме дека првиот елемент е најголем можен, потоа вториот, итн. Ја изминуваме линеарно низата и проверуваме дали елементот на таа позиција е поголем од сите елементи десно од него. Доколку е, продолжуваме, доколку не е најголем, тогаш го заменуваме со најголемиот. Можеме да го искорситиме фактот дека работиме со броевите од 1 до N. Според тоа, на i-тата позиција треба да го имаме бројот N-i, доколку не е таму, тогаш го наоѓаме бројот N-i во низата и ги заменуваме нивните места. Дозволено ни е да направиме најмногу K замени. Кога ќе стигнеме до тој број (или до крајот на низата), завршуваме со изминувањето и го печатиме резултатот.

[code language="cpp"]
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
    int n,k;
    cin&gt;&gt;n&gt;&gt;k;
    
    int arr[n];
    for(int i=0;i&lt;n;i++)
        cin&gt;&gt;arr[i];
    
    for(int i=0;i&lt;n &amp;&amp; k;i++)
        if(arr[i]!=n-i)
            for(int j=i+1;j&lt;n;j++)
                if(arr[j]==n-i)
                {
                    swap(arr[j],arr[i]);
                    k--;
                    break;
                }    
    
    for(int i=0;i&lt;n;i++)
    {
        cout&lt;&lt;arr[i]&lt;&lt;&quot; &quot;;
    }
    
    return 0;
}
[/code]

<h1>Number List</h1>
<a href="https://www.hackerrank.com/challenges/number-list">Линк до задачата</a>

Рекурзивно решение. Имаме функција solve (int pocetok, int kraj) која за тој интервал ќе ни го даде бројот на под-стрингови за кои најголемиот број е поголем од k. На кој начин го правиме тоа? Го наоѓаме најголемиот број во тој интервал и гледаме на која позиција е. Според тоа можеме да одредиме во колку подстрингови тој е најголемиот број.

Доколку се работи за интервал со должина S каде што најголемиот број е на позиција P, тогаш бројот на подстрингови од левата страна е P+1 додека бројот на подстрингови од десната страна е S-P. Доколку ги помножиме тие два броја ги добиваме сите можни подстрингови што го содржат најголемиот број.

Бидејќи сме ги пресметале сите подстрингови со бројот на позиција P, сега е потребно да ја направиме пресметката за подстринговите кои не го вклучуваат тој број. Ја повикуваме рекурзивно функцијата за интервалите од почетокот на интервалот до P-1 и од P+1 до крајот на интервалот. На овој начин ги пресметуваме сите интервали што имаат барем еден број поголем од k. Доколку не постои таков број во интервалот, враќаме 0.

[code language="cpp"]
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

int arr[200000];
int n,k;

long long no_substrings(int s, int p)
{
    return (p+1)*(s-p);
}

long long solve(int start, int finish)
{
    if(start&gt;finish)
        return 0;
    int maks=0,maksid;
    for(int i=start;i&lt;=finish;i++)
    {
        if(arr[i]&gt;maks)
        {
            maks=arr[i];
            maksid=i;
        }
    }
    if(maks&lt;=k)
        return 0;
    return no_substrings(finish-start+1,maksid-start)+solve(start,maksid-1)+solve(maksid+1,finish);
}

int main()
{
    ios_base::sync_with_stdio(false);
    int t;
    cin&gt;&gt;t;
    while(t--)
    {
        cin&gt;&gt;n&gt;&gt;k;

        for(int i=0;i&lt;n;i++)
            cin&gt;&gt;arr[i];

        cout&lt;&lt;solve(0,n-1)&lt;&lt;endl;
    }
    return 0;
}
[/code]

Заради големиот број на внесени податоци, користиме sync_with_stdio(false) за да ја забрзаме задачата. Овој код успеа да падне на 3 тест примери кои се преголеми за да ги анализирам. Доколку ја најдам грешката ќе го едитирам кодот.
<h1>Superman Celebrates Diwali</h1>
<a href="https://www.hackerrank.com/challenges/superman-celebrates-diwali">Линк до задачата</a>

Оваа задача ми се најде полесна од втората, така што успеав да ја решам и пред неа. Доколку имате искуство со динамичко програмирање, просто решение е веднаш воочливо. Правиме матрица people [ N ] [ H ] која ни означува во која зграда на кој кат колку луѓе има. Мислам дека не треба да се објаснува многу во детали овој дел бидејќи е лесен.

Правиме матрица DP со големини N * H (број на згради помножено по нивната висина). Така да бројот DP[ i ] [ j ] ни означува колку луѓе можеме да спасиме доколку се наоѓаме на i-тата зграда на j-тиот кат.  Кога се наоѓаме на зграда DP [ i ] [ j ], имаме два избора:
<ul>
	<li>Да се спуштиме еден кат подолу во истата зграда ( DP [ i ] [ j ] = people [ i ] [ j ] + DP [ i ] [ j-1 ]</li>
	<li>Да скокнеме на друга зграда (онаа која има најголем DP на катот j - I)</li>
</ul>
Првобитното решение кое го пробав е со O(N^3) сложеност. Според точките горе, со bottom-up динамичко ја решавав задачата. За секој кат (i,j) во секоја зграда (почнувајќи од сите згради со првиот кат, па сите згради со вториот кат, итн) ги споредував катот (i,j-1) со сите катови на висина j-I. Но заради големата сложеност овој алгоритам паѓаше временски, што значи дека O(N^3) сложеноста не поминува.

Овој код можеше да се оптимизира на следниов начин: наместо секогаш да проверуваме кој кат има најголем DP на висината j-I, можевме да провериме еднаш и да го запишеме бројот на најголемиот кат на таа висина. Бидејќи сега имаме еден циклус помалку (за секој кат во секоја зграда имаме само if услови наместо for циклус), ја намаливме сложеноста на O(N^2) која е доволна да помине решението. Кога е пополнета целата матрица, го печатиме најголемиот елемент од врвот на сите згради.

[code language="cpp"]
#include &lt;iostream&gt;
#include &lt;cstring&gt;

using namespace std;

int DP[1900][1901];
int people[1900][1901];
int n,h,I;

int main()
{
    ios_base::sync_with_stdio(false);
    cin&gt;&gt;n&gt;&gt;h&gt;&gt;I;

    memset(DP,0,3611900*sizeof(int));
    memset(people,0,3611900*sizeof(int));

    for(int i=0;i&lt;n;i++)
    {
        int temp;
        cin&gt;&gt;temp;
        while(temp--)
        {
            int floor;
            cin&gt;&gt;floor;
            people[i][floor]++;
        }
    }

    int bestonfloor[h+1];
    int tempbest=0;

    bestonfloor[0]=0;

    for(int i=1;i&lt;=h;i++)
    {
        tempbest=0;
        bestonfloor[i]=0;
        for(int k=0;k&lt;n;k++)
        {
            DP[k][i]=DP[k][i-1];
            if(i-I&gt;=0)
                DP[k][i]=max(DP[k][i],DP[bestonfloor[i-I]][i-I]);
            DP[k][i]+=people[k][i];
            if(DP[k][i]&gt;tempbest)
            {
                tempbest=DP[k][i];
                bestonfloor[i]=k;
            }
        }
    }

    cout&lt;&lt;DP[bestonfloor[h]][h];
    
    return 0;
}
[/code]
]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>92</wp:post_id>
  <wp:post_date>2015-03-21 13:28:36</wp:post_date>
  <wp:post_date_gmt>2015-03-21 12:28:36</wp:post_date_gmt>
  <wp:post_modified>2015-03-28 00:07:16</wp:post_modified>
  <wp:post_modified_gmt>2015-03-27 23:07:16</wp:post_modified_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>hackerrank-weekly-challenge-week-14</wp:post_name>
  <wp:status>publish</wp:status>
  <wp:post_parent>0</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>post</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <category domain="post_tag" nicename="%d0%b4%d0%b8%d0%bd%d0%b0%d0%bc%d0%b8%d1%87%d0%ba%d0%be-%d0%bf%d1%80%d0%be%d0%b3%d1%80%d0%b0%d0%bc%d0%b8%d1%80%d0%b0%d1%9a%d0%b5"><![CDATA[Динамичко програмирање]]></category>
  <category domain="post_tag" nicename="%d1%80%d0%b5%d0%ba%d1%83%d1%80%d0%b7%d0%b8%d1%98%d0%b0"><![CDATA[Рекурзија]]></category>
  <category domain="post_tag" nicename="greedy"><![CDATA[Greedy]]></category>
  <category domain="category" nicename="hackerrank"><![CDATA[HackerRank]]></category>
  <wp:postmeta>
    <wp:meta_key>_rest_api_published</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_rest_api_client_id</wp:meta_key>
    <wp:meta_value><![CDATA[-1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_publicize_pending</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
</item>
<item>
  <title>Мендо - Код</title>
  <link>https://aandevski.wordpress.com/2015/03/22/%d0%bc%d0%b5%d0%bd%d0%b4%d0%be-%d0%ba%d0%be%d0%b4/</link>
  <pubDate>Sun, 22 Mar 2015 12:01:11 +0000</pubDate>
  <dc:creator>add1ctus</dc:creator>
  <guid isPermaLink="false">https://aandevski.wordpress.com/?p=95</guid>
  <description/>
  <content:encoded><![CDATA[Се приближува државниот натпревар по програмирање, така да одлучив оваа недела да решам некои од (според мене) поинтересни задачи кои се паднале на претходните државни натпревари. Една од тие е задачата Код од државниот натпревар во 2009.<!--more-->

<a href="http://mendo.mk/Task.do?id=21">Линк до задачата</a>

Бидејќи се работи за број со должина 250 цифри, читање на влезот како било каков тип на број отпада (најголемиот број што можеме да го прочитаме е 18-цифрен со long long), така да ни преостанува да го читаме бројот како низа од карактери или string (било кое би работело без проблеми).

Да го разгледаме пример стрингот, 25114. Стрингот можеме да го прочитаме на следниве начини:
<ul>
	<li>2 5 1 1 4 - BEAAD</li>
	<li>2 5 1 14 - BEAN</li>
	<li>2 5 11 4 - BEKD</li>
	<li>25 1 1 4 - YAAD</li>
	<li>25 1 14 - YAN</li>
	<li>25 11 4 - YKD</li>
</ul>
Што можеме да приметиме од овој пример? Сите броеви во стрингот можеме да ги гледаме како едноцифрени броеви (освен доколку го имаме бројот 0, бидејќи нема буква еквивалент на 0). Но кога го гледаме бројот како двоцифрен број? Само доколку првата цифра е 1 или пак првата цифра е 2 но втората цифра е измеѓу 0 и 6.

Според ова би можеле да го изминеме стрингот линеарно, при тоа забележувајќи која цифра на колку начини може да се искористи. За секоја цифра гледаме дали може да се искористи како едноцифрен број и дали може да се искористи како втората цифра на двоцифрен број (со тоа што ја проверуваме и цифрата пред неа повторно). Бидејќи цифра пред првата нема, знаеме дека таа може само на еден начин да се брои и линеарното изминување го започнуваме од втората цифра.

Како на овој начин го добиваме резултатот? Правиме еднодимензионална низа од integer-и и ја пополнуваме со динамичко програмирање. DP[x] ќе ни означува на колку различни начини може да се декодира стрингот кој ги содржи сите цифри од првата до x-тата цифра во стрингот.

Така на пример за горниот пример

DP[1] = 1 (2 може да се декодира само на еден начин)
DP[2] = 2 (25 може да се декодира како : 25 или 2 5)
DP[3] = 2 (251 може да се декодира како : 2 5 1 или 25 1)
DP[4] = 4 (2511 може да се декодира како : 2 5 1 1, 25 1 1, 2 5 11 или 25 11)
DP[5] = 6 (наброени се горе сите начини за декодирање на целиот стринг)

Низата ја пополнуваме со bottom-up пристап, почнувајќи од 2рата буква (бидејќи знаеме дека секогаш DP[1] = 1 и DP[0] = 1). За i-тата буква од стрингот:
<ul>
	<li>Доколку таа е различна од 0, тогаш DP [i] += DP[i-1]</li>
	<li>Доколку таа може да се искористи како втора цифра на двоцифрен број, DP [i] += DP[i-2]</li>
</ul>
Но бидејќи стрингот ни е индексиран почнувајќи од 0, а низата со динамичко ја започнуваме од 1, мора на бројачот i да додаваме +1. Со тоа го добиваме овој код:

[code language="cpp"]
#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

int main()
{
    string input;
    cin&gt;&gt;input;
    int dp[251];
    dp[0]=dp[1]=1;
    for(int j=1;j&lt;input.size();j++)
    {
        if(input[j]!='0')dp[j+1]=dp[j];
        if((input[j-1]=='1') || (input[j-1]=='2' &amp;&amp; input[j]&lt;='6'))dp[j+1]+=dp[j-1];
    }
    cout&lt;&lt;dp[input.size()];
    return 0;
}
[/code]
]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>95</wp:post_id>
  <wp:post_date>2015-03-22 13:01:11</wp:post_date>
  <wp:post_date_gmt>2015-03-22 12:01:11</wp:post_date_gmt>
  <wp:post_modified>2015-03-22 13:01:51</wp:post_modified>
  <wp:post_modified_gmt>2015-03-22 12:01:51</wp:post_modified_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>%d0%bc%d0%b5%d0%bd%d0%b4%d0%be-%d0%ba%d0%be%d0%b4</wp:post_name>
  <wp:status>publish</wp:status>
  <wp:post_parent>0</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>post</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <category domain="post_tag" nicename="%d0%b4%d0%b8%d0%bd%d0%b0%d0%bc%d0%b8%d1%87%d0%ba%d0%be-%d0%bf%d1%80%d0%be%d0%b3%d1%80%d0%b0%d0%bc%d0%b8%d1%80%d0%b0%d1%9a%d0%b5"><![CDATA[Динамичко програмирање]]></category>
  <category domain="post_tag" nicename="%d1%81%d1%82%d1%80%d0%b8%d0%bd%d0%b3%d0%be%d0%b2%d0%b8"><![CDATA[Стрингови]]></category>
  <category domain="category" nicename="%d0%bc%d0%b5%d0%bd%d0%b4%d0%be"><![CDATA[мендо]]></category>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_facebook</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_google_plus</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_twitter</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_linkedin</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_tumblr</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_path</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_rest_api_published</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_rest_api_client_id</wp:meta_key>
    <wp:meta_value><![CDATA[-1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_edit_last</wp:meta_key>
    <wp:meta_value><![CDATA[55813594]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>geo_public</wp:meta_key>
    <wp:meta_value><![CDATA[0]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_publicize_pending</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:comment>
    <wp:comment_id>9</wp:comment_id>
    <wp:comment_author><![CDATA[Jovan]]></wp:comment_author>
    <wp:comment_author_email>jovanovskijovan97@gmail.com</wp:comment_author_email>
    <wp:comment_author_url/>
    <wp:comment_author_IP>89.205.77.235</wp:comment_author_IP>
    <wp:comment_date>2016-03-21 18:53:25</wp:comment_date>
    <wp:comment_date_gmt>2016-03-21 16:53:25</wp:comment_date_gmt>
    <wp:comment_content><![CDATA[Можеби малку доцна, но забалежав мала грешка во решението. За dp[j+1]+=dp[j-1]; да добие правилна вредност кога input[j]!='0', треба dp[j+1] да има некоја претходна вредност. Затоа пред линијата 11 треба да се дадат вредности 0 за сите полиња на dp: memset(dp, 0, sizeof(int)*251);]]></wp:comment_content>
    <wp:comment_approved>1</wp:comment_approved>
    <wp:comment_type/>
    <wp:comment_parent>0</wp:comment_parent>
    <wp:comment_user_id>0</wp:comment_user_id>
    <wp:commentmeta>
      <wp:meta_key>akismet_result</wp:meta_key>
      <wp:meta_value><![CDATA[false]]></wp:meta_value>
    </wp:commentmeta>
    <wp:commentmeta>
      <wp:meta_key>akismet_history</wp:meta_key>
      <wp:meta_value><![CDATA[a:2:{s:4:"time";d:1458579207.4566218852996826171875;s:5:"event";s:9:"check-ham";}]]></wp:meta_value>
    </wp:commentmeta>
    <wp:commentmeta>
      <wp:meta_key>email_notification_notqueued</wp:meta_key>
      <wp:meta_value><![CDATA[1458579208]]></wp:meta_value>
    </wp:commentmeta>
    <wp:commentmeta>
      <wp:meta_key>email_notification_jobid</wp:meta_key>
      <wp:meta_value><![CDATA[20983174183]]></wp:meta_value>
    </wp:commentmeta>
    <wp:commentmeta>
      <wp:meta_key>email_notification_queued</wp:meta_key>
      <wp:meta_value><![CDATA[1458580042]]></wp:meta_value>
    </wp:commentmeta>
    <wp:commentmeta>
      <wp:meta_key>jabber_published</wp:meta_key>
      <wp:meta_value><![CDATA[1458580042]]></wp:meta_value>
    </wp:commentmeta>
    <wp:commentmeta>
      <wp:meta_key>akismet_history</wp:meta_key>
      <wp:meta_value><![CDATA[a:3:{s:4:"time";d:1458580042.2557399272918701171875;s:5:"event";s:15:"status-approved";s:4:"user";s:8:"add1ctus";}]]></wp:meta_value>
    </wp:commentmeta>
  </wp:comment>
</item>
<item>
  <title>Мендо - Финкимен</title>
  <link>https://aandevski.wordpress.com/2015/03/24/%d0%bc%d0%b5%d0%bd%d0%b4%d0%be-%d1%84%d0%b8%d0%bd%d0%ba%d0%b8%d0%bc%d0%b5%d0%bd/</link>
  <pubDate>Tue, 24 Mar 2015 02:13:28 +0000</pubDate>
  <dc:creator>add1ctus</dc:creator>
  <guid isPermaLink="false">https://aandevski.wordpress.com/?p=104</guid>
  <description/>
  <content:encoded><![CDATA[Без многу вовед, веднаш ќе навлезам во задачата. Иако веројатно постои некое ad hoc решение, задачата е најлесно решлива доколку имате познавања од графови, поточно Flood fill алгоритмот (што е всушност варијација на DFS).<!--more-->

<a href="http://mendo.mk/Task.do?id=140">Линк до задачата</a>

Пред да преминеме на flood fill и на решавањето, првин треба да знаеме која е оптималната стратегија за поставување на роботите. Бидејќи роботите можат само да се движат само на рамен терен или по угорници, идеално решение е доколку ги поставуваме на најниското можно место. Со ова ќе се осигураме дека еден робот може да се прошири на што повеќе места (со што ќе ни бидат потребни помалку роботи). Но дали според оваа логика би можел еден робот да го покрие целиот град? Во некои случаи, да.

Да го разгледаме следниов пример:

1 4 1
1 4 1

Според правилото што го утврдивме, треба да поставиме робот на некое поле со висина 1. Но само еден робот не би можел да го покрие целиот град, бидејќи за да се стигне од левиот крај до десниот крај, тој робот би требало да се качува нагоре па да се спушта надолу (што не може). Така да не секогаш еден робот ќе може да го покрие градот. Во вакви случаи ни се формираат повеќе „групи“ на позиции. За горниот пример би можеле да ги направиме групите вака:

<span style="text-decoration:underline;color:#3366ff;"><strong>1 4</strong></span> 1
<span style="text-decoration:underline;color:#3366ff;"><strong>1 4</strong></span> 1

или

1 <span style="text-decoration:underline;color:#3366ff;"><strong>4 1</strong></span>
1 <span style="text-decoration:underline;color:#3366ff;"><strong>4 1</strong></span>

Бројот на групи ни е всушност бројот на потребни роботи за да се покрие целиот град. Прашањето е како да ги добиеме групите. Веќе претходно заклучивме дека идеалното решение е кога почнуваме од најниското можно поле. Така да во овој случај го бараме најниското поле кое не е во група, и од него се прошируваме во сите 4 насоки (се додека не стигнеме до удолница). Ова се изведува со помош на flood fill алгоритмот и ќе се врши се додека не ги ставиме сите полиња во некоја група.
<h1>Пишување на кодот</h1>
Бидејќи flood fill алгоритмот се имплементира како посебна рекурзивна функција (има и други начини, но нема да ги разгледуваме сега), потребно е мапата што ја внесуваме да е сместена во глобална променлива. Затоа правиме матрица од int mapa[50][50] каде што mapa[i][j] ќе ни означува која е висина на полето со координати i,j. За да водиме евиденција кое поле е веќе ставено во група а кое не, додаваме уште една матрица poseteno[50][50] од тип boolean каде што poseteno[i][j] е true додека полето е веќе ставено во група, а false во спротивно. На крајот додаваме една променлива poseteniTeminja која ни означува колку темиња сме веќе поминале (ставиле во група). Кога овој број ќе стигне до вредноста R*C значи сите темиња се посетени и програмот завршува.

Кога веќе ја знаеме податочната структура, да го размислиме flood fill кодот. Потребно е да имаме функција која кога ќе се повика за некое теме x,y:
<ul>
	<li>Ќе го означи темето x,y како посетено во матрицата poseteno</li>
	<li>Ќе го зголеми бројачот за посетени темиња за 1.</li>
	<li>Ќе проба да ги посети сите околни <strong>непосетени</strong> темиња кои се поголеми или еднакви од темето на кое се наоѓаме (притоа треба да внимавате да не излезете надвор од меморискиот опсег)</li>
</ul>
Првите две можеме да ги средиме со два реда код:

[code language="cpp"]
void floodfill (int x, int y)
{
    poseteno[x][y]=true;
    poseteniTeminja++;
[/code]

Сега потребно е да се посетат сите околни темиња - да ја повикнеме функцијата flood fill рекурзивно за сите 4 поврзани темиња. Доколку се наоѓаме на позицијата x,y, тогаш 4-те соседни темиња се наоѓаат на координатите
<ul>
	<li>x+1, y</li>
	<li>x-1, y</li>
	<li>x, y+1</li>
	<li>x, y-1</li>
</ul>
Прво што треба да направиме е да провериме дали секоја од овие позиции е валидна (да не е некоја координата помала од 0 или поголема од R или C, зависи од тоа дали се работи за X или Y координатата). Доколку позицијата е валидна, тогаш треба да провериме дали таа веќе е ставена во некоја група. Доколку не е ставена (вредноста poseteno на тоа поле е false), тогаш останува само да провериме дали роботот може да се движи во таа насока (дали полето на кое стои е пониско или на иста висина со полето кон кое сакаме да се движиме). Доколку сите овие услови се исполнети, тогаш ја повикуваме функцијата flood fill за тоа поле.

[code language="cpp" firstline="5"]
    if(x+1&lt;r &amp;&amp; !visited[x+1][y] &amp;&amp; mapa[x][y]&lt;=mapa[x+1][y])
        floodfill(x+1,y);
    if(x-1&gt;=0 &amp;&amp; !visited[x-1][y] &amp;&amp; mapa[x][y]&lt;=mapa[x-1][y])
        floodfill(x-1,y);
    if(y+1&lt;c &amp;&amp; !visited[x][y+1] &amp;&amp; mapa[x][y]&lt;=mapa[x][y+1])
        floodfill(x,y+1);
    if(y-1&gt;=0 &amp;&amp; !visited[x][y-1] &amp;&amp; mapa[x][y]&lt;=mapa[x][y-1])
        floodfill(x,y-1);
}
[/code]

Со ова е завршена flood fill функцијата. Единственото нешто што ни преостанува е да ја искористиме таа функција. Се додека не се одредени сите полиња (се додека poseteniTeminja е помало од R*C), потребно е да ја повикаме функцијата floodfill со параметри - најниската точка која сеуште не е посетена. Бидејќи се работи за мала мапа (со големини 30х30), можеме слободно да ја изминеме целата и да го најдеме најниското место. Кога ја добиваме таа точка, ја повикуваме функцијата flood fill за неа. Секогаш кога ја повикуваме floodfill функцијата од main функцијата ние всушност создаваме нова група, така да секогаш кога ќе ја повикуваме функцијата ќе го зголемуваме резултатот за 1.

[code language="cpp"]
while(poseteniTeminja&lt;r*c)
    {
        int najmalBroj=32; //Не постои поле повисоко од 32
        int najmalX,najmalY;
 
        for(int i=0;i&lt;r;i++)
            for(int j=0;j&lt;c;j++)
                if(najmalBroj&gt;mapa[i][j] &amp;&amp; !poseteno[i][j])
                {
                    najmalBroj=mapa[i][j];
                    najmalX=i;
                    najmalY=j;
                }
 
        rezultat++;
        floodfill(najmalX,najmalY);
    }
[/code]

Со прекинување на овој while циклус ќе го добиеме резултатот во променливата rezultat, кој го печатиме.]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>104</wp:post_id>
  <wp:post_date>2015-03-24 03:13:28</wp:post_date>
  <wp:post_date_gmt>2015-03-24 02:13:28</wp:post_date_gmt>
  <wp:post_modified>2015-03-24 03:13:55</wp:post_modified>
  <wp:post_modified_gmt>2015-03-24 02:13:55</wp:post_modified_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>%d0%bc%d0%b5%d0%bd%d0%b4%d0%be-%d1%84%d0%b8%d0%bd%d0%ba%d0%b8%d0%bc%d0%b5%d0%bd</wp:post_name>
  <wp:status>publish</wp:status>
  <wp:post_parent>0</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>post</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <category domain="category" nicename="%d0%bc%d0%b5%d0%bd%d0%b4%d0%be"><![CDATA[мендо]]></category>
  <category domain="post_tag" nicename="flood-fill"><![CDATA[Flood fill]]></category>
  <wp:postmeta>
    <wp:meta_key>_rest_api_client_id</wp:meta_key>
    <wp:meta_value><![CDATA[-1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_rest_api_published</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_publicize_pending</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
</item>
<item>
  <title>Мендо - Државен натпревар 2015</title>
  <link>https://aandevski.wordpress.com/2015/04/08/%d0%bc%d0%b5%d0%bd%d0%b4%d0%be-%d0%b4%d1%80%d0%b6%d0%b0%d0%b2%d0%b5%d0%bd-%d0%bd%d0%b0%d1%82%d0%bf%d1%80%d0%b5%d0%b2%d0%b0%d1%80-2015/</link>
  <pubDate>Wed, 08 Apr 2015 18:07:04 +0000</pubDate>
  <dc:creator>add1ctus</dc:creator>
  <guid isPermaLink="false">https://aandevski.wordpress.com/?p=108</guid>
  <description/>
  <content:encoded><![CDATA[Најпрвин би сакал да се извинам што го пишувам постов толку касно. Натпреварот се поклопи со почетокот на колоквиумската недела, така да од учење и немав многу време да посветам на програмирање. По неколку дена одмор, сега повторно се враќам на решавање задачи и подготовки за натпревари, така да очекувајте многу поредовни постови. А сега, назад на натпреварот.

Честитки до сите што учествуваа, посебно до Христијан кој успеа да го земе првото место со само еден поен разлика, што укажува на тоа колку беше јака конкуренцијата. Во овој пост ќе ги објаснам првите три задачи, додека наредните две ќе ги објаснам во посебни (и поголеми) постови наредните денови. Па, да започнеме..<!--more-->
<h1>Пакети</h1>
<a href="http://mendo.mk/Task.do?id=543">Линк до задачата</a>

Како и вообичаено, првата задача се базира на имплементација која ќе провери колку добро ученикот владее со програмирање, а не со решавање на проблеми. Имено, имаме дадени два броја, A и B - број на чоколади од двата типа. Од вас се бара да го испечатите бројот на различни начини на кои можете да ги поделите чоколадите во еднакви пакети.

На пример, доколку имате 4 чоколади од тип A и 8 чоколади од тип B, тогаш имате 3 начина на поделба:
<ul>
	<li>1 пакет со 4 A и 8 B чоколади</li>
	<li>2 пакети со 2 A и 4 B чоколади</li>
	<li>4 пакети со 1 A и 2 B чоколади</li>
</ul>
Можете да забележите дека броевите 1,2 и 4 се делители на броевите 4 и 8, што насочува дека резултатот го сочинуваат сите броеви кои се делители на броевите A и B, што можеме и да го докажеме. Доколку 4 и 8 чоколади пробаме да поделиме на 3 пакета (број што не е делив со A и B), тогаш во секој пакет би имале 1 A и 2 B чоколади, при што ни остануваат една A и две B чоколади вишок. Ова важи за било кој друг број кој не е делив со A и B. Секогаш ќе има неколку чоколада останати вишок, што значи дека таква респределба не може да се направи.

Се што преостанува е да ги испечатиме сите броеви кои се деливи со A и B. Бидејќи се работи за мал број (највеќе 10,000 чоколади), можеме да ги провериме сите броеви од 1 до 10,000 и да провериме кој од нив е делив со A и B и да го испечатиме.

[code language="cpp"]
#include &lt;iostream&gt;

using namespace std;

int main()
{
    int a,b;
    cin&gt;&gt;a&gt;&gt;b;

    for(int i=1;i&lt;=10000;i++)
        if(a%i==0 &amp;&amp; b%i==0)
            cout&lt;&lt;i&lt;&lt;endl;

    return 0;
}
[/code]

<h1>Арч</h1>
<a href="http://mendo.mk/Task.do?id=541">Линк до задачата</a>

Повторно се работи за имплементација, која во овој случај е малку потешка од првата задача. Доколку го пратите мојот блог веројатно имате веќе видено дека секогаш кога треба да се внесе некој број кој што ќе го поделуваме на цифри, добра навика е бројот да се внесе како string, освен доколку не треба да се прават и други операции на бројот. Тоа ни овозможува многу лесно и брзо проверување на секоја цифра посебно, без потреба на делење на бројот и без ограничување на големината на бројот (со long long највеќе можете да прочитате 18-цифрен број).

Така да што треба да направиме е да внесеме N броја како стрингови, и за секој од нив да провериме дали се состои само од карактерите '0', '2', '4', '6' и '8'. Доколку се состои само од тие карактери, тогаш зголемуваме два бројачи:
<ul>
	<li>broevi++ - што ни означува колку вкупно броеви можеме да искуцаме</li>
	<li>tipki+=broj.size() - означува колку вкупно типки сме притиснале</li>
</ul>

[code language="cpp"]
#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

int main()
{
    int broevi=0,tipki=0,n;
    string broj;

    cin&gt;&gt;n;

    for(int i=0;i&lt;n;i++) 
    { 
        cin&gt;&gt;broj;
        bool mozeDaSeIskuca=true;

        for(int j=0;j&lt;broj.size();j++)
            if(broj[j]=='1' || broj[j]=='3' || broj[j]=='5' || broj[j]=='7' || broj[j]=='9')
                mozeDaSeIskuca=false;

        if(mozeDaSeIskuca)
        {
            broevi++;
            tipki+=broj.size();
        }
    }

    cout&lt;&lt;broevi&lt;&lt;endl&lt;&lt;tipki;

    return 0;
}
[/code]

<h1>Програмери</h1>
<a href="http://mendo.mk/Task.do?id=544">Линк до задачата</a>

Веќе стигнуваме до малку попредизвикувачките задачи. На прв поглед ни оваа задача не е тешка, но доколку обрнете внимание на ограничувањата, задачата станува потешка. Доколку би пробале да направите низа со должина 1,000,000,000 која би означувала кој број колку пати се појавува, таа низа би зафаќала 3.72 гигабајти, што е многу над мемориското ограничување од 64 мегабајти. Од друга страна пак, доколку би ги внеле сите 100,000 броеви во низа (со големина едвај 0.38 мегабајти), тогаш немате брз начин да проверите кој број колку пати се појавува (мислам дека најдобриот случај би бил сортирање со O(N logN) алгоритам па линеарно изминување, кој е најверојатно спор за 200 милисекунди).

Решението (можеби не единствено) се наоѓа во мапа од тип &lt;int, int&gt;. Ја користите на ист начин како што би употребиле обична низа за да забележите кој број колку пати се појавува. Но разликата е во тоа што додека низа би алоцирала 1,000,000,000 елементи во меморијата веднаш, мапата алоцира елементи во меморијата само кога ги повикувате. Така да иако вие можеби пристапувате до броевите 0 и 999,999,999,999 во мапата, таа никогаш нема да алоцира повеќе од 100,000 броја при внес (бидејќи толку различни броја може највеќе да се внесат).

Кога веќе имате информација кој број колку пати се појавува, потребно е само да проверите за секој број X, колку пати се појавуваат броевите X-k и X+k и да го помножите тоа со колку пати се појавува бројот X. На овој начин ќе добиете дупликат вредности (бидејќи секој пар ќе се рачуна два пати), така да потребно е или да го поделите резултатот со 2, или да пресметувате само со X+k или само со X-k (само во една насока). Но како знаеме кои броеви X се внесени во мапата?

Иако постои начин со итератори да ја изминеме содржината на мапата, постои многу полесен начин за кодирање каде што ги пресметуваме паровите веднаш при внесување. Веднаш кога ќе внесеме број X, знаеме дека од него можеме да направиме mapa[X-k] + mapa[X+k] парови во тој момент. Ова правило важи секогаш освен кога k е 0. Да го разгледаме тој случај:
<ul>
	<li>Доколку имаме 2 исти броја, тогаш имаме само 1 пар. Горниот алгоритам би дал резултат 0 или 2.</li>
	<li>Доколку имаме 3 исти броја, тогаш имаме 3 пара (прв и втор, прв и трет, втор и трет). Горниот алгоритам би дал резултат 3 или 12.</li>
	<li>Доколку имаме 4 исти броја, тогаш имаме 6 пара. Нашиот алгоритам би дал резултат 12 или 20.</li>
</ul>
Резултатот зависи од тоа дали прво ја зголемуваме мапата па додаваме резултат или обратно. Бидејќи знаеме дека алгоритмот не е точен, да обрнеме внимание на резултатите со k = 0

2 броја - 1 пар
3 броја - 3 пара
4 броја - 6 пара
5 броја - 10 пара
6 броја - 15 пара

Можеме да го забележиме шаблонот: кога ќе се внесе X-тиот ист број, тогаш бројот на парови се зголемува за X-1.

Се што преостанува е да ја имплементираме идејата во код, при што користиме sync_with_stdio(false) за да го оптимизираме влезот (да работи побрзо):

[code language="cpp"]
#include &lt;iostream&gt;
#include &lt;map&gt;

using namespace std;

int main()
{
    ios_base::sync_with_stdio(false);

    int n,k,broj;
    long long rezultat=0;
    cin&gt;&gt;n&gt;&gt;k;

    map&lt;int, int&gt; mapa;

    if(k==0)
        for(int i=0;i&lt;n;i++)
        {
            cin&gt;&gt;broj;
            mapa[broj]++;
            rezultat+=mapa[broj]-1;
        }
    else
        for(int i=0;i&lt;n;i++)
        {
            cin&gt;&gt;broj;
            mapa[broj]++;
            rezultat+=mapa[broj-k]+mapa[broj+k];
        }
    
    cout&lt;&lt;rezultat;
    
    return 0;
}
[/code]
]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>108</wp:post_id>
  <wp:post_date>2015-04-08 19:07:04</wp:post_date>
  <wp:post_date_gmt>2015-04-08 18:07:04</wp:post_date_gmt>
  <wp:post_modified>2015-04-10 22:10:25</wp:post_modified>
  <wp:post_modified_gmt>2015-04-10 21:10:25</wp:post_modified_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>%d0%bc%d0%b5%d0%bd%d0%b4%d0%be-%d0%b4%d1%80%d0%b6%d0%b0%d0%b2%d0%b5%d0%bd-%d0%bd%d0%b0%d1%82%d0%bf%d1%80%d0%b5%d0%b2%d0%b0%d1%80-2015</wp:post_name>
  <wp:status>publish</wp:status>
  <wp:post_parent>0</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>post</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <category domain="post_tag" nicename="ad-hoc"><![CDATA[Ad hoc]]></category>
  <category domain="category" nicename="%d0%bc%d0%b5%d0%bd%d0%b4%d0%be"><![CDATA[мендо]]></category>
  <wp:postmeta>
    <wp:meta_key>_publicize_pending</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_rest_api_client_id</wp:meta_key>
    <wp:meta_value><![CDATA[-1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_rest_api_published</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
</item>
<item>
  <title>Мендо - Обединети Нации</title>
  <link>https://aandevski.wordpress.com/2015/04/10/%d0%bc%d0%b5%d0%bd%d0%b4%d0%be-%d0%be%d0%b1%d0%b5%d0%b4%d0%b8%d0%bd%d0%b5%d1%82%d0%b8-%d0%bd%d0%b0%d1%86%d0%b8%d0%b8/</link>
  <pubDate>Fri, 10 Apr 2015 21:09:55 +0000</pubDate>
  <dc:creator>add1ctus</dc:creator>
  <guid isPermaLink="false">https://aandevski.wordpress.com/?p=112</guid>
  <description/>
  <content:encoded><![CDATA[Напрвин збунувачка задача, но доста интересна. За сите кои имаат искуство со графови, брзо станува очигледно дека групите се добиваат со DFS. За сите кои немаат, веќе е крајно време да почнете да учите (посебно кога земете во предвид дека и регионалниот и државниот натпревар имаа DFS задача). Да ја разгледаме.<!--more-->

<a href="http://mendo.mk/Task.do?id=545">Линк до задачата</a>

Имаме дадено две или повеќе групи на граѓани, и треба да го испечатиме бројот на начини за избирање на двајца кандидати така да тие се од различна група. Најпрвин, потребно е да можеме да одредиме кои граѓани се заедно во група.

<a href="https://aandevski.files.wordpress.com/2015/04/screenshot_12.png"><img class=" size-full wp-image-114 alignleft" src="https://aandevski.files.wordpress.com/2015/04/screenshot_12.png" alt="Screenshot_12" width="208" height="184" /></a>

Да замислиме граф каде што темињата се граѓаните. Тие се поврзани само доколку имало телефонски разговор помеѓу нив. Иако можеби не е јасно од првото читање на задачата, доколку две граѓани се дел од ист сврзан подграф, тие се дел од иста група. На сликата имате прикажано пример за граф со 5 граѓани, каде што има телефонски повик меѓу граѓаните A и B, меѓу граѓаните C и D и меѓу граѓаните D и E. Тука граѓаните A и B прават еден сврзан подграф (една група), а граѓаните C,D и Е прават втор сврзан подграф (втора група).

Групите ги добиваме така што пуштаме DFS од секое непосетено теме. Сите темиња што ќе се посетат се од иста група. Така да доколку пуштите DFS од темето C, тоа ќе се прошири до темињата D и E, кои се дел од иста група. За ова изминување потребно ви е само да чувате низа од boolean која ќе означува кое теме е веќе посетено.

Но како да се претстави графот? Најлесниот начин е секако матрица на поврзаност, каде што mat[a][b] е 1 доколку темињата a и b се поврзани, и 0 во спротивно. Но во случај каде што имаме 100,000 граѓани, станува збор за матрица со големина од 10,000,000,000, која би зафаќала нешто над 9.3 гигабајти меморија. Но бидејќи има само 10,000 повици, тука можеме да употребиме вектор од вектори (или низа од вектори), каде што во векторот graf[a] ќе ги ставиме сите темиња кои се поврзани со темето a. Во најлош случај користиме 78 килобајти меморија, што е огромна разлика (и како додатна бенефиција - побрзо ќе работи DFS-то! ).

Сега кога веќе знаеме кои се групите, треба само да го добиеме резултатот. Доколку имаме две групи, тогаш знаеме дека бројот на различни комбинации на претставници е производот на бројот на членови во двете групи. Така за горниот пример имаме 2*3 = 6 комбинации, кои се :
<ul>
	<li>A и C</li>
	<li>A и D</li>
	<li>А и E</li>
	<li>B и C</li>
	<li>B и D</li>
	<li>B и E</li>
</ul>
Но што се случува кога имаме повеќе од две групи? Тогаш повеќе групи се спојуваат на различни начини за да добиеме 2 групи како резултат. На пример со 4 групи на граѓани, ги имаме следниве комбинации:
<ul>
	<li>1 / 2+3+4</li>
	<li>1+2 / 3+4</li>
	<li>1+2+3 / 4</li>
	<li>1+3 / 2+4</li>
	<li>1+3+4 / 2</li>
	<li>1+4 / 2+3</li>
	<li>1+2+4 / 3</li>
</ul>
Доколку ги проверуваме сите овие комбинации, ова може да трае повеќе време (бидејќи можеме да имаме 100,000 различни групи). Дури и кога би се правело ова побрзо, на овој начин би добиле многу дупликат кандидати, така да мора да се најде пооптимален начин. Клучната забелешка тука е дека доколку две темиња A и B не се во иста група, тогаш тие може да се изберат како претставници за обединетите нации најмалку еднаш (и како такви, треба да ги броиме). Можеме да го искористиме овој факт и гледајќи поопширно, така што за дадена група X, сите членови од X можат да бидат претставници заедно со било кој граѓанин што не е член на X. Според ова својство, на нас ни е само потребно да ги изминеме сите групи и да го забележиме бројот grupa[i] * (brojNaGragjani - grupa[i]). Збирот на овие броеви ќе ни го даде бројот на различни начини за бирање на два кандидата од различна група. Но бидејќи секој избор на кандидати ќе се претставува два пати (еднаш како A и B, еднаш како B и A), резултатот го делиме со 2.

[code language="cpp"]

#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;cstring&gt;

using namespace std;

vector&lt;vector&lt;int&gt; &gt; graf(100001);
bool poseteno[100001];
int goleminaNaGrupa;

void dfs(int n)
{
    poseteno[n]=true;
    goleminaNaGrupa++;
    for(int i=0;i&lt;graf[n].size();i++)
        if(!poseteno[graf[n][i]])
            dfs(graf[n][i]);
}

int main()
{
    int n,i,a,b;
    cin&gt;&gt;n&gt;&gt;i;

    memset(poseteno,false,100001);

    for(;i;i--)
    {
        cin&gt;&gt;a&gt;&gt;b;
        graf[a].push_back(b);
        graf[b].push_back(a);
    }

    long long rezultat=0;

    for(int i=0;i&lt;n;i++)
    {
        if(!poseteno[i])
        {
            goleminaNaGrupa=0;
            dfs(i);
            rezultat+=goleminaNaGrupa*(n-goleminaNaGrupa);
        }
    }

    rezultat/=2;
    cout&lt;&lt;rezultat;

    return 0;
}

[/code]
]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>112</wp:post_id>
  <wp:post_date>2015-04-10 22:09:55</wp:post_date>
  <wp:post_date_gmt>2015-04-10 21:09:55</wp:post_date_gmt>
  <wp:post_modified>2015-04-10 22:08:21</wp:post_modified>
  <wp:post_modified_gmt>2015-04-10 21:08:21</wp:post_modified_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>%d0%bc%d0%b5%d0%bd%d0%b4%d0%be-%d0%be%d0%b1%d0%b5%d0%b4%d0%b8%d0%bd%d0%b5%d1%82%d0%b8-%d0%bd%d0%b0%d1%86%d0%b8%d0%b8</wp:post_name>
  <wp:status>publish</wp:status>
  <wp:post_parent>0</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>post</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <category domain="post_tag" nicename="dfs"><![CDATA[DFS]]></category>
  <category domain="category" nicename="%d0%bc%d0%b5%d0%bd%d0%b4%d0%be"><![CDATA[мендо]]></category>
  <wp:postmeta>
    <wp:meta_key>_rest_api_published</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_rest_api_client_id</wp:meta_key>
    <wp:meta_value><![CDATA[-1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_publicize_pending</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
</item>
<item>
  <title>Screenshot_11</title>
  <link>https://aandevski.wordpress.com/2015/04/10/%d0%bc%d0%b5%d0%bd%d0%b4%d0%be-%d0%be%d0%b1%d0%b5%d0%b4%d0%b8%d0%bd%d0%b5%d1%82%d0%b8-%d0%bd%d0%b0%d1%86%d0%b8%d0%b8/screenshot_11/</link>
  <pubDate>Fri, 10 Apr 2015 20:36:56 +0000</pubDate>
  <dc:creator>add1ctus</dc:creator>
  <guid isPermaLink="false">http://aandevski.files.wordpress.com/2015/04/screenshot_11.png</guid>
  <description/>
  <content:encoded><![CDATA[]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>113</wp:post_id>
  <wp:post_date>2015-04-10 21:36:56</wp:post_date>
  <wp:post_date_gmt>2015-04-10 20:36:56</wp:post_date_gmt>
  <wp:post_modified>2015-04-10 21:36:56</wp:post_modified>
  <wp:post_modified_gmt>2015-04-10 20:36:56</wp:post_modified_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>screenshot_11</wp:post_name>
  <wp:status>inherit</wp:status>
  <wp:post_parent>112</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>attachment</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <wp:attachment_url>https://aandevski.files.wordpress.com/2015/04/screenshot_11.png</wp:attachment_url>
</item>
<item>
  <title>Screenshot_12</title>
  <link>https://aandevski.wordpress.com/2015/04/10/%d0%bc%d0%b5%d0%bd%d0%b4%d0%be-%d0%be%d0%b1%d0%b5%d0%b4%d0%b8%d0%bd%d0%b5%d1%82%d0%b8-%d0%bd%d0%b0%d1%86%d0%b8%d0%b8/screenshot_12/</link>
  <pubDate>Fri, 10 Apr 2015 20:39:12 +0000</pubDate>
  <dc:creator>add1ctus</dc:creator>
  <guid isPermaLink="false">http://aandevski.files.wordpress.com/2015/04/screenshot_12.png</guid>
  <description/>
  <content:encoded><![CDATA[]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>114</wp:post_id>
  <wp:post_date>2015-04-10 21:39:12</wp:post_date>
  <wp:post_date_gmt>2015-04-10 20:39:12</wp:post_date_gmt>
  <wp:post_modified>2015-04-10 21:39:12</wp:post_modified>
  <wp:post_modified_gmt>2015-04-10 20:39:12</wp:post_modified_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>screenshot_12</wp:post_name>
  <wp:status>inherit</wp:status>
  <wp:post_parent>112</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>attachment</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <wp:attachment_url>https://aandevski.files.wordpress.com/2015/04/screenshot_12.png</wp:attachment_url>
</item>
<item>
  <title>Codeforces Round #298</title>
  <link>https://aandevski.wordpress.com/2015/04/13/codeforces-round-298/</link>
  <pubDate>Mon, 13 Apr 2015 02:29:13 +0000</pubDate>
  <dc:creator>add1ctus</dc:creator>
  <guid isPermaLink="false">https://aandevski.wordpress.com/?p=117</guid>
  <description/>
  <content:encoded><![CDATA[По колоквиумската пауза повторно почнувам со учество на Topcoder и Codeforces натпревари, и првиот на листа е Codeforces #298. Успеав да решам 3 задачи (и четвртата откако заврши натпреварот) со што го обезбедив 118-тото место од 2300+ учесника, што ме врати повторно во првата дивизија! Невообичаено за Codeforces, првите 3 задачи имаа ad hoc решенија и беа доста лесни. Ова се моите решенија: <!--more-->
<h1>A - Exam</h1>
<a href="http://codeforces.com/problemset/problem/534/A">Линк до задачата</a>

За даден број N, од вас се бараше да направите што поголема пермутација од броевите од 1 до N, така што сите соседни броеви не се еден до друг во пермутацијата. Можеме да го искористиме фактот дека доколку два броја имаат иста парност (двата се непарни или пак двата се парни), тогаш тие сигурно не се соседни. Така да ги печатиме прво ситеепарни броеви од 1 до N, па потоа сите непарни од 2 до N.

Простор за грешка има кога N=2 или 3. Во случај кога N = 2, не можеме да направиме пермутација од 2 броја (бидејќи 1 и 2 се соседни). Во случај кога N = 3, не можеме да направиме пермутација од 3 броја (било која пермутација ќе има два соседни броја еден до друг). За да се среди ова, само додаваме 2 if-а за n==2 и n==3.

[code language="cpp"]
#include &lt;iostream&gt;

using namespace std;

int main()
{
    int n;
    cin&gt;&gt;n;

    if(n==2)
        cout&lt;&lt;1&lt;&lt;endl&lt;&lt;1;
    else if(n==3)
        cout&lt;&lt;2&lt;&lt;endl&lt;&lt;&quot;1 3&quot;;
    else
    {
        cout&lt;&lt;n&lt;&lt;endl;
        for(int i=2;i&lt;=n;i+=2)
            cout&lt;&lt;i&lt;&lt;&quot; &quot;;
        for(int i=1;i&lt;=n;i+=2)
            cout&lt;&lt;i&lt;&lt;&quot; &quot;;
    }

    return 0;
}
[/code]

<h1>B - Covered Path</h1>
<a href="http://codeforces.com/problemset/problem/534/B">Линк до задачата</a>

За некое возење на автомобил вие имате дадено три вредности:
<ul>
	<li>v1 - брзината на почетокот на возење во m/s</li>
	<li>v2 - брзината на крајот на возење во m/s</li>
	<li>t - време на возење во секунди</li>
</ul>
Доколку знаете дека автомобилот може да се забрза највеќе d m/s во една секунда, која е најголемата должина што тој автомобил би можело да ја измине?

За да изминеме што поголема должина, потребно е да ја максимизираме брзината секогаш. Идеално, брзината би ја зголемувале за d секогаш. Но бидејќи мора да го завршиме возењето со брзина v2, не можеме да ја зголемуваме брзината засекогаш, ќе треба во текот на возењето да ја намалуваме доколку треба. Па, како знаеме кога да треба да се намали брзината?

[caption id="attachment_118" align="alignleft" width="208"]<a href="https://aandevski.files.wordpress.com/2015/04/screenshot_15.png"><img class="wp-image-118 size-medium" src="https://aandevski.files.wordpress.com/2015/04/screenshot_15.png?w=208" alt="Тест пример со t=4, v1=5, v2=6, d=2" width="208" height="300" /></a> Тест пример со t=4, v1=5, v2=6, d=2[/caption]

Да замислиме дека имаме две посебни возења: едно кое почнува со брзина v1 и се зголемува до брзина X, и второ кое започнува со брзина X и завршува со брзина v2. Тие две возења можеме да ги претставиме како отсечки.

Местото каде што се сечат тие две отсечки е местото каде што треба да почнеме да ја намалуваме брзината.

Како ова најлесно може да се изведе во код? Чуваме две посебни низи за двете возења, каде што бележиме која е брзината на тоа возење во секоја секунда. Резултатот го добиваме така што за секоја секунда ја земаме помалата вредност од двете низи. Ја печатиме сумата на овие вредности.

[code language="cpp"]
#include &lt;iostream&gt;

using namespace std;

int main()
{
    int v1,v2,t,d;
    cin&gt;&gt;v1&gt;&gt;v2&gt;&gt;t&gt;&gt;d;

    int sum=0;

    int fromstart[t],fromend[t];

    fromstart[0]=v1;
    fromend[t-1]=v2;

    for(int i=1;i&lt;t;i++)
        fromstart[i]=fromstart[i-1]+d;

    for(int i=t-2;i&gt;=0;i--)
        fromend[i]=fromend[i+1]+d;

    for(int i=0;i&lt;t;i++)
    {
        if(fromstart[i]&lt;fromend[i])
            sum+=fromstart[i];
        else
            sum+=fromend[i];
    }

    cout&lt;&lt;sum;

    return 0;
}
[/code]

<h1>C - Polycarpus' Dice</h1>
Имате дадено N коцки за фрлање (со X страни, и броевите од 1 до X на секоја страна). Коцките може да имаат различен број на страни (за пример, може да имате една коцка со 6 страни и 2 коцки со 3 страни). За некое фрлање, вие знаете кои коцки се користени и колку е збирот од фрлањето. Бидејќи не можете со сигурност да одредите кои коцки се паднале (на пример доколку збирот е 6 а вие имате 2 коцки со 6 страни, фрлањето би можело да биде 1+5, 2+4 или 3+3), од вас се бара да одредите за секоја коцка кои броеви не се паднале (во претходниот пример, за ни една коцка не може да се падне бројот 6).

Да разгледаме внимателно, кога поточно не може да се падне некој број за некоја коцка? Има два случаи:
<ul>
	<li>Кога го надминувате збирот. На пример доколку збирот е 4, а вие имате 3 коцки, тогаш максимумот што може да ви се падне на секоја коцка е 2 (бидејќи другите две коцки би имале 1, и 2+1+1=4). Најголемиот број што може да ви се падне со некоја коцка е <strong>S-N+1</strong> (бидејќи било кој друг би го надминал збирот)</li>
	<li>Кога не го достигате збирот. На пример, имате збир 8 и 3 коцки со 3 страни. Не можете збирот да го добиете доколку ви се падне 1 на некоја коцка (бидејќи 1+3+3&lt;8). Најмалиот број што може да ви се падне со некоја коцка е <strong>S - (сума на сите коцки - број на страни на коцка)</strong>. Било кој друг број (помал од тој) и нема да добиете збир S.</li>
</ul>
Кога веќе знаеме за сите коцки која е најмалата и најголемата вредност, преостанува да видиме кои вредности од коцката не ги користиме. Доколку имате коцка со 6 страни, каде што најмалата довзолена вредност е 2 а најголемата 4, тогаш страните 1, 5 и 6 не ги користите = вкупно 3 страни. Тоа се добива со : <strong>број на страни - најголема вредност + најмала вредност - 1</strong>

[code language="cpp"]
#include &lt;iostream&gt;

using namespace std;

int main()
{
    long long n,A;
    cin&gt;&gt;n&gt;&gt;A;

    long long sum=0;

    long long arr[n];
    for(int i=0;i&lt;n;i++)
    {
        cin&gt;&gt;arr[i];
        sum+=arr[i];
    }


    for(int i=0;i&lt;n;i++)
    {
        int lowest=max(1LL,A-(sum-arr[i]));
        int highest=min(arr[i],A-(n-1));
        cout&lt;&lt;arr[i]-highest+lowest-1&lt;&lt;&quot; &quot;;
    }

    return 0;
}
[/code]

<h1>D - Handshakes</h1>
<a href="http://codeforces.com/problemset/problem/534/D">Линк до задачата</a>

Интересна задача која успеав многу да ја искомплицирам за време на натпреварот и не видов просто DFS решение. Имате дадено N студенти кои влегувале во соба еден по еден. Секогаш кога некој ќе влезе, тој се поздравува со сите слободни студенти. Кога студентите се внатре, тие можат да направат тим од тројца и да решаваат задачи. Кога студенти решаваат задачи, тогаш новите студенти што влегуваат не се поздравуваат со нив.

Имате дадено низа што означува кој студент колку пати се поздравил при влегување. Од вас се бара да го испечатите редоследот на влегување на студентите (доколку постои таков). Првиот студент што влегува не се поздравува со никого, потоа вториот се поздравува со еден студент, па третиот со два студента, итн. Доколку тие направат тим, тогаш може да влезе некој што се поздравува со 0 студенти. Доколку не направат тим, тогаш може да влезе некој што се поздравува со 3 студенти. Ја сфаќате идејата.

Ова можеме да го претставиме како граф, на тој начин што секогаш кога ќе влезе некој студент со X поздравувања, после него треба да влезе некој студент со X+1 поздравувања. Се додека има студенти кои го задоволуваат ова барање, студентите влегуваат и бележиме кој кога влегува. Кога веќе нема студент со X+1 поздравувања, тогаш проверуваме дали има студент со (X+1)-3 поздравувања (што би значело дека студентите внатре направиле еден тим. Доколку повторно нема, тогаш пак одземаме 3 студенти, се додека не најдеме некој студент, или пак додека не стигнеме до негативен број (кога ќе знаеме дека не постои решение).

За да не пребаруваме цело време низ низата од студенти, користиме вектор од вектори, така што во vec[i] ги имаме сите студенти кои се поздравиле i - пати.

За пуштено dfs од x поздравувања, доколку постои студент во векторот vec[x], го вадиме од векторот, го запишуваме во резултатот и повикуваме dfs за x+1. Доколку не постои, тогаш повикуваме dfs за x-3 (освен ако x-3 е негативен број). Кодот сам ќе си заврши или кога ќе ги внесе сите студенти, или кога ќе стигне до негативен број и ќе се врати назад. Како знаеме кога е најден резултатот, а кога не? Векторот со резутлат треба да има вкупно N членови внатре. Доколку има помалку, тогаш не сме ги ставиле сите студенти - не постои резултат.

[code language="cpp"]
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

vector&lt;int&gt; output;
vector&lt;vector&lt;int&gt; &gt; graph(200001);

void dfs(int shakes)
{
    if(graph[shakes].empty())
    {
        if(shakes-3&lt;0)
            return;
        dfs(shakes-3);
    }
    else
    {
        output.push_back(graph[shakes].back());
        graph[shakes].pop_back();
        dfs(shakes+1);
    }
}

int main()
{
    int n;
    cin&gt;&gt;n;

    for(int i=1;i&lt;=n;i++)
    {
        int temp;
        cin&gt;&gt;temp;
        graph[temp].push_back(i);
    }

    dfs(0);

    if(output.size()==n)
    {
        cout&lt;&lt;&quot;Possible&quot;&lt;&lt;endl;
        for(int i=0;i&lt;n;i++)
            cout&lt;&lt;output[i]&lt;&lt;&quot; &quot;;
    }
    else
        cout&lt;&lt;&quot;Impossible&quot;;

    return 0;
}
[/code]]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>117</wp:post_id>
  <wp:post_date>2015-04-13 03:29:13</wp:post_date>
  <wp:post_date_gmt>2015-04-13 02:29:13</wp:post_date_gmt>
  <wp:post_modified>2015-04-13 03:27:37</wp:post_modified>
  <wp:post_modified_gmt>2015-04-13 02:27:37</wp:post_modified_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>codeforces-round-298</wp:post_name>
  <wp:status>publish</wp:status>
  <wp:post_parent>0</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>post</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <category domain="post_tag" nicename="ad-hoc"><![CDATA[Ad hoc]]></category>
  <category domain="category" nicename="codeforces"><![CDATA[codeforces]]></category>
  <category domain="post_tag" nicename="dfs"><![CDATA[DFS]]></category>
  <wp:postmeta>
    <wp:meta_key>_rest_api_published</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_rest_api_client_id</wp:meta_key>
    <wp:meta_value><![CDATA[-1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_publicize_pending</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
</item>
<item>
  <title>Screenshot_15</title>
  <link>https://aandevski.wordpress.com/2015/04/13/codeforces-round-298/screenshot_15/</link>
  <pubDate>Mon, 13 Apr 2015 01:49:20 +0000</pubDate>
  <dc:creator>add1ctus</dc:creator>
  <guid isPermaLink="false">http://aandevski.files.wordpress.com/2015/04/screenshot_15.png</guid>
  <description/>
  <content:encoded><![CDATA[]]></content:encoded>
  <excerpt:encoded><![CDATA[Тест пример со t=4, v1=5, v2=6, d=2]]></excerpt:encoded>
  <wp:post_id>118</wp:post_id>
  <wp:post_date>2015-04-13 02:49:20</wp:post_date>
  <wp:post_date_gmt>2015-04-13 01:49:20</wp:post_date_gmt>
  <wp:post_modified>2015-04-13 02:49:34</wp:post_modified>
  <wp:post_modified_gmt>2015-04-13 01:49:34</wp:post_modified_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>screenshot_15</wp:post_name>
  <wp:status>inherit</wp:status>
  <wp:post_parent>117</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>attachment</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <wp:attachment_url>https://aandevski.files.wordpress.com/2015/04/screenshot_15.png</wp:attachment_url>
</item>
<item>
  <title>CodeFu 2015: Round 1</title>
  <link>https://aandevski.wordpress.com/2015/04/21/codefu-2015-round-1/</link>
  <pubDate>Tue, 21 Apr 2015 20:28:35 +0000</pubDate>
  <dc:creator>add1ctus</dc:creator>
  <guid isPermaLink="false">https://aandevski.wordpress.com/?p=123</guid>
  <description/>
  <content:encoded><![CDATA[Изминатиот викенд се одржа првата рунда од квалификациите за годишниот CodeFu натпревар. Доста интересен натпревар со не многу тешки задачи, кој имаше 90 учесника (повеќето студенти, но исто така и по некој средношколец). Но и покрај тежината на задачите, успеав едвај да извадам 450 од 1500 поени за 25-тото место заради багови во две задачи (кои ме чинеа 550 поени и 20 места во пласманот). Ова е лекција за да ги тестирам повеќе задачите пред да праќам финални решенија следен пат. <!--more-->
<h1>100 - TableTennisScore</h1>
<a href="http://codefu.mk/codefu2015-round1.html?subpage=problem&amp;problemid=2165">Линк до задачата</a>

Традиционално, првата задача се базира само на имплементација. Потребно е да се парсира стринг кој содржи резултати од пинг-понг, така да го испечатиме победникот и резултатот во партии. Потребни ни се две функции, една за претворање на int во string и уште една што го прави обратното:

[code language="cpp"]
    int getnumber(string score)
    {
        int result=0;
        for(int i=0;i&lt;score.size();i++)
        {
            result*=10;
            result+=score[i]-'0';
        }
    return result;
    }
[/code]


[code language="cpp"]
    string getstring(int number)
    {
        string result;
        while(number&gt;0)
        {
            result+=(number%10)+'0';
            number/=10;
        }
        reverse(result.begin(),result.end());
        if(result==&quot;&quot;)
            return &quot;0&quot;;
        return result;
    }
[/code]

Се што преостанува е да ги употребиме овие функции за парсирање на стрингот. Тоа го правиме така што го изминуваме стрингот буква по буква и секоја буква ја ставаме во друг привремен стринг, се додека не сретнеме празно место. Кога сретнеме празно место или две точки тогаш ги обработуваме податоците што се внатре во привремениот стринг па потоа го празниме истиот стринг. Првин го правиме тоа за имињата, кои ги зачувуваме во два посебни стринга, па потоа до крај на стрингот ги парсираме резултатите. Но бидејќи резултатот го пресметуваме кога сретнеме празно место, додаваме на крајот на стрингот уште едно празно место за да се пресмета последниот меч.

[code language="cpp"]
string whoWon(string score)
    {
        score+=' ';
        
        int parser=0;
        string parsed=&quot;&quot;;
        string names[2];
        int scores[2]={0};
        
        while(score[parser]!=' ')
            names[0]+=score[parser++];
            
        parser++;
        
        while(score[parser]!=' ')
            names[1]+=score[parser++];
            
        parser++;
        
        for(;parser&lt;score.size();parser++)
        {
            int sc[2];
            if(score[parser]==':')
            {
                sc[0]=getnumber(parsed);
                parsed=&quot;&quot;;
            }
            else if(score[parser]==' ')
            {
                sc[1]=getnumber(parsed);
                if(sc[0]&gt;sc[1])
                    scores[0]++;
                else if(sc[1]&gt;sc[0])
                    scores[1]++;
                parsed=&quot;&quot;;
            }
            else
                parsed+=score[parser];
        }
        
        string result;
        
        if(scores[0]&gt;scores[1])
            result=names[0]+' '+getstring(scores[0])+':'+getstring(scores[1]);
        else
            result=names[1]+' '+getstring(scores[1])+':'+getstring(scores[0]);
            
        return result;
  }
[/code]

<h1>200 - TheSubsequences</h1>
<a href="http://codefu.mk/codefu2015-round1.html?subpage=problem&amp;problemid=2166">Линк до задачата</a>

Доколку досега не знаевте, временскиот лимит на CodeFu е 5 секунди, што дава многу повеќе простор за brute force решенија. Токму тој факт, заедно со фактот дека треба да се изминат највеќе милион броеви ќе ги искористиме за решението на оваа задача. Потребна ни е функција која за два броја ќе проверува дали првиот е субсеквенца на вториот. При ова повикување, првиот број е секогаш поголемиот (измеѓу А и B), а вториот е помал (C). Тоа го правиме така што првиот број го делиме со 10 (ја отфрламе цифрата од десно) се додека последната цифра на првиот број е различна од последната цифра на вториот број. Кога последните цифри се исти, тогаш ги делиме и двата броја со 10. Ова се прави се додека еден од броевите не стигне до 0. Доколку првиот број стигне до 0, тогаш бројот не е субсеквенца. Доколку вториот број е 0, тогаш се работи за субсеквенца.

[code language="cpp"]
    bool check(int A, int C)
    {
        while(A&gt;0 &amp;&amp; C&gt;0)
        {
            if(A%10==C%10)
                C/=10;
            A/=10;
        }
        return (C==0)?true:false;
    }
[/code]

Се што преостанува е да ги изминеме сите броеви од A до B и да провериме за колку броеви функцијата ќе врати true.

[code language="cpp"]
int count(int A, int B, int C)
    {
        int result=0;
        for(;A&lt;=B;A++)
            if(check(A,C))
                result++;
        return result;
    }
[/code]

<h1>300 - CandyCrush</h1>
<a href="http://codefu.mk/codefu2015-round1.html?subpage=problem&amp;problemid=2167">Линк до задачата</a>

Замислете ја низата како граф, каде што секое теме е поврзано со двете соседни темиња. Со BFS можеме да ја откриеме далечината до сите други темиња. Со dist[x] го означуваме времето потребно да се стигне до некое теме x од почетокот, а во times[x] го имаме времето кога тоа поле се руши. Тогаш некое поле можеме да посетиме (и да посетуваме други негови соседни полиња преку него) само доколку times[x]&gt;=dist[x]. Во спротивно, тоа поле би било срушено и не може да се поминува низ него. Кога завршиме со посетување на сите можни полиња (притоа не посетуваме ниту едно поле два пати - користиме низа boolean), тогаш проверуваме кое е полето со најголемо times[x] кое е посетено, и го печатиме тој број.

[code language="cpp"]
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;cstring&gt;
using namespace std;

class CandyCrush
{
  public:
    int howLong(vector&lt;int&gt; times, int position)
    {
        queue&lt;int&gt; Q;
        int dist[times.size()];
        bool visited[times.size()];
        memset(visited,false,times.size());

        Q.push(position);
        visited[position]=true;
        dist[position]=1;

        int reachedmaximum=times[position];

        while(!Q.empty())
        {
            int current=Q.front();
            if(times[current]&gt;reachedmaximum)
                reachedmaximum=times[current];
            Q.pop();
            if(current-1&gt;=0 &amp;&amp; !visited[current-1] &amp;&amp; dist[current]+1&lt;=times[current-1])
            {
                Q.push(current-1);
                dist[current-1]=dist[current]+1;
                visited[current-1]=true;
            }
            if(current+1&lt;times.size() &amp;&amp; !visited[current+1] &amp;&amp; dist[current]+1&lt;=times[current+1])
            {
                Q.push(current+1);
                dist[current+1]=dist[current]+1;
                visited[current+1]=true;
            }
        }

        return reachedmaximum;
  }
};

[/code]

<h1>400 - EternalDiamonds</h1>
<a href="http://codefu.mk/codefu2015-round1.html?subpage=problem&amp;problemid=2168">Линк до задачата</a>

Интересна и предизвикувачка задача, која успеа да ми помине на сите 10 претест примери, но ми падна на сите останати 90 заради глупа грешка. Решението е top-down динамичко. Чуваме две матрици:
<ul>
	<li>int pole[202][202], каде што pole[x][y] ќе е 1 доколку има дијамант на тоа поле, 0 доколку нема, а -1 доколку има ѕид.</li>
	<li>int DP[202][202], каде што DP[x][y] го означува колку највеќе дијаманти може да се собере доколку го изберете оптималниот пат од точката (0,0) до точката (x,y). Доколку не постои пат помеѓу (0,0) и (x,y), тогаш DP[x][y] е -1</li>
</ul>
Матрицата DP ја иницираме со вредности -2. Зошто? Можеме да го искористиме ова, така што доколку DP[x][y] е различно од -2, тогаш знаеме дека сме го пресметале најдобриот пат за тоа поле и може да се искористи резултатот. Но доколку е -2, тогаш ова поле не било посетено и го наоѓаме најдобриот пат за тоа поле.

[caption id="attachment_127" align="alignleft" width="183"]<a href="https://aandevski.files.wordpress.com/2015/04/screenshot_5.png"><img class="size-full wp-image-127" src="https://aandevski.files.wordpress.com/2015/04/screenshot_5.png" alt="Пример за мапа со големина 5" width="183" height="144" /></a> Пример за мапа со големина 5[/caption]

Бидејќи се работи за top-down динамичко, тогаш решаваме од десно кон лево. Да ја разгледаме мапата со големина 5, која има 8 колони (што се добива со size*2-2) .Решението е во DP[8][0]. До точката (8,0) може да се стигне од две други точки (ова важи за сите точки), (7,0) и (7,1). Проверуваме која од овие две точки има поголема вредност во DP матрицата, ја земаме поголемата вредност и додаваме pole[8][0]. Доколку и двете точки DP[7][0] и DP[7][1] се еднакви на -1, тогаш не постои пат од (0,0) до (8,0) (заради ѕидови). Истото се случува и рекурзивно: за точката (7,0) ги проверуваме точките (6,0) и (6,1), а за точката (7,1) ги проверуваме точките (6,1) и (6,2). При тоа, (6,1) само еднаш ќе го провериме, а за вториот пат ќе го имаме резултатот во DP[6][1], и со тоа ќе спречиме вишок проверки.

[caption id="attachment_129" align="alignright" width="189"]<a href="https://aandevski.files.wordpress.com/2015/04/screenshot_6.png"><img class="wp-image-129 size-full" src="https://aandevski.files.wordpress.com/2015/04/screenshot_6.png" alt="Screenshot_6" width="189" height="142" /></a> Пример за поделба на мапа со големина 5[/caption]

Мапата ја делиме на две половини, прикажано како на сликата. Едната половина е од колона 0 па до колона size-1, додека другата половина е од колона size до колона size*2-2, каде што size е големината на мапата. Зошто го правиме ова? Има две причини:
<ul>
	<li>Да знаеме кон кои полиња треба да се движиме. Во левата половина, од точка (x,y) се движиме кон (x-1,y) и (x-1,y+1), додека во десната половина се движиме кон (x-1,y) и (x-1,y-1)</li>
	<li>Да знаеме колку полиња има во таа колона. Во левата половина, секоја колона X има X полиња, додека во десната половина, секоја колона има 2*size-X-1 полиња. Ова го користиме така да не искочиме надвор од границите (пример, во мапа со големина 5 не постои поле 5,4, додека во мапа со големина 7 постои).</li>
</ul>
Правиме функција solve, која доколку DP[x][y]==-2, ќе ја пресмета вредноста на DP[x][y]. Во функцијата прво правиме две променливи:
<ul>
	<li>int best, чија почетна вредност е -1. Во best го ставаме поголемиот број од двете точки од лево од точката (x,y) (на пример, доколку повикаме solve(4,1), тогаш best ќе е поголемиот број од DP[3][0] и DP[3][1].</li>
	<li>int verticalsize, кој ќе означува колку полиња има во колоната x-1 (за да знаеме да не излеземе надвор од границите. Оваа променлива добива вредност така што проверуваме во која половина се наоѓа колоната x-1, и ја добиваме вредноста со помош на горе наведените формули.</li>
</ul>
Се што преостанува е сега да ги провериме полињата од лево и да го вратиме поголемиот број како резултат. Едно од полињата лево ќе е секогаш (x-1,y), освен кога тоа не постои (објаснето погоре). Проверуваме дали y е помало или еднакво на verticalsize, и доколку е, тогаш проверуваме дали има ѕид на тоа поле (дали pole[x-1][y]==-1). Доколку полето постои и нема ѕид, тогаш доколку DP[x-1][y]==-2, повикуваме solve(x-1,y), а во спротивно го земаме резултатот од DP[x-1][y].

Со ова ја имаме проверено едната насока на движење, останува другата. За таа, прво треба да провериме во која половина се наоѓаме (доколку сме во левата, се движиме кон (x-1,y+1), во спротивно, кон (x-1,y-1). Кога веќе знаеме кон кое поле треба да се движиме, ги правиме истите проверки напишани во претходниот параграф, и доколку добиениот резултат е поголем од best, тогаш го ставаме резултатот во best.

Се што преостанува е да се врати резултатот кој е best (најдоброт пат до (x,y)) + pole[x][y]. При тоа, доколку best==-1, значи дека не постои пат од (0,0) до (x,y), во кој случај враќаме -1. Резулатот исто така го запишуваме во DP[x][y].

[code language="cpp"]
int solve(int x, int y)
    {
        int best=-1;
        int verticalsize;
        
        if(x-1&lt;sz)
            verticalsize=x-1;
        else
            verticalsize=sz*2-x-1;
        
        if(y&lt;=verticalsize &amp;&amp; dp[x-1][y]==-2 &amp;&amp; pole[x-1][y]!=-1)
            best=solve(x-1,y);
        else if(y&lt;=verticalsize &amp;&amp; pole[x-1][y]!=-1)
            best=dp[x-1][y];
            
        if(x&gt;=sz)
        {
            if(y+1&lt;=verticalsize &amp;&amp; dp[x-1][y+1]==-2 &amp;&amp; pole[x-1][y+1]!=-1)
                best=max(best,solve(x-1,y+1));
            else if(y&lt;=verticalsize &amp;&amp; pole[x-1][y+1]!=-1)
                best=max(best,dp[x-1][y+1]);
        }
        else
        {
            if(y-1&gt;=0 &amp;&amp; dp[x-1][y-1]==-2 &amp;&amp; pole[x-1][y-1]!=-1)
                best=max(best,solve(x-1,y-1));
            else if(y-1&gt;=0 &amp;&amp; pole[x-1][y-1]!=-1)
                best=max(best,dp[x-1][y-1]);
        }
        
        if(best==-1)
            dp[x][y]=-1;
        else
            dp[x][y]=best+pole[x][y];
            
        return dp[x][y];
    }
[/code]

Кога веќе знаеме како се добива решението, се што преостанува е да ги пополниме матриците со почетни вредности и да повикаме solve(size*2-2,0). Матрицата DP има почетни вредности -2, додека матрицата pole има почетни вредности 0. Додатно, DP[0][0]=0 (бидејќи никогаш нема дијамант на почетокот, и не мора да се проверува лево од 0,0). Потребно е само во pole да се стави 1 каде има дијамант во мапата и -1 каде што има ѕид. Тоа го правиме на сличен начин како и со првата задача - парсираме стрингови. При тоа, ја користиме истата getnumber функција од првата задача.

[code language="cpp"]
int getMaxScore(int size, vector&lt;string&gt; diamonds, vector&lt;string&gt; walls)
    {
        sz=size;
        for(int i=0;i&lt;202;i++)
            for(int j=0;j&lt;202;j++)
                dp[i][j]=-2;
        memset(pole,0,202*202);
        dp[0][0]=0;
        for(int i=0;i&lt;diamonds.size();i++)
        {
            int parser=0;
            string parsed=&quot;&quot;;
            while(diamonds[i][parser]!=';')
                parsed+=diamonds[i][parser++];
            int x=getnumber(parsed);
            parser++;
            parsed=&quot;&quot;;
            while(parser&lt;diamonds[i].size())
                parsed+=diamonds[i][parser++];
            int y=getnumber(parsed);
            pole[x][y]=1;
        }
        for(int i=0;i&lt;walls.size();i++)
        {
            int parser=0;
            string parsed=&quot;&quot;;
            while(walls[i][parser]!=';')
                parsed+=walls[i][parser++];
            int x=getnumber(parsed);
            parsed=&quot;&quot;;
            parser++;
            while(walls[i][parser]!=';')
                parsed+=walls[i][parser++];
            int y1=getnumber(parsed);
            parsed=&quot;&quot;;
            parser++;
            while(parser&lt;walls[i].size())
                parsed+=walls[i][parser++];
            int y2=getnumber(parsed);
            for(;y1&lt;=y2;y1++)
            {
                pole[x][y1]=-1;
            }
        }
        return solve(size*2-2,0);
  }
[/code]
]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>123</wp:post_id>
  <wp:post_date>2015-04-21 21:28:35</wp:post_date>
  <wp:post_date_gmt>2015-04-21 20:28:35</wp:post_date_gmt>
  <wp:post_modified>2015-04-21 21:26:52</wp:post_modified>
  <wp:post_modified_gmt>2015-04-21 20:26:52</wp:post_modified_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>codefu-2015-round-1</wp:post_name>
  <wp:status>publish</wp:status>
  <wp:post_parent>0</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>post</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <category domain="post_tag" nicename="ad-hoc"><![CDATA[Ad hoc]]></category>
  <category domain="post_tag" nicename="bfs"><![CDATA[BFS]]></category>
  <category domain="post_tag" nicename="brute-force"><![CDATA[Brute force]]></category>
  <category domain="category" nicename="codefu"><![CDATA[CodeFu]]></category>
  <category domain="post_tag" nicename="%d0%b4%d0%b8%d0%bd%d0%b0%d0%bc%d0%b8%d1%87%d0%ba%d0%be-%d0%bf%d1%80%d0%be%d0%b3%d1%80%d0%b0%d0%bc%d0%b8%d1%80%d0%b0%d1%9a%d0%b5"><![CDATA[Динамичко програмирање]]></category>
  <category domain="post_tag" nicename="%d1%80%d0%b5%d0%ba%d1%83%d1%80%d0%b7%d0%b8%d1%98%d0%b0"><![CDATA[Рекурзија]]></category>
  <category domain="post_tag" nicename="%d1%81%d1%82%d1%80%d0%b8%d0%bd%d0%b3%d0%be%d0%b2%d0%b8"><![CDATA[Стрингови]]></category>
  <wp:postmeta>
    <wp:meta_key>_rest_api_published</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_rest_api_client_id</wp:meta_key>
    <wp:meta_value><![CDATA[-1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_publicize_pending</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
</item>
<item>
  <title>Screenshot_5</title>
  <link>https://aandevski.wordpress.com/2015/04/21/codefu-2015-round-1/screenshot_5/</link>
  <pubDate>Tue, 21 Apr 2015 19:53:39 +0000</pubDate>
  <dc:creator>add1ctus</dc:creator>
  <guid isPermaLink="false">http://aandevski.files.wordpress.com/2015/04/screenshot_5.png</guid>
  <description/>
  <content:encoded><![CDATA[]]></content:encoded>
  <excerpt:encoded><![CDATA[Пример за мапа со големина 5]]></excerpt:encoded>
  <wp:post_id>127</wp:post_id>
  <wp:post_date>2015-04-21 20:53:39</wp:post_date>
  <wp:post_date_gmt>2015-04-21 19:53:39</wp:post_date_gmt>
  <wp:post_modified>2015-04-21 20:53:48</wp:post_modified>
  <wp:post_modified_gmt>2015-04-21 19:53:48</wp:post_modified_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>screenshot_5</wp:post_name>
  <wp:status>inherit</wp:status>
  <wp:post_parent>123</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>attachment</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <wp:attachment_url>https://aandevski.files.wordpress.com/2015/04/screenshot_5.png</wp:attachment_url>
</item>
<item>
  <title>Screenshot_4</title>
  <link>https://aandevski.wordpress.com/2015/04/21/codefu-2015-round-1/screenshot_4/</link>
  <pubDate>Tue, 21 Apr 2015 19:58:00 +0000</pubDate>
  <dc:creator>add1ctus</dc:creator>
  <guid isPermaLink="false">http://aandevski.files.wordpress.com/2015/04/screenshot_4.png</guid>
  <description/>
  <content:encoded><![CDATA[]]></content:encoded>
  <excerpt:encoded><![CDATA[Поделба на мапа со големина 5]]></excerpt:encoded>
  <wp:post_id>128</wp:post_id>
  <wp:post_date>2015-04-21 20:58:00</wp:post_date>
  <wp:post_date_gmt>2015-04-21 19:58:00</wp:post_date_gmt>
  <wp:post_modified>2015-04-21 20:58:10</wp:post_modified>
  <wp:post_modified_gmt>2015-04-21 19:58:10</wp:post_modified_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>screenshot_4</wp:post_name>
  <wp:status>inherit</wp:status>
  <wp:post_parent>123</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>attachment</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <wp:attachment_url>https://aandevski.files.wordpress.com/2015/04/screenshot_4.png</wp:attachment_url>
</item>
<item>
  <title>Screenshot_6</title>
  <link>https://aandevski.wordpress.com/2015/04/21/codefu-2015-round-1/screenshot_6/</link>
  <pubDate>Tue, 21 Apr 2015 20:02:34 +0000</pubDate>
  <dc:creator>add1ctus</dc:creator>
  <guid isPermaLink="false">http://aandevski.files.wordpress.com/2015/04/screenshot_6.png</guid>
  <description/>
  <content:encoded><![CDATA[]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>129</wp:post_id>
  <wp:post_date>2015-04-21 21:02:34</wp:post_date>
  <wp:post_date_gmt>2015-04-21 20:02:34</wp:post_date_gmt>
  <wp:post_modified>2015-04-21 21:02:34</wp:post_modified>
  <wp:post_modified_gmt>2015-04-21 20:02:34</wp:post_modified_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>screenshot_6</wp:post_name>
  <wp:status>inherit</wp:status>
  <wp:post_parent>123</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>attachment</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <wp:attachment_url>https://aandevski.files.wordpress.com/2015/04/screenshot_6.png</wp:attachment_url>
</item>
<item>
  <title>Codeforces Round #300</title>
  <link>https://aandevski.wordpress.com/2015/04/28/codeforces-round-300/</link>
  <pubDate>Tue, 28 Apr 2015 22:42:13 +0000</pubDate>
  <dc:creator>add1ctus</dc:creator>
  <guid isPermaLink="false">https://aandevski.wordpress.com/?p=133</guid>
  <description/>
  <content:encoded><![CDATA[Уште еден во низата лоши натпревари за мене (се надевам и последен), повторно назад во втора дивизија. Изгубив неколку минути на првата задача бидејќи погрешно ја сфатив, додека во втората задача заради погрешни ограничувања (сум напишал 100000 наместо 1000000) ја решив дури еден саат подоцна од потребно, по 3 погрешни одговори пратено. За да биде уште полошо, третата задача која имаше просто greedy решение се обидував да ја решам со binary search, што ми даваше погрешни резултати за некои примери. Ги средив решенијата на првите три задачи и ги поправив грешките, во продолжение можете да ги најдете решенијата.

<!--more-->
<h1>A - Cutting Banner</h1>
<a href="http://codeforces.com/problemset/problem/538/A">Линк до задачата</a>

Да го искористиме фактот дека стрингот може да е највеќе 100 букви долг, што е доста мал број. Знаеме дека треба да избришеме само еден дел од стрингот. Да го означиме со i почетокот на делот што го бришеме, а со j крајот на делот што го бришеме. Бидејќи i и j можат да бидат помеѓу 0 и 99, во најлош случај имаме 100*100 = 10,000 можни начини да избришеме некој дел од дадениот стринг. Можеме да ги провериме сите и да видиме дали при некое бришење, остатокот е "CODEFORCES".

Доколку го бришеме делот од i до j, тогаш ни останува делот од 0 до i и од j+1 до крај. Тие два дела можеме да ги добиеме со функцијата substr. Кога на substr даваме еден параметар x, тогаш таа ни го враќа стрингот од позиција x до крајот. Кога на substr му дадеме два параметри x и y, тогаш добиваме стринг кој почнува од позиција x и е долг y букви. Така да стрингот без избришаниот дел би го добиле со substr(0,i) + substr(j+1). Проверуваме дали некогаш овој стринг ќе е еднаков на "CODEFORCES", со што ја решаваме задачата.

[code language="cpp"]
#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

int main()
{
    string input;
    cin&gt;&gt;input;
    for(int i=0;i&lt;input.size();i++)
        for(int j=i;j&lt;input.size();j++)
            if(input.substr(0,i)+input.substr(j+1)==&quot;CODEFORCES&quot;)
            {
                cout&lt;&lt;&quot;YES&quot;;
                return 0;
            }
    cout&lt;&lt;&quot;NO&quot;;
    return 0;
}
[/code]

<h1>B - Quasi Binary</h1>
<a href="http://codeforces.com/problemset/problem/538/B">Линк до задачата</a>

Доколку ја имате решено задачата „Палиндроми“ од државниот натпревар во 2014, тогаш сигурно ќе ви е јасна оваа задача, која дури е и малку полесна од таа. Решението е обично knapsack динамичко, при што памтиме кој предмет кога го земаме. Во овој случај, големината на ранецот е бројот n, а предметите што можеме да ги ставаме во ранецот се сите квазибинарни броеви. Се бара пополнување на ранецот со најмал број на предмети.

Правиме низа DP[n+1] каде што DP[x] - колку најмалку квазибинарни броеви се потребни за да се претстави бројот x. Во викито на Мендо како и низ многу други места по интернет можете да најдете добри објаснувања за knapsack динамичко, така да тој дел нема да го објаснувам, туку само ќе го напишам кодот. Додатно, за да меморираме кој квазибинарен број сме го избрале на позиција x, имаме додатна низа taken[n+1]. Во векторот qb ни се ставени сите квазибинарни броеви.

[code language="cpp"]
    for(int i=2;i&lt;=needednumber;i++)
        for(int j=0;j&lt;qb.size() &amp;&amp; i-qb[j]&gt;=0;j++)
            if(DP[i]&gt;DP[i-qb[j]]+1)
            {
                DP[i]=DP[i-qb[j]]+1;
                taken[i]=qb[j];
            }
[/code]

Но како го пополнуваме векторот qb? Сите 2-цифрени квазибинарни броеви можеме да ги добиеме врз основа на едноцифрените, така што на секој едноцифрен број ќе му додадеме 0 и 1 на крајот за да добиеме нов број. Истото важи и за сите други. Од броевите 10 и 11 можете да ги добиете броевите 100,101,110 и 111, што се сите 3-цифрени квазибинарни броеви. Ова се повторува се додека не ги добиеме сите 6 цифрени броеви, на кои сами ќе го додадеме 1000000 (единствениот 7-цифрен број кој ни е потребен). За почеток, во векторот ги имаме броевите 0,1,10,11 во векторот. За да ги добиеме 3-цифрените броеви, вршиме додавање на броевите од позиција 2 до 3 (двата двоцифрени броја). За 4-цифрени броеви, вршиме додавање на броевите од позиција 4 до 7 (сите 3-цифрени броеви). Првиот број секогаш се дуплира, додека вториот секогаш се дуплира и му се додава 1.

[code language="cpp"]
    vector&lt;int&gt; qb;

    qb.push_back(0);
    qb.push_back(1);
    qb.push_back(10);
    qb.push_back(11);

    for(int i=0;i&lt;=1000000;i++)
        DP[i]=9999;

    DP[0]=DP[1]=DP[10]=DP[11]=DP[1000000]=1;
    taken[1]=1;
    taken[10]=10;
    taken[11]=11;
    taken[1000000]=1000000;

    int limitlevo=2,limitdesno=3;

    for(int cifri=2;cifri&lt;6;cifri++)
    {
        for(int i=limitlevo;i&lt;=limitdesno;i++)
        {
            qb.push_back(qb[i]*10);
            DP[qb.back()]=1;
            taken[qb.back()]=qb.back();
            qb.push_back(qb[i]*10+1);
            DP[qb.back()]=1;
            taken[qb.back()]=qb.back();
        }
        limitlevo*=2;
        limitdesno*=2;
        limitdesno++;
    }
    qb.push_back(1000000);
[/code]

Се што преостанува е да го испечатиме резултатот кој се наоѓа во DP[needednumber] и да го реконструираме со помош на низата taken.

[code language="cpp"]
    cout&lt;&lt;DP[needednumber]&lt;&lt;endl;
    while(needednumber!=0)
    {
        cout&lt;&lt;taken[needednumber]&lt;&lt;&quot; &quot;;
        needednumber-=taken[needednumber];
    }
[/code]

<h1>C - Tourist's Notes</h1>
<a href="http://codeforces.com/problemset/problem/538/C">Линк до задачата</a>

Доколку за претходната задача најдовме слична задача од Мендо, овој пат може да се најде слична задача од Codeforces. Два натпревари порано, во <a href="https://aandevski.wordpress.com/2015/04/13/codeforces-round-298/">Codeforces Round #298</a>, втората задача со иста идеја како оваа, со тоа што оваа е малку покомплицирана.

Бидејќи се работи за ограничувања до 10^8, мора да користиме мапи, каде што mapa[x] = височина на точка x. Почнувајќи од вториот член, секогаш го проверуваме внесениот член со последниот внесен. Доколку абсолутната разлика на висните е поголема од далечината помеѓу тие две точки, тогаш можеме веднаш да испечатиме IMPOSSIBLE и да го прекинеме програмот. Доколку итераторот mapa.end() го означува крајот на мапата, тогаш со --mapa.end() можеме да го добиеме последниот член во мапата.

[code language="cpp"]
    map&lt;int, int&gt; height;
    int days,known;
    cin&gt;&gt;days&gt;&gt;known;
    map&lt;int, int&gt;::iterator it;
    for(int i=0;i&lt;known;i++)
    {
        int d,h;
        cin&gt;&gt;d&gt;&gt;h;
        if(!height.empty())
            if(!eval((--height.end())-&gt;first,d,(--height.end())-&gt;second,h))
            {
                cout&lt;&lt;&quot;IMPOSSIBLE&quot;;
                return 0;
            }
        height[d]=h;
    }
[/code]

Заради уредност на кодот користам функција eval, која што проверува дали абсолутната вредност помеѓу висините е поголема од далечината.

[code language="cpp"]
bool eval(int d1, int d2, int h1, int h2)
{
    if(h1&gt;h2)
        swap(h1,h2);
    if(h2-h1&gt;d2-d1)
        return false;
    return true;
}
[/code]

Доколку не испечатиме IMPOSSIBLE, тогаш треба да ја најдеме максималната височина. Бидејќи се работи за огромни броеви, начинот на кој ја решивме задачата B од натпреварот #298 не можеме да го употребиме тука. Пооптимизиран начин би било така што првин проверуваме колку време треба за да ги изедначиме двете точки (од пониската точка да стигнеме до висината на повисоката). Кога веќе двете точки се на иста висина, знаеме дека просторот помеѓу нив го поделуваме на две половини: една каде што висината расте, една каде што висината опаѓа. На овој начин можеме да стигнеме до максималната висина, но повторно да се вратиме на потребната висина.

[code language="cpp"]
    for(it=++height.begin();it!=height.end();it++)
    {
        int distances[2]={(--it)-&gt;first,(++it)-&gt;first};
        int heights[2]={(--it)-&gt;second,(++it)-&gt;second};
        int dist=distances[1]-distances[0];
        if(heights[0]&gt;heights[1])
        {
            dist-=heights[0]-heights[1];
            maksimum=max(maksimum,dist/2+heights[0]);
        }
        else
        {
            dist-=heights[1]-heights[0];
            maksimum=max(maksimum,dist/2+heights[1]);
        }
    }
[/code]

Се што преостанува е да го пресметаме просторот помеѓу 0 и првата точка и помеѓу последната точка и крајот.
[code language="cpp"]
maksimum=max(maksimum,height.begin()-&gt;second+height.begin()-&gt;first-1);
maksimum=max(maksimum,days-(--height.end())-&gt;first+(--height.end())-&gt;second);
[/code]

Ја печатиме променливата maksimum.]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>133</wp:post_id>
  <wp:post_date>2015-04-28 23:42:13</wp:post_date>
  <wp:post_date_gmt>2015-04-28 22:42:13</wp:post_date_gmt>
  <wp:post_modified>2015-04-28 23:42:13</wp:post_modified>
  <wp:post_modified_gmt>2015-04-28 22:42:13</wp:post_modified_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>codeforces-round-300</wp:post_name>
  <wp:status>publish</wp:status>
  <wp:post_parent>0</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>post</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <category domain="post_tag" nicename="brute-force"><![CDATA[Brute force]]></category>
  <category domain="category" nicename="codeforces"><![CDATA[codeforces]]></category>
  <category domain="post_tag" nicename="%d0%b4%d0%b8%d0%bd%d0%b0%d0%bc%d0%b8%d1%87%d0%ba%d0%be-%d0%bf%d1%80%d0%be%d0%b3%d1%80%d0%b0%d0%bc%d0%b8%d1%80%d0%b0%d1%9a%d0%b5"><![CDATA[Динамичко програмирање]]></category>
  <category domain="post_tag" nicename="%d1%81%d1%82%d1%80%d0%b8%d0%bd%d0%b3%d0%be%d0%b2%d0%b8"><![CDATA[Стрингови]]></category>
  <wp:postmeta>
    <wp:meta_key>_edit_last</wp:meta_key>
    <wp:meta_value><![CDATA[55813594]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>geo_public</wp:meta_key>
    <wp:meta_value><![CDATA[0]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_publicize_pending</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
</item>
<item>
  <title>Codeforces Round #303</title>
  <link>https://aandevski.wordpress.com/2015/05/19/codeforces-round-303/</link>
  <pubDate>Tue, 19 May 2015 19:54:12 +0000</pubDate>
  <dc:creator>add1ctus</dc:creator>
  <guid isPermaLink="false">https://aandevski.wordpress.com/?p=137</guid>
  <description/>
  <content:encoded><![CDATA[Досега најлесниот Codeforces натпревар на кој што сум учествувал. Од 5-те задачи, 3 се решаваа со greedy додека една имаше ad hoc решение. И покрај 4 решени задачи едвај добив +20 рејтинг заради изгубеното време на третата задача (50 минути и 4 погрешни решение заради глупа грешка).<!--more-->



<h1>A - Toy Cars</h1>

<a href="http://codeforces.com/problemset/problem/545/A">Линк до задачата</a>

Мислам дека нема потреба од многу објаснување за оваа задача. Ја читаме матрицата, и доколку во i-тиот ред сретнеме број 1 или 3 значи дека i-тиот автомобил не е добар. Исто така, доколку во j-тата колона сретнеме број 2 или 3, значи дека j-тиот автомобил не е добар. Ова го бележиме во boolean низа (иницирана на true). Додатно чувам променлива counter која ја намалувам секогаш кога ќе ставам некоја boolean вредност од true на false (бидејќи треба да се испечати исто така и бројот на добри автомобили).

[code language="cpp"]
#include &lt;iostream&gt;
#include &lt;cstring&gt;

using namespace std;

int main()
{
    int n;
    cin&gt;&gt;n;
    bool good[n];
    memset(good,true,n);
    int temp;
    int counter=n;
    for(int i=0;i&lt;n;i++)
        for(int j=0;j&lt;n;j++)
        {
            cin&gt;&gt;temp;
            if(temp&lt;=0)
                continue;
            if(temp==1 || temp==3)
            {
                if(good[i])
                    counter--;
                good[i]=false;
            }
            if(temp==2 || temp==3)
            {
                if(good[j])
                    counter--;
                good[j]=false;
            }
        }
    cout&lt;&lt;counter&lt;&lt;endl;
    for(int i=0;i&lt;n;i++)
        if(good[i])
            cout&lt;&lt;i+1&lt;&lt;&quot; &quot;;
    return 0;
}
[/code]

<h1>B - Equidistant String</h1>

<a href="http://codeforces.com/problemset/problem/545/B">Линк до задачата</a>

За дадените два стринга a и b, далечината ја пресметувате така што ги изминувате стринговите и проверувате на кои позиции a[i]!=b[i]. Доколку далечината на двата стринга е непарен број, тогаш печатиме impossible бидејќи не постои стринг што има еднаква далечина со двата стринга (секогаш ќе е поблиску до еден стринг). Доколку бројот е парен, тогаш можеме да направиме нов стринг p, така што на сите места каде што a[i]==b[i], ја ставаме таа буква. На преостанатите места, на една половина од нив ќе ја ставиме буквата од а, на другата половина буквата од б.

[code language="cpp"]
#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

int main()
{
    string a,b;
    cin&gt;&gt;a&gt;&gt;b;
    int distance=0;
    for(int i=0;i&lt;a.size();i++)
        if(a[i]!=b[i])
            distance++;
    if(distance%2==1)
    {
        cout&lt;&lt;&quot;impossible&quot;;
        return 0;
    }
    distance/=2;
    string result;
    for(int i=0;i&lt;a.size();i++)
        if(a[i]==b[i])
            result+=a[i];
        else if(distance)
        {
            result+=a[i];
            distance--;
        }
        else
            result+=b[i];
    cout&lt;&lt;result;
    return 0;
}
[/code]

<h1>C - Woodcutters</h1>

<a href="http://codeforces.com/problemset/problem/545/C">Линк до задачата</a>

Задача која што за време на натпреварот ја решив со динамичко (и изгубив многу поени заради грешка во печатење на резултатот), а има многу просто greedy решение.

Почнуваме од лево и ги бутаме дрвјата едно по едно. Првото дрво секогаш го бутаме на лева страна (бидејќи таму нема да смета на никое друго дрво). Бидејќи првото дрво веќе е бутнато, тогаш доколку го бутнеме второто на лево, знаеме дека нема да смета на првото. Истото правило важи и за сите останати дрвја (доколку можеме сите да ги бутнеме на лево, така правиме). Но што се случува кога не може да се бутне дрвото на лево? Доколку го бутнеме на десно, тогаш постои шанса да смета на дрвото од десно (да не можеме да го бутнеме на лево). Но како и да е, сме бутнале едно дрво а сме спречиле друго да не се бутне (кое дрво и да бутнеме, пак сме бутнале 1 дрво, не прави разлика), така да можеме слободно да бутнеме на десно доколку лево не можеме.

Чуваме две низи, position[i] (што означува позиција на i-тото дрво) и height[i] (што означува висина на i-тото дрво) и int бројач што ни означува колку дрва сме бутнале. Бидејќи првото дрво секогаш можеме да го бутнеме на лево, бројачот почнува од 1 (и фор циклусот го скокнува првото дрво). За сите наредни дрва (освен последното, кое секогаш можеме десно да го бутнеме), проверуваме дали position[i]-height[i] &gt; position[i-1] (дали доколку се бутне дрвото на лево, ќе удри во дрвото од негова лева страна). Доколку овој услов е исполнет, тогаш го зголемуваме бројачот за 1. Доколку не е исполнет, тогаш проверуваме position[i]+height[i] &lt; position[i+1] (дали доколку бутнеме на десно, ќе удри во дрвото од десна страна). Доколку овој услов е исполнет, тогаш го зголемуваме бројачот, но и на position[i] ја додаваме вредноста од height[i], за да не дојде до преклопување доколку две соседни дрва бутнеме едно кон друго. Се што преостанува е на крајот да додадеме +1 на резултатот за последното дрво кое секогаш го бутаме на десно. Но доколку n==1, тогаш не додаваме +1 бидејќи ќе ни даде погрешен резултат.

[code language=&quot;cpp&quot;]
#include &lt;iostream&gt;

using namespace std;

int main()
{
    int positions[100000];
    int heights[100000];
    int n;
    cin&gt;&gt;n;

    for(int i=0;i&lt;n;i++)
        cin&gt;&gt;positions[i]&gt;&gt;heights[i];

    int fallenTrees=1;

    for(int i=1;i&lt;n-1;i++)
    {
        if(positions[i]-heights[i]&gt;positions[i-1])
            fallenTrees++;
        else if(positions[i]+heights[i]&lt;positions[i+1])
        {
            fallenTrees++;
            positions[i]+=heights[i];
        }
    }

    if(n&gt;1)
        fallenTrees++;

    cout&lt;&lt;fallenTrees;

    return 0;
}
[/code]

<h1>D - Queue</h1>

<a href="http://codeforces.com/contest/545/problem/D">Линк до задачата</a>

Идејата е секогаш да служиме гости за кои треба највеќе време. Доколку имаме двајца со време 1 и 2, тогаш доколку прво го послужиме гостинот со време 2, тогаш гостинот со време 1 ќе е незадоволен. Ја сортираме низата, и почнуваме од гостите кои бараат најмалку време. Чуваме посебна променлива за тоа колку време поминало, и доколку послужиме некој гостин (времето му е помало од изминатото време), тогаш го зголемуваме изминатото време за неговото време. Во посебна променлива бележиме колку гости сме послужиле вкупно и го печатиме тој број.

[code language="cpp"]
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

int main()
{
    ios_base::sync_with_stdio(false);
    long long arr[100000];
    int n;
    cin&gt;&gt;n;
    for(int i=0;i&lt;n;i++)
        cin&gt;&gt;arr[i];
    sort(arr,arr+n);
    long long time=arr[0];
    int counter=1;
    for(int i=1;i&lt;n;i++)
        if(arr[i]&gt;=time)
        {
            counter++;
            time+=arr[i];
        }
    cout&lt;&lt;counter;
    return 0;
}
[/code]
]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>137</wp:post_id>
  <wp:post_date>2015-05-19 20:54:12</wp:post_date>
  <wp:post_date_gmt>2015-05-19 19:54:12</wp:post_date_gmt>
  <wp:post_modified>2015-05-20 11:35:25</wp:post_modified>
  <wp:post_modified_gmt>2015-05-20 10:35:25</wp:post_modified_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>codeforces-round-303</wp:post_name>
  <wp:status>publish</wp:status>
  <wp:post_parent>0</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>post</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <category domain="post_tag" nicename="ad-hoc"><![CDATA[Ad hoc]]></category>
  <category domain="category" nicename="codeforces"><![CDATA[codeforces]]></category>
  <category domain="post_tag" nicename="greedy"><![CDATA[Greedy]]></category>
  <wp:postmeta>
    <wp:meta_key>_rest_api_published</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_rest_api_client_id</wp:meta_key>
    <wp:meta_value><![CDATA[-1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_publicize_pending</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
</item>
<item>
  <title>Codeforces Round #304</title>
  <link>https://aandevski.wordpress.com/2015/05/23/codeforces-round-304/</link>
  <pubDate>Sat, 23 May 2015 02:00:16 +0000</pubDate>
  <dc:creator>add1ctus</dc:creator>
  <guid isPermaLink="false">https://aandevski.wordpress.com/?p=142</guid>
  <description/>
  <content:encoded><![CDATA[<em>Note to self: Никогаш не користи cin/cout наместо scanf/printf. Може да те чини 1000+ поени. </em>

Уште еден релативно лесен натпревар за втората дивизија со 4 задачи кои носат помалку од 2000 поени. Успеав првите 3 да ги решам за 18 минути (при што првата ја решив за 1 минут, нов личен рекорд). Четвртата задача, иако точна, не поминуваше на временскиот лимит заради користење на cin/cout. Учиме на грешките. <!--more-->

<h1>A - Soldier and Bananas</h1>

<a href="http://codeforces.com/problemset/problem/546/A">Линк до задачата</a>

Многу краток текст (што е реткост) кој ја објаснува задачата на прост начин. Потребно е само да го направите тоа што се бара: да ги соберете цените на сите банани (со помош на for циклус) и да проверите дали фалат уште пари или имате доволно. Истото може и да се направи така што од променливата со пари ги одземате цените на бананите. Доколку бројот е помал од 0, значи ви фалат пари, во спротивно, печатите 0.

[code language="cpp"]
#include &lt;iostream&gt;

using namespace std;

int main()
{
    int number,dollars,k;
    cin&gt;&gt;k&gt;&gt;dollars&gt;&gt;number;
    for(int i=1;i&lt;=number;i++)
        dollars-=k*i;
    if(dollars&gt;0)
        cout&lt;&lt;0;
    else
        cout&lt;&lt;dollars*-1;
    return 0;
}
[/code]

<h1>B - Soldier and Badges</h1>

<a href="http://codeforces.com/problemset/problem/546/B">Линк до задачата</a>

Повторно лесна задача која има повеќе начини за решавање. Го користиме фактот дека можеме само да ги зголемуваме броевите, но не и намалуваме. Започнуваме од најмалиот број (користам priority queue за да не се мачам со сортирање цело време) и користам додатна мапа &lt;int, bool&gt; за да забележам кој број го веќе имам земено (бидејќи не смееме да имаме дупликат броеви). Го земаме најмалиот број од queue-то. Доколку тој број прв пат се појавува, само забележуваме true во мапата. Во спротивно, го зголемуваме бројот се додека не стигнеме до некој број што не се појавува во мапата. Бележиме колку пати зголемуваме некој број, го печатиме тој број на крај.

[code language="cpp"]
#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
#include &lt;functional&gt;
#include &lt;map&gt;

using namespace std;

int main()
{
    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; Q;
    int n;
    cin&gt;&gt;n;
    for(int i=0;i&lt;n;i++)
    {
        int temp;
        cin&gt;&gt;temp;
        Q.push(temp);
    }
    map&lt;int, bool&gt; found;
    int result=0;
    while(!Q.empty())
    {
        int top=Q.top();
        Q.pop();
        while(found[top])
        {
            top++;
            result++;
        }
        found[top]=true;
    }
    cout&lt;&lt;result;
    return 0;
}
[/code]

<h1>C - Soldier and Cards</h1>

<a href="http://codeforces.com/problemset/problem/546/C">Линк до задачата</a>

Да го искористиме фактот дека постојат највеќе 10 карти. Во најлош случај потребни се 106 „борби“ за да има победник. Доколку има повеќе од 106 борби, значи резултатот е -1. Според начинот на кој играта се игра, може да користите 2 queue за двата играчи, каде што ги додавате картите. Ја вршиме објаснетата операција (споредување на првите 2 карти, ги ставаме на крај на играчот со поголема карта) се додека не се испразни некој шпил или бројот на операции е поголем од 106 (јас во мојот код ставив 10,000,000 заради безбедност, лол). На крајот само го печатиме резултатот.

[code language="cpp"]
#include &lt;iostream&gt;
#include &lt;queue&gt;

using namespace std;

int main()
{
    int n;
    cin&gt;&gt;n;
    queue&lt;int&gt; first,second;
    cin&gt;&gt;n;
    for(int i=0;i&lt;n;i++)
    {
        int temp;
        cin&gt;&gt;temp;
        first.push(temp);
    }
    cin&gt;&gt;n;
    for(int i=0;i&lt;n;i++)
    {
        int temp;
        cin&gt;&gt;temp;
        second.push(temp);
    }
    int stepCounter=0;
    while(stepCounter&lt;10000000 &amp;&amp; !first.empty() &amp;&amp; !second.empty())
    {
        if(first.front()&gt;second.front())
        {
            first.push(second.front());
            first.push(first.front());
        }
        else
        {
            second.push(first.front());
            second.push(second.front());
        }
        first.pop();
        second.pop();
        stepCounter++;
    }
    if(first.empty())
        cout&lt;&lt;stepCounter&lt;&lt;&quot; &quot;&lt;&lt;2&lt;&lt;endl;
    else if(second.empty())
        cout&lt;&lt;stepCounter&lt;&lt;&quot; &quot;&lt;&lt;1&lt;&lt;endl;
    else
        cout&lt;&lt;-1;
    return 0;
}
[/code]

<h1>D - Soldier and Number Game</h1>

<a href="http://codeforces.com/problemset/problem/546/D">Линк до задачата</a>

Интересна и предизвикувачка задача. Да разгледаме прво според која логика вториот војник би ги бирал броевите. Бидејќи при секој избор на број ние всушност го делиме дадениот број со нашиот број, значи дека ние дадениот број го делиме на помали делители. Бидејќи целта ни е да ја извршиме таа операција што повеќе пати, потребно е да го разложиме дадениот број на што повеќе броеви. Максималното разложување се постигнува кога бројот ќе се разложи на прости броеви (кои понатаму не можеме да ги разложиме). Така да за даден број x, потребно е да знаеме од колку прости броеви се содржи.

Но да го разгледаме начинот на внесување на броеви. Знаеме дека факториелот се пресметува како :

a! = 1 * 2 * 3 * 4 .... * a

Бидејќи имаме делење на два факториела, имаме повторување на дел од множителите, кои што можеме да ги скратиме. Да земеме за пример a=7 и b=4.

a! / b! = 1 * 2 * 3 * 4 * 5 * 6 * 7 / 1 * 2 * 3 * 4 = 5 * 6 * 7

Што значи дека на нас ни е потребно само да ги разложиме броевите 5, 6 и 7. Но бидејќи се работи за големи броеви (што ако треба да ги собираме сите множители од 1 до 5,000,000, милион пати?), заради оптимизација користиме динамичко програмирање (Range Sum Query). Користиме низа int DP каде што DP[x] означува колку прости множители имаат сите броеви од 1 до x. Со ова, доколку сакаме да ги добиеме множителите на сите броеви од 5 до 7 потребно е само да пресметаме DP[7] - DP[4].

Како ја пополнуваме оваа низа? Најпрвин користиме Ератостеново сито (гуглајте Sieve of Eratosthenes доколку ова не ви звучи познато) за да добиеме две работи:
<ul>
	<li>Листа на сите прости броеви (доколку е прост значи има само еден множител)</li>
	<li>Некој множител на сите останати проеви</li>
</ul>
Зошто ни е второто потребно? Да го земеме за пример бројот 20. Тој може да се претстави како 2 * 10, што значи дека DP[20] = 1 + DP[10]. Така да првично ја пополнуваме DP низата така што на сите места на прости броеви ставаме 1, а на останатите ставаме некој прост број кој може да го подели тој број.

Потоа почнувајќи од најмалиот, сите елементи ги заменуваме со вистинската вредност на DP (број на прости множители), така што доколку сретнеме број различен од 1, на негово место ставаме 1+DP[x/DP[x]]. Се што преостанува е да ја претвориме оваа низа во RSQ така што за сите DP правиме DP[x]=DP[x-1]+DP[x].

На крајот само ги внесуваме сите броеви и ја печатиме разликата DP[a]-DP[b].

[code language="cpp"]
#include &lt;stdio.h&gt;
#include &lt;cstring&gt;

using namespace std;

int DP[5000001];
bool isPrime[5000001];

int main()
{
    for(int i=0;i&lt;5000001;i++)
        DP[i]=1;
    memset(isPrime,true,5000001);
    isPrime[0]=isPrime[1]=false;
    for(int i=2;i&lt;2236;i++)
    {
        if(isPrime[i])
        {
            DP[i]=1;
            for(long long j=i*i;j&lt;5000001;j=j+i)
            {
                isPrime[j]=false;
                DP[j]=i;
            }
        }
    }

    for(int i=2;i&lt;5000001;i++)
        if(DP[i]!=1)
            DP[i]=1+DP[i/DP[i]];

    for(int i=2;i&lt;5000001;i++)
        DP[i]=DP[i-1]+DP[i];

    int tests,a,b;
    scanf(&quot;%d&quot;,&amp;tests);
    while(tests--)
    {
        scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
        printf(&quot;%d\n&quot;,DP[a]-DP[b]);
    }

    return 0;
}
[/code]]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>142</wp:post_id>
  <wp:post_date>2015-05-23 03:00:16</wp:post_date>
  <wp:post_date_gmt>2015-05-23 02:00:16</wp:post_date_gmt>
  <wp:post_modified>2015-05-23 02:58:12</wp:post_modified>
  <wp:post_modified_gmt>2015-05-23 01:58:12</wp:post_modified_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>codeforces-round-304</wp:post_name>
  <wp:status>publish</wp:status>
  <wp:post_parent>0</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>post</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <category domain="post_tag" nicename="ad-hoc"><![CDATA[Ad hoc]]></category>
  <category domain="post_tag" nicename="brute-force"><![CDATA[Brute force]]></category>
  <category domain="category" nicename="codeforces"><![CDATA[codeforces]]></category>
  <category domain="post_tag" nicename="%d0%b4%d0%b8%d0%bd%d0%b0%d0%bc%d0%b8%d1%87%d0%ba%d0%be-%d0%bf%d1%80%d0%be%d0%b3%d1%80%d0%b0%d0%bc%d0%b8%d1%80%d0%b0%d1%9a%d0%b5"><![CDATA[Динамичко програмирање]]></category>
  <wp:postmeta>
    <wp:meta_key>_rest_api_published</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_rest_api_client_id</wp:meta_key>
    <wp:meta_value><![CDATA[-1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_publicize_job_id</wp:meta_key>
    <wp:meta_value><![CDATA[10909892952]]></wp:meta_value>
  </wp:postmeta>
</item>
<item>
  <title>CodeFu 2015: Final Round</title>
  <link>https://aandevski.wordpress.com/2015/06/20/codefu-2015-final-round/</link>
  <pubDate>Sat, 20 Jun 2015 11:18:31 +0000</pubDate>
  <dc:creator>add1ctus</dc:creator>
  <guid isPermaLink="false">https://aandevski.wordpress.com/?p=144</guid>
  <description/>
  <content:encoded><![CDATA[<em>За почеток, да се извинам за долгата неактивност на блогов. Покрај колоквиумската недела и испитната сесија немав време да решавам било какви натпревари, а не пак да пишувам за нив. Од денеска започнувам со подготвување за локалните ACM квалификации, така да очекувајте зголемен број на постови. </em>

Еден од последните натпревари на кој учествував е 9-тото финале на CodeFu. Бидејќи натпреварот беше во исто време со испитната сесија, не успеав да се подготвам за него. Завршив 6-то место со 800 поени, губејќи 200 поени заради многу глупа грешка. Резултатите можете да ги отворите <a href="http://codefu.mk/codefu2015-final-round.html?subpage=results">тука</a>. А сега, на задачите.

[caption id="" align="aligncenter" width="1024"]<img src="http://codefu.mk/files/codefu2015/a5.jpg" alt="" width="1024" height="682" /> Атмосферата за време на натпреварот. Credits: codefu.mk[/caption]

<!--more-->
<h1>100 - ChessPieces</h1>
<a href="http://codefu.mk/codefu2015-final-round.html?subpage=problem&amp;problemid=2205">Линк до задачата</a>

Доста проста задача, која само бара да имплементирате тоа што е напишано. Ова може да се изведе на 2 начина, со барање на минимумот при делење на бројот на секоја фигура со бројот на фигури што одат во еден сет, или пак brute force со while циклус. Бидејќи има највеќе 100 фигури, тоа се во најлош случај 12 итерации, така да јас се одлучив за while варијантата за време на натпреварот.

Се додека имаме доволно фигури да направиме еден сет (8 пешаци, 2 коњи, 2 ловци, 2 топа, 1 крал, 1 кралица, од двете бои), го зголемуваме бројачот на сетови за 1 и ги одземаме тие фигури. Го враќаме резултатот кога еден од условите не е исполнет (фали една фигура од некој тип за сет). Исто така треба да го собереме и бројот на фигури кои не се искористени, што го правиме со for циклус.

Бидејќи одговорот треба да е string, користиме и getString функција која број ќе претвори во стринг (можете да ја најдете во претходниот CodeFu пост).

[code language="cpp"]
string howMany(vector&lt;int&gt; pieces)
    {
        int completeSets=0;
        while(pieces[0]&gt;=8
            &amp;&amp; pieces[1]&gt;=2
            &amp;&amp; pieces[2]&gt;=2
            &amp;&amp; pieces[3]&gt;=2
            &amp;&amp; pieces[4]&gt;=1
            &amp;&amp; pieces[5]&gt;=1
            &amp;&amp; pieces[6]&gt;=8
            &amp;&amp; pieces[7]&gt;=2
           &amp;&amp; pieces[8]&gt;=2
            &amp;&amp; pieces[9]&gt;=2
            &amp;&amp; pieces[10]&gt;=1
            &amp;&amp; pieces[11]&gt;=1)
        {
            pieces[0]-=8;
            pieces[1]-=2;
            pieces[2]-=2;
            pieces[3]-=2;
            pieces[4]-=1;
            pieces[5]-=1;
            pieces[6]-=8;
            pieces[7]-=2;
            pieces[8]-=2;
            pieces[9]-=2;
            pieces[10]-=1;
            pieces[11]-=1;
            completeSets++;
        }

        int sum=0;
        for(int i=0;i&lt;12;i++)
            sum+=pieces[i];

        string result;
        result+=getString(completeSets);
        result+=',';
        result+=getString(sum);

      return result;
  }
[/code]

<h1>200 - Calculator</h1>
<a href="http://codefu.mk/codefu2015-final-round.html?subpage=problem&amp;problemid=2206">Линк до задачата</a>

Доста интересна задача која само бара внимателно кодирање, а не познавања од некои стандардни алгоритми. Задачата е многу полесна доколку ја поделете на повеќе мали функции наместо еден огромен код. Јас ги користев следниве променливи:
<ul>
	<li>long long screen - бројот кој е прикажан на екранот</li>
	<li>long long memory - бројот запишан во меморија</li>
	<li>long long lastDigit - ова се користи за вршење на операции и го памти првиот број внесен (пред да се внесе некоја операциа и да почнете да го внесувате вториот број)</li>
	<li>char lastOperation - ја памти последната внесена операција (собирање / одземање / множење / делење)</li>
	<li>bool clearOnInput - доколку ова е true, тогаш треба да се внесе нов број (доколку се внесе некој број, бришеме се што има на екранот)</li>
</ul>
Потоа, потребни ни се следниве функции:
<ul>
	<li>void enterDigit(char c) - Доколку clearOnInput е true, брише се од екранот и ја внесува цифрата c, а во спротивно ја додава на крајот на бројот (целиот број го множи со 10 прво)</li>
	<li>void doOperation(char c) - Ја извршува операцијата дадена со c, помеѓу броевите lastDigit и screen.</li>
	<li>void enterOperation(char c) - Ја извршува претходната операција (lastOperation) и ги поставува променливите за нови внесувања</li>
	<li>void toMemory() - Го внесува бројот од screen во memory</li>
	<li>void fromMemory() - Го враќа бројот од меморија</li>
</ul>
Кога ги напишеме овие функции, се што преостанува е да го изминеме целиот инпут со фор циклус и да ги повикуваме функциите кога е потребно.

[code language="cpp"]
    long long lastDigit;
    long long memory;
    long long screen;
    bool clearOnInput;
    char lastOperation;
    void enterDigit(char c)
    {
        if(clearOnInput)
        {
            screen=c-'0';
            clearOnInput=false;
        }
        else
        {
            screen*=10;
            screen+=c-'0';
        }
    }
    void doOperation(char c)
    {
        if(c=='+')
        {
            screen=lastDigit+screen;
        }
        else if(c=='-')
        {
            screen=lastDigit-screen;
        }
        else if(c=='*')
        {
            screen=lastDigit*screen;
        }
        else
        {
            screen=lastDigit/screen;
        }
    }
    void enterOperation(char c)
    {
        doOperation(lastOperation);
        lastOperation=c;
        lastDigit=screen;
        clearOnInput=true;
    }
    void toMemory()
    {
        memory=screen;
    }
    void fromMemory()
    {
        screen=memory;
        clearOnInput=false;
    }
    int getResult(string input)
    {
        lastDigit=0;
        memory=0;
        screen=0;
        clea rOnInput=false;
        lastOperation='+';
        for(int i=0;i&lt;input.size()-1;i++)
        {
            if(input[i]&gt;='0' &amp;&amp; input[i]&lt;='9')
                enterDigit(input[i]);
            else if(input[i]=='M')
                toMemory();
            else if(input[i]=='R')
                fromMemory();
            else
                enterOperation(input[i]);
        }

        doOperation(lastOperation);

      return screen;
  }
[/code]

<h1>300 - KthNumber</h1>
<a href="http://codefu.mk/codefu2015-final-round.html?subpage=problem&amp;problemid=2207">Линк до задачата</a>

Омилената задача од овој натпревар и според мене потешка од четвртата. Го користиме фактот дека секој број може да се претстави како уникатна комбинација од прости множители. Пример, бројот 12 може да се претстави како 2*2*3 и на никој друг начин. Исто така, 2*2*3 го претставува само бројот 12 и никој друг.

Задачава ја решаваме brute force со помош на priority queue. Првиот број од кој почнуваме е 1. Кога вадиме некој број од priority queue, додаваме P нови броеви (каде што P е бројот на дадени прости броеви). Доколку простите броеви ни се 2, 3 и 5, а го вадиме бројот 15 од queue-от, тогаш ги додаваме броевите 30 (2*15), 45 (3*15) и 75(5*15). При ова додавање само треба да внимаваме да не додадеме ист број два пати, што може лесно да се направи со int,bool мапа. На овој начин цело време вадиме и додаваме броеви од queue-то, кое само ни ги сортира броевите цело време. K-тиот број што ќе го извадиме е решението.

Единствено нешто на кое што треба да внимавате е priority queue-от. Треба посебно да се дефинира да ги сортира во обратен редослед (од најмал кон најголем).

[code language="cpp"]
    string kthNumber(vector&lt;int&gt; primes, int k)
    {
        map&lt;long long, bool&gt; found;
        priority_queue&lt;long long, vector&lt;long long&gt;, greater&lt;long long&gt; &gt; Q;

        found[1]=true;
        Q.push(1);

        for(int i=0;i&lt;k-1;i++)
        {
            long long current=Q.top();
            Q.pop();
            for(int j=0;j&lt;primes.size();j++)
                if(!found[current*primes[j]])
                {
                    found[current*primes[j]]=true;
                    Q.push(current*primes[j]);
                }
        }


      return getString(Q.top());
  }
[/code]

<h1>400 - DigitsGame</h1>
<a href="http://codefu.mk/codefu2015-final-round.html?subpage=problem&amp;problemid=2208">Линк до задачата</a>

Не толку проста greedy задача. Најпрво броиме колку цифри имаме на располагање, и потоа ги користиме нив за да составиме број. Бројот го составуваме почнувајќи од лево кон десно. Бидејќи бројот што го составуваме треба да биде што поблиску до бројот A (или најмалиот број поголем од A или најголемиот број помал од A), секогаш пробуваме прво да ставиме иста цифра од бројот A на иста позиција. Доколку немаме таква цифра на располагање, тогаш додаваме друга цифра (пoголема од потребната за X, помала од потребната за Y). Кога веќе еднаш додадеме различна цифра, тогаш останатите цифри ги додаваме greedy. За X секогаш земаме помала цифра, додека за Y секогаш земаме поголема цифра (за да стигнеме што поблиску до A).

Решението го имплементираме рекурзивно (две посебни функции за поголем или помал број). Рекурзијата има два параметри - int што означува на кое место треба да додадеме цифра и bool што означува дали веќе имаме еднаш додадено различна цифра (за да го пополниме остатокот од бројот со greedy). Функцијата е од тип bool, која би вратила false доколку не можеме да добиеме таков број.

[code language="cpp"]
string target;
int available[10];
int temp[10];

string result=&quot;&quot;;

bool getSmaller(int targetPosition, bool goHam)
{
    if(targetPosition==target.size())
        return !(target==result);
    if(goHam)
    {
        for(int i=9;i&gt;=0;i--)
        {
            if(available[i])
            {
                available[i]--;
                result+=(char)(i+'0');
                if(getSmaller(targetPosition+1,goHam))
                    return true;
                available[i]++;
                result.erase(result.size()-1,1);
            }
        }
    }
    int neededDigit=target[targetPosition]-'0';
    if(available[neededDigit])
    {
        result+=(char)(neededDigit+'0');
        available[neededDigit]--;
        if(getSmaller(targetPosition+1,false))
            return true;
        available[neededDigit]++;
        result.erase(result.size()-1,1);
    }
    if(targetPosition==0 &amp;&amp; neededDigit==1)
        return false;
    for(int i=neededDigit-1;i&gt;=0;i--)
    {
        if(available[i])
        {
            available[i]--;
            result+=(char)(i+'0');
            if(getSmaller(targetPosition+1,true))
                return true;
            available[i]++;
            result.erase(result.size()-1,1);
        }
    }
    return false;
}

bool getBigger(int targetPosition, bool goHam)
{
    if(targetPosition==target.size())
        return true;
    if(goHam)
    {
        for(int i=0;i&lt;=9;i++)
        {
            if(available[i])
            {
                available[i]--;
                result+=(char)(i+'0');
                if(getBigger(targetPosition+1,true))
                    return true;
                available[i]++;
                result.erase(result.size()-1,1);
            }
        }
    }
    int neededDigit=target[targetPosition]-'0';
    if(available[neededDigit])
    {
        result+=(char)(neededDigit+'0');
        available[neededDigit]--;
        if(getBigger(targetPosition+1,false))
            return true;
        available[neededDigit]++;
        result.erase(result.size()-1,1);
    }
    for(int i=neededDigit+1;i&lt;=9;i++)
    {
        if(available[i])
        {
            available[i]--;
            result+=(char)(i+'0');
            if(getBigger(targetPosition+1,true))
                return true;
            available[i]++;
            result+=(char)(i+'0');
        }
    }
    return false;
}

class DigitsGame
{
  public:
    string getNumbers(string A, string B)
    {
        for(int i=0;i&lt;10;i++)
            available[i]=0;
        target=A;
        for(int i=0;i&lt;B.size();i++)
        {
            available[B[i]-'0']++;
        }

        string rez;
        if(!getBigger(0,false))
            result=&quot;0&quot;;
        rez+=result;
        rez+=',';
        result=&quot;&quot;;
        for(int i=0;i&lt;10;i++)
            available[i]=0;
        for(int i=0;i&lt;B.size();i++)
        {
            available[B[i]-'0']++;
        }
        if(!getSmaller(0,false))
            result=&quot;0&quot;;
        rez+=result;

      return rez;
  }
};
[/code]
]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>144</wp:post_id>
  <wp:post_date>2015-06-20 12:18:31</wp:post_date>
  <wp:post_date_gmt>2015-06-20 11:18:31</wp:post_date_gmt>
  <wp:post_modified>2015-06-20 12:16:15</wp:post_modified>
  <wp:post_modified_gmt>2015-06-20 11:16:15</wp:post_modified_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>codefu-2015-final-round</wp:post_name>
  <wp:status>publish</wp:status>
  <wp:post_parent>0</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>post</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <category domain="post_tag" nicename="ad-hoc"><![CDATA[Ad hoc]]></category>
  <category domain="post_tag" nicename="brute-force"><![CDATA[Brute force]]></category>
  <category domain="category" nicename="codefu"><![CDATA[CodeFu]]></category>
  <category domain="post_tag" nicename="%d1%80%d0%b5%d0%ba%d1%83%d1%80%d0%b7%d0%b8%d1%98%d0%b0"><![CDATA[Рекурзија]]></category>
  <category domain="post_tag" nicename="greedy"><![CDATA[Greedy]]></category>
  <wp:postmeta>
    <wp:meta_key>_rest_api_published</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_rest_api_client_id</wp:meta_key>
    <wp:meta_value><![CDATA[-1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_publicize_job_id</wp:meta_key>
    <wp:meta_value><![CDATA[11858500622]]></wp:meta_value>
  </wp:postmeta>
</item>
<item>
  <title>Дрва, Политички Партии (МОИ 15)</title>
  <link>https://aandevski.wordpress.com/2015/07/13/%d0%b4%d1%80%d0%b2%d0%b0-%d0%bf%d0%be%d0%bb%d0%b8%d1%82%d0%b8%d1%87%d0%ba%d0%b8-%d0%bf%d0%b0%d1%80%d1%82%d0%b8%d0%b8-%d0%bc%d0%be%d0%b8-15/</link>
  <pubDate>Mon, 13 Jul 2015 17:03:07 +0000</pubDate>
  <dc:creator>add1ctus</dc:creator>
  <guid isPermaLink="false">https://aandevski.wordpress.com/?p=148</guid>
  <description/>
  <content:encoded><![CDATA[Неодамна добив една доста интересна задача за решавање, задачата <a href="http://mendo.mk/Task.do?id=555" target="_blank">Политичка Партија</a> од овогодинешните МОИ. При првото читање на задачата, првото решение што ми текна е претставување на партијата како кореново дрво и greedy бришење на темиња (што се испостави да не работи во секој случај). Како и да е, бидејќи порано немав решавано задачи со дрва (или воопшто користено дрва), иако успеав да ја решам задачата само 16/20, искуството со дрва ми се покажа доста корисно. Во продолжение ќе го објаснам моето решение на задачата.<!--more-->
<h1>Што се дрва?</h1>
Доколку би ја сретнал оваа задача пред година дена, повторно би се сетил на greedy идејата, но би го имплементирал ова со граф. Кодот би бил доста посложен да се напише и најверојатно не би работел толку бргу (моето решение со дрва поминува за 0.1 секунда на најтешкиот пример со уште простор за оптимизација). Што е разликата помеѓу графови и дрва тогаш?

Технички гледано, дрвата се графови. Структура која содржи темиња и мостови кои ги поврзуваат тие темиња. Додатно, дрвото има некои додатни спецификации. Тоа не е насочено и нема циклуси. Кореново дрво е дрво каде што темињата кои се поврзани се во врска родител - дете. За секои две темиња кои се поврзани, едното е родител, другото е дете. Темето кое нема ниту еден родител се нарекува корен. Секогаш постои само еден корен во кореново дрво.

[caption id="" align="aligncenter" width="576"]<img src="http://www.csee.umbc.edu/courses/undergraduate/341/fall98/frey/ClassNotes/Class14/RootedTree.jpg" alt="" width="576" height="377" /> Кореново дрво каде што A е коренот[/caption]

Најголемата разлика е во начинот на претставување на дрвата во код. Додека за граф би користеле матрица на соседност или листи (низа од вектори) кои покажуваат која точка со кои е поврзана, за дрво користиме посебна структура за темињата. Во структурата зачувуваме покажувачи кон родителот на тоа теме и неговите деца. Подоцна правиме низа од таа структура и со покажувачите ги дефинираме врските помеѓу темињата.

[code language="cpp"]
struct Node
{
    Node* parent;
    vector&lt;Node*&gt; children;
}

Node nodes[50000];
[/code]

За да работите дрва треба да имате основни познавања од објектно-ориентирано програмирање (структури) и покажувачи. Нема да навлегувам многу во детали за нешто што можете да го научите онлајн, туку ќе преминам на задачата.
<h1>Решавање на Политички партии со дрва</h1>
Доколку не забележавте досега, политичката партија е секогаш кореново дрво, каде што членот 1 е секогаш коренот. За секое теме освен родителот и децата, треба исто така и да забележиме колкава е неговата лична моќ, и вкупната моќ (неговата моќ + вкупната моќ на сите негови деца). Додатно, чувам уште една boolean променлива која ми означива дали тој член е веќе избришан. Тука можете да забележите колкава предност ни даваат дрвата во однос на графови во оваа задача.

[code language="cpp"]
    void calculateSubtree()
    {
        sum=power; //Ставаме почетна вредност на сумата, личната моќ на тоа теме
        for(int i=0;i&lt;children.size();++i) //Ги изминува сите деца
        {
            children[i]-&gt;calculateSubtree(); //Ја пресметува рекурзивно моќта на детето i
            sum+=children[i]-&gt;sum; //Ја додава пресметаната моќ на детето i на сумата
        }
    }
[/code]

Откако ќе го имаме внесено дрвото (врските родител-дете за сите темиња) и личната моќ на сите членови, доколку ја повикаме оваа функција за коренот на дрвото, рекурзивно ќе се пресмета вкупната моќ за сите членови во целото дрво. Уште полесно ни е бришењето на членови од партијата, што го правиме со две функции:

[code language="cpp"]
    void deleteIt()
    {
        for(int i=0;i&lt;children.size();++i) //Ги изминува сите деца
            children[i]-&gt;deleteIt(); //Ги брише децата едно по едно
        changeParentSum(sum); //Ја намалува сумата на родителот
        deleted=true; //Го поставува темето како избришано
    }
[/code]


[code language="cpp"]
    void changeParentSum(long long n)
    {
        sum-=n; //Ја намалува сумата за дадениот број
        if(parent!=NULL) //Доколку темето има родител, ја намалува и сумата на родителот рекурзивно
            parent-&gt;changeParentSum(n);
    }
[/code]

Повторно, благодарение на рекурзија многу лесно можеме да бришеме членови од дрвото. Со ова задачата ни се сведува на:
<ul>
	<li>Внесување на дрвото</li>
	<li>Повикување calculateSubtree на коренот</li>
	<li>Извршување K-пати
<ul>
	<li>Наоѓање на членот со најмала вкупна моќ кој не е избришан</li>
	<li>Бришење на тој член доколку вкупната моќ му е помала од 0</li>
</ul>
</li>
	<li>Печатење на сумата на коренот</li>
</ul>

[code language="cpp"]
    nodes[0].calculateSubtree();

    while(k--)
    {
        int smallest=-1;
        for(int i=0;i&lt;n;++i)
        {
            if(!nodes[i].deleted &amp;&amp; (smallest==-1 || nodes[i].sum &lt; nodes[smallest].sum))
                smallest=i;
        }

        if(nodes[smallest].sum&gt;0)
            break;

        nodes[smallest].deleteIt();
    }

    printf(&quot;%I64d&quot;,nodes[0].sum);
[/code]

Единственото нешто што преостанува е конструкција на дрвото, што се испостави малку потешко за оваа задача.
<h1>Конструкција на дрвото</h1>
За конструкција на дрвото користиме две додатни функции:

[code language="cpp"]
    void addChild(Node* child)
    {
        children.push_back(child);
    }
[/code]


[code language="cpp"]
    void setParent(Node* p)
    {
        parent=p;
    }
[/code]

Доколку имаме врска помеѓу a и b каде што а е родителот а b е детето, тогаш повикуваме

[code language="cpp"]
    nodes[a].addChild(&amp;nodes[b]);
    nodes[b].setParent(&amp;nodes[a]);
[/code]

Но за дадена врска, како знаеме кој е родителот а кој е детето? Единствено што знаеме во задачата е дека 1 е коренот на ова дрво. Да го разгледаме следниов тест пример

3 2
1 3

Бидејќи знаеме дека 1 е коренот на дрвото, тогаш знаеме дека 1 е родителот на 3. Доколку го забележиме својството во задачата дека секое теме може да има само еден родител, тогаш со сигурност знаеме дека 3 е родителот на 2 (бидејќи 3 не може да има два родитела). Но бидејќи прво внесуваме 3 2, не знаеме дека 3 има родител и не можеме да ја запишеме оваа врска.

Едно решение би било изминување на целата низа се додека не се разрешат сите врски. Доколку и двете темиња немаат најдено родител, ги меморираме, прескокнуваме и пробуваме подоцна. Но доколку би имале тест пример што личи на :

5 4
4 3
3 2
2 1

овој алгоритам би работел многу поспоро. Со максимум (50,000) темиња, се работи за 1,250,025,000 проверки додека да се прочита целото дрво. Сигурно би можеле нешто побрзо да смислиме.

Друго решение е доколку користиме нешто слично на граф (низа од вектори) каде што ги зачувуваме сите врски кај кои немаме најдено родител. Доколку прочитаме броеви a и b и немаме најдено родители и кај двата, тогаш во vec[a] го додаваме бројот b и во vec[b] го додаваме бројот а. Подоцна, кога ќе најдеме родител на некое теме (да кажеме теме x), тогаш сите темиња од vec[x] ги поставаме да се деца на x. Ова се извршува рекурзивно за да го генерираме целото дрво. Користиме додатна boolean низа found која ни означува дали родителот на некое теме е пронајден (иако може да се имплементира ова и со parent покажувачот)

[code language="cpp"]
    for(int i=0;i&lt;n-1;++i)
    {
        scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
        --a; //Ги намалуваме броевите бидејќи низата започнува од 0
        --b;
        if(!found[a]) //Доколку не е пронајден родителот на а, ги заменуваме да провериме дали е пронајден родителот на b
        {
            swap(a,b);
        }
        if(!found[a]) //Доколку не е пронајден ниту овој родител, тогаш ги запишуваме во векторите
        {
            vec[a].push_back(b);
            vec[b].push_back(a);
        }
        else //Пронајден е родител, така да можеме да ја поставиме врската, и да повикаме реконструкција на b за да се додадат врските од векторот
        {
            nodes[a].addChild(&amp;nodes[b]); 
            nodes[b].setParent(&amp;nodes[a]);
            reconstruct(b);
        }
    }
[/code]


[code language="cpp"]
void reconstruct(int n)
{
    if(found[n]) //Доколку е веќе пронајден родителот на темето, нема што да смениме, се враќаме назад
        return;
    found[n]=true;
    for(int i=0;i&lt;vec[n].size();++i)
    {
        if(!found[vec[n][i]])
        {
            nodes[n].addChild(&amp;nodes[vec[n][i]]);
            nodes[vec[n][i]].setParent(&amp;nodes[n]);
            reconstruct(vec[n][i]);
        }
    }
}
[/code]

За ова да работи потребно е низата found да е иницирана на false, освен коренот на дрво кој е поставен на true (бидејќи не треба да има родител). Ова го заклучува решението на задачата, кое поминува на 16/20 тест примери.
<h1>Зошто решението не работи целосно</h1>
Идејата не е добра. Да го разгледаме следниов тест пример.

<a href="https://aandevski.files.wordpress.com/2015/07/screenshot_19.png"><img class="aligncenter size-full wp-image-149" src="https://aandevski.files.wordpress.com/2015/07/screenshot_19.png" alt="Screenshot_19" width="278" height="268" /></a>Замислете дека дрвото уште продолжува нагоре. Сумата на темето 1 од лева страна би била -26, додека сумата на темето 1 кое е родител на сите би била -39.

Според нашата greedy идеја, најдобро решение би било да го избришеме горното теме 1, со што вкупната вредност ќе ни се зголеми за 39. Но дали секогаш е така? Да замислиме дека сите други темиња во дрвото се позитивни. Тогаш:
<ul>
	<li>Доколку смееме да избришеме еден член, го бршеме родителот и збирот ни се зголемува за 39.</li>
	<li>Доколку смееме да избришеме два члена, ги бришеме децата од лева и десна страна (со вредностите 1 и -15), така да сумата ни се зголемува за 41</li>
	<li>Доколку смееме да избришеме три члена, ги бришеме членовите со вредности -20, -15 и -8. Вкупната сума ни се зголемува за 43.</li>
</ul>
Бидејќи изборот ни зависи од тоа колку членови треба да избришеме, не можеме со greedy да правиме избор. Не се сетив на овој пример кога почнав да ја решавам задачава, но бев изненаден како може да се добијат 80 поени со вакво решение. Мислам дека решението на оваа задача ќе се базира на динамичко, но сеуште ја немам размислувано или решавано во таа насока.]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>148</wp:post_id>
  <wp:post_date>2015-07-13 18:03:07</wp:post_date>
  <wp:post_date_gmt>2015-07-13 17:03:07</wp:post_date_gmt>
  <wp:post_modified>2015-07-13 18:00:36</wp:post_modified>
  <wp:post_modified_gmt>2015-07-13 17:00:36</wp:post_modified_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>%d0%b4%d1%80%d0%b2%d0%b0-%d0%bf%d0%be%d0%bb%d0%b8%d1%82%d0%b8%d1%87%d0%ba%d0%b8-%d0%bf%d0%b0%d1%80%d1%82%d0%b8%d0%b8-%d0%bc%d0%be%d0%b8-15</wp:post_name>
  <wp:status>publish</wp:status>
  <wp:post_parent>0</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>post</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <category domain="post_tag" nicename="%d0%b4%d1%80%d0%b2%d0%b0"><![CDATA[Дрва]]></category>
  <category domain="category" nicename="%d0%bc%d0%b5%d0%bd%d0%b4%d0%be"><![CDATA[мендо]]></category>
  <wp:postmeta>
    <wp:meta_key>_rest_api_published</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_rest_api_client_id</wp:meta_key>
    <wp:meta_value><![CDATA[-1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_publicize_job_id</wp:meta_key>
    <wp:meta_value><![CDATA[12691427040]]></wp:meta_value>
  </wp:postmeta>
</item>
<item>
  <title>Screenshot_19</title>
  <link>https://aandevski.wordpress.com/2015/07/13/%d0%b4%d1%80%d0%b2%d0%b0-%d0%bf%d0%be%d0%bb%d0%b8%d1%82%d0%b8%d1%87%d0%ba%d0%b8-%d0%bf%d0%b0%d1%80%d1%82%d0%b8%d0%b8-%d0%bc%d0%be%d0%b8-15/screenshot_19/</link>
  <pubDate>Mon, 13 Jul 2015 16:54:42 +0000</pubDate>
  <dc:creator>add1ctus</dc:creator>
  <guid isPermaLink="false">http://aandevski.files.wordpress.com/2015/07/screenshot_19.png</guid>
  <description/>
  <content:encoded><![CDATA[]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>149</wp:post_id>
  <wp:post_date>2015-07-13 17:54:42</wp:post_date>
  <wp:post_date_gmt>2015-07-13 16:54:42</wp:post_date_gmt>
  <wp:post_modified>2015-07-13 17:54:42</wp:post_modified>
  <wp:post_modified_gmt>2015-07-13 16:54:42</wp:post_modified_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>screenshot_19</wp:post_name>
  <wp:status>inherit</wp:status>
  <wp:post_parent>148</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>attachment</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <wp:attachment_url>https://aandevski.files.wordpress.com/2015/07/screenshot_19.png</wp:attachment_url>
</item>
<item>
  <title>Најкраток пат во граф со негативни тежини, Bellman-Ford</title>
  <link>https://aandevski.wordpress.com/2015/07/25/%d0%bd%d0%b0%d1%98%d0%ba%d1%80%d0%b0%d1%82%d0%be%d0%ba-%d0%bf%d0%b0%d1%82-%d0%b2%d0%be-%d0%b3%d1%80%d0%b0%d1%84-%d1%81%d0%be-%d0%bd%d0%b5%d0%b3%d0%b0%d1%82%d0%b8%d0%b2%d0%bd%d0%b8-%d1%82%d0%b5%d0%b6/</link>
  <pubDate>Sat, 25 Jul 2015 12:20:00 +0000</pubDate>
  <dc:creator>add1ctus</dc:creator>
  <guid isPermaLink="false">https://aandevski.wordpress.com/?p=151</guid>
  <description/>
  <content:encoded><![CDATA[Доколку не бевте запознаени досега, постои <a href="http://mendo.mk/algoritmi/">„скриен“ дел на Мендо</a> наменет за ФИНКИ, поточно за предметот Алгоритми и податочни структури (кој се изучува втора година). Таму, покрај лабораториските вежби за тој предмет и неколку предизвици по Дискретна математика, исто така можете да најдете и<a href="http://mendo.mk/algoritmi/User_Competition.do?id=150"> интересна база на задачи за вежбање</a> алгоритми (динамичко, графови, итн). Решавајќи ги задачите од таа секција наидов на една доста интересна задача за која морав да научам нов алгоритам кој е доста лесен и интересен, па решив да го споделам.

<!--more-->

Задачава е <a href="http://mendo.mk/algoritmi/Task.do?competition=150&amp;id=166">следна</a>. Откако ќе ја прочитате приказната за магистрални патишта, компании и инвестиции и размислите малку, станува јасно дека во задачава всушност станува збор за насочен тежински граф во кој треба да најдете најкраток пат од точката S до точката T. Звучи просто на почеток, станува збор само за школски пример на алгоритмот на Dijkstra. Но тука наидуваме на проблем, во задачава тежините можат да бидат и негативни броеви.
<h1>Зошто Dijkstra не работи со негативни броеви?</h1>
Доколку сте добро запознаени со алгоритмот на Dijkstra, веројатно знаете дека тој работи на greedy принцип. Тоа би работело перфектно во граф со само позитивни тежини, бидејќи секогаш пробувате да ја изберете најмалата тежина (бидејќи доколку сега не сте нашле помала, сигурно нема и во иднина да најдете). Проблемот доаѓа со негативни тежини, бидејќи не можеме да бидеме сигурни дека најмалата тежина што ја гледаме во даден момент ќе е најмала и кога завршиме со изминување на графот, бидејќи можеби графот се разгранува во негативни броеви кои би пронашле алтернативен и поефтин пат до бараното теме. Доколку ова ви звучи тешко за сфаќање, ќе разгледаме еден прост пример.

<img class=" aligncenter" src="http://i.stack.imgur.com/rmowk.png" alt="" />

Најпрвин да разгледаме како алгоритмот на Dijkstra би работел тука. Почнувајќи од A, најблиското теме ни е C, така да го означуваме како посетено со далечина 0. Следното е B, со далечина 1, па на крајот останува D, со далечина 99. Врската D-&gt;B со тежина -300 воопшто не се користи. Доколку би ја искористиле таа врска, тогаш најкраткиот пат до B е -201, а најкраткиот пат до C е -200.
<h1>Enter, Bellman-Ford</h1>
Смислен од прилика во исто време со алгоритмот на Dijkstra, алгоритмот на Richard Bellman и Lester Ford ја врши истата работа, наоѓање на најкраток пат во граф. Но за разлика од Dijkstra кој работи во временска сложеност од O(N^2) (или O(NlogN) со priority queue), овој алгоритам работи со приближно O(N^3) сложеност, што е значајно поспоро при големи тест примери. Предноста е во тоа што овој алгоритам е пофлексибилен, па како таков дозволува и негативни тежини и додатно може да најде неограничени циклуси на негативни тежини (што ќе објасниме подоцна).

Начинот на кој овој алгоритам работи е доста прост и е уште полесен за пишување во код. За разлика од Dijkstra, тука не бележиме кое теме е веќе посетено (бидејќи ќе ги посетуваме повеќе пати), туку само ја бележиме далечината на темињата од изворот. Додатно, може да го бележите изворот за секое теме (исто како кај Dijkstra) што може да се најде корисно при реконструкција на патот (што е потребно во задачата која ја решаваме).

За почеток, далечините на сите темиња ги иницијализираме на некој огромен број, освен за изворот чија далечина е 0. Потоа, за сите врски (x,y) (што значи врска од темето x кон темето y) со тежина z, проверуваме дали dist[x] + z е помало од dist[y]. Доколку е помало, тогаш го менуваме dist[y] и source-от соодветно. За поопширно објаснување како работи овој алгоритам (и следење на пример чекор по чекор), ви го препорачувам <a href="https://www.youtube.com/watch?v=iTW2yFYd1Nc">ова видео</a>.

На овој начин, редоследот по кој ги бираме врските би бил доста битен, но дури и тогаш алгоритмот не би го открил најкраткиот пат секогаш, бидејќи не се разгранува ни прилично доволно за да ги провери сите патишта. Како решение на овој проблем, го пуштаме горенаведениот алгоритам да работи N-1 пати, каде N е бројот на темиња во графот. Со завршувањето на N-1 итерации, овој алгоритам би го открил најкраткиот пат кон секое теме.
<h1>Негативни циклуси</h1>
Една забелешка кај графови со негативни тежини е дека не секој граф има најкраток пат. Да го разгледаме следниов граф:

<img class=" aligncenter" src="http://i.stack.imgur.com/pNLTw.png" alt="" />

Во дадениот пример, како најкраток пат од 1 до 2 може да се земе патот 1-&gt;2 со далечина -20. Уште пократок пат би бил патот 1-&gt;2-&gt;3-&gt;2 со далечина -25. Уште пократок пат од тоа би бил 1-&gt;2-&gt;3-&gt;2-&gt;3-&gt;2 со далечина -30. Всушност секогаш кога ние додаваме 2-&gt;3-&gt;2 во патот, ние ја намалуваме должината за 5. Направете го тоа бесконечен број пати и добивате пат со бесконечно мала должина. За вакви графови се вели дека немаат најкраток пат (дека не е можно да се одреди најкраткиот пат).

За среќа, алгоритмот на Bellman-Ford ни овозможува лесно да детектираме и да ги пријавиме ваквите циклуси. Бидејќи алгоритмот гарантира дека после N-1 итерации ќе го пронајде најкраткиот пат од изворот до секое теме, потребно е ние да направиме само уште една итерација. Доколку новата итерација повторно најде некој пократок пат, значи дека овој граф има бесконечен негативен циклус.
<h1>Пишување на код, решавање на задачата</h1>
Најпрвин ги пишуваме податочните структури и го средуваме инпутот на задачата. Графот го запишуваме во низа од вектори од парови (бидејќи работиме со тежини). Додатно имаме низи dist (за далечина) и source (за памтење на изворот за реконструкција). При внес, броевите ги намалувам за 1 за да биде графот од 0 до N-1 наместо од 1 до N (бидејќи сум навикнат да пишувам for циклуси што почнуваат од 0). Додатно, dist низата ја иницираме на 9999999, освен изворот кој го иницираме на 0.

[code language="cpp"]
    int n,m,a,b,c,s,t;
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);

    vector&lt;pair&lt;int,int&gt; &gt; graph[3000];
    int dist[3000];
    int source[3000];

    for(int i=0;i&lt;3000;++i)
        dist[i]=9999999;

    for(;m;--m)
    {
        scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);
        graph[--a].push_back(make_pair(--b,c));
    }

    scanf(&quot;%d%d&quot;,&amp;s,&amp;t);
    dist[--s]=0;
[/code]

Со ова инпутот ни е завршен и вредностите се иницијализирани, така да можеме да преминеме на наоѓањето на најкраток пат. Почнуваме со for циклус кој ќе изброи N-1 итерации на алгоритмот. Внатре во тој for циклус, со друг for циклус го изминуваме секое теме, чии што врски ги изминуваме со трет for циклус. На овој начин ги изминуваме сите можни врски во графот. Се што преостанува е да провериме за секоја можна врска, дали таа наоѓа нов, пократок пат, од оној што го веќе знаеме.

Заради природата на овој алгоритам, доколку сакате можете графот да го запишете само како низа од врски, каде што врската би била претставена со 3 параметри: двете точки кои се поврзани и тежината на врската. На овој начин алгоритмот би работел со O(N*M) сложеност, додека со матрица на поврзаност алгоритмот работи со O(N^3) сложеност.

[code language="cpp"]
    for(int iteracii=0;iteracii&lt;n-1;++iteracii)
        for(int i=0;i&lt;n;++i)
            for(int j=0;j&lt;graph[i].size();++j)
                if(dist[i] + graph[i][j].second &lt; dist[graph[i][j].first])
                {
                    source[graph[i][j].first] = i;
                    dist[graph[i][j].first] = dist[i] + graph[i][j].second;
                }
[/code]

За крај, треба да провериме дали постои некој циклус, така да правиме уште една додатна итерација која веднаш пријавува доколку сретне пократок пат и го прекинува програмот.

[code language="cpp"]
    for(int i=0;i&lt;n;++i)
        for(int j=0;j&lt;graph[i].size();++j)
            if(dist[i] + graph[i][j].second &lt; dist[graph[i][j].first])
            {
                printf(&quot;Impossible&quot;);
                return 0;
            }
[/code]

Доколку не е пронајден циклус, тогаш потребно е да ја испечатиме далечината на патот и со помош на source да го измериме бројот на чекори.

[code language="cpp"]
    printf(&quot;%d &quot;,dist[--t]);

    int counter=0;

    while(t!=s)
    {
        ++counter;
        t=source[t];
    }

    printf(&quot;%d&quot;,counter);
[/code]

Со ова задачата е решена.]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>151</wp:post_id>
  <wp:post_date>2015-07-25 14:20:00</wp:post_date>
  <wp:post_date_gmt>2015-07-25 12:20:00</wp:post_date_gmt>
  <wp:post_modified>2015-07-25 14:27:02</wp:post_modified>
  <wp:post_modified_gmt>2015-07-25 12:27:02</wp:post_modified_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>%d0%bd%d0%b0%d1%98%d0%ba%d1%80%d0%b0%d1%82%d0%be%d0%ba-%d0%bf%d0%b0%d1%82-%d0%b2%d0%be-%d0%b3%d1%80%d0%b0%d1%84-%d1%81%d0%be-%d0%bd%d0%b5%d0%b3%d0%b0%d1%82%d0%b8%d0%b2%d0%bd%d0%b8-%d1%82%d0%b5%d0%b6</wp:post_name>
  <wp:status>publish</wp:status>
  <wp:post_parent>0</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>post</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <category domain="post_tag" nicename="bellman-ford"><![CDATA[Bellman-Ford]]></category>
  <category domain="category" nicename="%d0%bc%d0%b5%d0%bd%d0%b4%d0%be"><![CDATA[мендо]]></category>
  <wp:postmeta>
    <wp:meta_key>_rest_api_published</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_rest_api_client_id</wp:meta_key>
    <wp:meta_value><![CDATA[-1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_publicize_job_id</wp:meta_key>
    <wp:meta_value><![CDATA[13072692742]]></wp:meta_value>
  </wp:postmeta>
</item>
<item>
  <title>Codeforces Round #Pi</title>
  <link>https://aandevski.wordpress.com/2015/08/08/codeforces-round-pi/</link>
  <pubDate>Sat, 08 Aug 2015 13:33:30 +0000</pubDate>
  <dc:creator>add1ctus</dc:creator>
  <guid isPermaLink="false">https://aandevski.wordpress.com/?p=167</guid>
  <description/>
  <content:encoded><![CDATA[По долга пауза (некој вид на летен распуст) повторно започнувам со онлајн натпревари. Првиот на листа е 314-тиот Codeforces натпревар, посветен на бројот Пи. Како за натпревар организиран од учесник од втора дивизија, натпреварот беше прилично лесен и не бараше познавања од некои алгоритми надвор од стандардните (стандардните ги сметам BFS, DFS, Dijkstra, Динамичко, Binary search). Потешките задачи само имаа потежок начин на доаѓање до идејата.

За време на натпреварот успеав да ги решам првите 3 и бев многу блиску до точно решение на задачата D, каде што погрешно бев разбрал дел од задачата. Со тој резултат успеав да стигнам до 212-тото место што ме доближи до првата дивизија уште повеќе. Ова беа моите решенија на првите 4 задачи (задачата E ќе ја објаснам во посебен блог пост).<!--more-->
<h1>A - Lineland Mail</h1>
<a href="http://codeforces.com/problemset/problem/567/A">Линк до задачата</a>

Имате дадено градови во еднодимензионално поле (означени со Х координата). За секој град вие треба да ја кажете далечината на градот најблиску до него и градот најдалеку до него.

За два града x и y, далечината можеме да ја добиеме како апсолутната вредност од koordinata[x] - koordinata[y]. Доколку знаеме дека еден град има поголема координата од другиот, тогаш можеме да го ставиме како прв број во разликата и воопшто да не користиме апсолутна вредност.

Бидејќи се работи за 10<sup>5</sup> градови, не е идеално решението да ги споредуваме сите градови еден со друг. Со сигурност знаеме дека за секој град, градот најдалеку од него е еден од градовите кој се наоѓа на краевите на полето. Исто така знаеме дека за секој град, градот најблиску до него е еден од двата града соседни на тој град. Според ова, доколку имаме N градови и пробуваме да го најдеме решението за градот X, тогаш најдалекиот град е еден од градовите 0 или N-1, додека најблискиот град е еден од градовите X-1 или X+1. Единствен исклучок за ова е првиот и последниот град.

[code language="cpp"]
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    int arr[n];
    for(int i=0;i&lt;n;++i)
        scanf(&quot;%d&quot;,&amp;arr[i]);
    printf(&quot;%d %d\n&quot;,arr[1]-arr[0],arr[n-1]-arr[0]);
    for(int i=1;i&lt;n-1;++i)
        printf(&quot;%d %d\n&quot;,min(arr[i]-arr[i-1],arr[i+1]-arr[i]),max(arr[i]-arr[0],arr[n-1]-arr[i]));
    printf(&quot;%d %d&quot;,arr[n-1]-arr[n-2],arr[n-1]-arr[0]);
[/code]

<h1>B - Berland National Library</h1>
<a href="http://codeforces.com/problemset/problem/567/B">Линк до задачата</a>

Иако на почеток задачата знае да биде збунувачка, по кратко размислување можете да забележите дека е многу проста. Имате систем во библиотека кој бележи кога некој влегува или излегува. Секој посетител има свој ID и може да влегува или излегува повеќе пати. Исто така можно е тој посетител да влегол пред да се пушти системот. За даден извештај од системот, потребно е да утврдите колку највеќе луѓе биле внатре во било кој момент.

Чуваме boolean низа која ни означува дали некој посетител е внатре или не. Исто така имаме и променлива што ни означува колку луѓе има внатре во моментот. Секогаш кога ќе влезе некој, го зголемуваме бројот за 1. Но кога некој излезе, постојат две опции:
<ul>
	<li>Корисникот влегол кога бил пуштен системот, така да го намалуваме бројот на моментални посетители за 1</li>
	<li>Корисникот бил влезен пред да се пушти системот, така да го зголемуваме максимумот на посетителите за 1</li>
</ul>
Со оваа забелешка решението е просто:

[code language="cpp"]
int n;
    cin&gt;&gt;n;
    char sign;
    int id;
    int currentlyInside=0;
    int maxInside=0;
    bool isInside[1000001];
    memset(isInside,false,sizeof(isInside));
    for(;n;--n)
    {
        cin&gt;&gt;sign&gt;&gt;id;
        if(sign=='+')
        {
            isInside[id]=true;
            maxInside=max(maxInside,++currentlyInside);
        }
        else
        {
            if(!isInside[id])
                ++maxInside;
            else
            {
                isInside[id]=false;
                --currentlyInside;
            }
        }
    }
    cout&lt;&lt;maxInside;
[/code]

<h1>C - Geometric Progression</h1>
<a href="http://codeforces.com/problemset/problem/567/C">Линк до задачата</a>

Еве уште еден индикатор дека континуирано решавање на задачи на сите страни вреди многу и дека евентуално ќе сретнете задачи кои се повторуваат. Задачава е многу слична на задачата COW од <a href="https://aandevski.wordpress.com/2015/02/23/usaco-february-contest/">Фебруарскиот USACO натпревар</a>, со единствена разлика што во задачата COW се бараа буквите C, O и W во правилен редослед додека тука ги бараме броевите x, x*k, x*k*k, за било кој број x.

Идејата е иста: забележуваме колку пати бројот се појавил како прв член од некоја прогресија и како втор член од некоја прогресија. При тоа, бројот x секогаш може да е прв член од некоја прогресија, но може да е втор член само доколку тој број е делив со k и пред него се појавил бројот x/k барем еднаш. Разгледајте го решението на задачата COW за да ја сфатите подетално идејата.

[code language="cpp"]
    int n,k;
    scanf(&quot;%d%d&quot;,&amp;n,&amp;k);
    int temp;
    long long result=0;
    map&lt;int, long long&gt; appearedOnce;
    map&lt;int, long long&gt; appearedTwice;
    for(int i=0;i&lt;n;++i)
    {
        scanf(&quot;%d&quot;,&amp;temp);
        if(temp%k==0)
        {
            result+=appearedTwice[temp/k];
            appearedTwice[temp]+=appearedOnce[temp/k];
        }
        appearedOnce[temp]++;
    }

    printf(&quot;%I64d&quot;,result);
[/code]

<h1>D - One-Dimensional Battle Ships</h1>
<a href="http://codeforces.com/problemset/problem/567/D">Линк до задачата</a>

Задачава има неколкумина можни решенија, од кои успеав да најдам две доста интересни решенија со binary search. Но првин да ги разгледаме правилата на играта.

Исто како во првата задача, имаме дадено еднодимензионално поле со должина N. На тоа поле првиот играч постава K бродови со должина A, така да два брода не смеат да се допрат (што не приметив додека траеше натпреварот). Вториот играч, не знаејќи ги позициите на бродовите, потоа треба да „пука“, т.е. да проба да погоди на кои полиња се наоѓаат тие. Првиот играч е должен да ви каже "hit" доколку погодите некој брод. Во спротивно, ви кажува "miss". Проблемот со првиот играч во оваа задача е тоа што секогаш кажува "miss", дури и да погодите. Вашата задача е за дадени позиции на кои пукал вториот играч, да утврдите кога првиот играч сигурно лаже.

Можеме да сме сигурни дека првиот играч сигурно лаже само кога се погодени толку полиња така да веќе нема место да се наредат K бродови од должина A. Притоа треба да внимаваме, бидејќи не е исто да се погоди поле на почетокот од таблата и на средината од таблата. Сега, двете идеи за задачата:
<ul>
	<li>Чуваме сортиран вектор од непогодени сегменти (парови од два броја што означуваат почеток и крај на сегмент). На секое пукање ние го наоѓаме сегментот во кој е пукано, го бришеме и додаваме два нови сегменти како резултат на поделбата од пукањето. Со додатна променлива бележиме колку вкупно бродови можат да се постават на достапните сегменти. Секогаш кога одземаме сегмент, го одземаме и бројот на бродови што можат да се стават на тој сегмент. Кога додаваме нов сегмент, додаваме број на бродови што можат да се стават на тој сегмент. За сегмент кој почнува на позиција l и завршува на позиција r (вклучувајќи ги и тие две точки), можеме да поставиме вкупно (l+r+2) / (a+1) бродови. Binary search користиме кога го наоѓаме сегментот во кој е пукано.</li>
	<li>Правиме функција која за даден број на пукања (X) ќе ни каже дали може да се постават K брода на преостанатите полиња. Тоа можеме да го симулираме лесно така што ќе направиме низа од boolean со големина N, и првите X пукања ќе ги обележиме како false во низата (сите останати се true). Потоа, ја изминуваме низата од почеток до крај и броиме колку брода можеме да поставиме на greedy начин (секогаш ставаме најлево можно). Кога веќе имаме функција која ни кажува кој број на пукања е валиден, потребно е само со binary search да го пронајдеме најмалиот број на пукања каде што резултатот е false. Доколку по сите пукања резултатот од функцијата е true, значи одговорот е -1 (не можеме да докажеме дека првиот играч лаже).</li>
</ul>
Функцијата за проверка:

[code language="cpp"]
bool check(int s)
{
    bool board[200001];
    memset(board,true,sizeof(board));
    for(int i=0;i&lt;s;++i)
        board[shots[i]]=false;
    int placedShips=0;
    for(int i=1;i&lt;=n-a+1;++i)
    {
        bool canPlace=true;
        for(int j=i;j&lt;i+a;++j)
            if(!board[j])
            {
                i=j;
                canPlace=false;
                break;
            }
        if(canPlace)
        {
            ++placedShips;
            i+=a;
        }
    }
    if(placedShips&lt;k)
        return false;
    return true;
}
[/code]

Остатокот од решението (binary search):

[code language="cpp"]
    scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;k,&amp;a,&amp;m);

    for(int i=0;i&lt;m;++i)
        scanf(&quot;%d&quot;,&amp;shots[i]);

    if(check(m))
    {
        printf(&quot;%d&quot;,-1);
        return 0;
    }

    int lo,mid,hi;
    lo=1;
    hi=m;

    while(lo&lt;hi)
    {
        mid=(hi+lo)/2;
        if(!check(mid))
            hi=mid;
        else
            lo=mid+1;
    }

    printf(&quot;%d&quot;,hi);
[/code]
]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>167</wp:post_id>
  <wp:post_date>2015-08-08 15:33:30</wp:post_date>
  <wp:post_date_gmt>2015-08-08 13:33:30</wp:post_date_gmt>
  <wp:post_modified>2015-08-08 15:33:47</wp:post_modified>
  <wp:post_modified_gmt>2015-08-08 13:33:47</wp:post_modified_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>codeforces-round-pi</wp:post_name>
  <wp:status>publish</wp:status>
  <wp:post_parent>0</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>post</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <category domain="post_tag" nicename="ad-hoc"><![CDATA[Ad hoc]]></category>
  <category domain="post_tag" nicename="binary-search"><![CDATA[Binary Search]]></category>
  <category domain="category" nicename="codeforces"><![CDATA[codeforces]]></category>
  <wp:postmeta>
    <wp:meta_key>_publicize_job_id</wp:meta_key>
    <wp:meta_value><![CDATA[13527095616]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_edit_last</wp:meta_key>
    <wp:meta_value><![CDATA[55813594]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_rest_api_client_id</wp:meta_key>
    <wp:meta_value><![CDATA[-1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_rest_api_published</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
</item>
<item>
  <title>Dijkstra со priority queue</title>
  <link>https://aandevski.wordpress.com/2015/08/10/dijkstra-%d1%81%d0%be-priority-queue/</link>
  <pubDate>Mon, 10 Aug 2015 11:53:47 +0000</pubDate>
  <dc:creator>add1ctus</dc:creator>
  <guid isPermaLink="false">https://aandevski.wordpress.com/?p=173</guid>
  <description/>
  <content:encoded><![CDATA[Како што спомнав минатиот пост, алгоритмот на Dijkstra е (според мене) еден од основните алгоритми кој се користи за натпреварување. Најчесто научен како алгоритам со O(N<sup>2</sup>) сложеност, Dijkstra е перфектниот алгоритам за наоѓање на најкраткиот пат во граф со тежини од едно теме (изворот) кон сите други темиња во графот. Но што се случува кога N е многу голем број?

Последниот Codeforces натпревар имаше задача со граф од 100,000 темиња. O(N<sup>2</sup>) сложеност би резултирало во 10 билиони операции во најлош случај, што е премногу за да се изврши во 2 секунди. Во такви околности алгоритмот на Dijkstra можеме да го оптимизираме со priority queue, намалувајќи ја сложеноста на O(N*logN), што би резултирало во помалку до 2 милиона операции за истиот граф. Огромна разлика.

Во продолжение ќе ја разгледаме задачата и ќе објаснам како најлесно може да се искористи оваа оптимизација.<!--more-->

Предупредување : Ве очекува многу текст
<h1>E - President and Roads</h1>
<a href="http://codeforces.com/problemset/problem/567/E">Линк до задачата</a>

Се работи за држава со N градови, меѓусебно поврзани со M насочени врски, секоја со своја цена за патување, и се бара најефтиниот пат од градот S до градот T. По наоѓање на најефтиниот пат, потребно е да направите анализа за секоја врска, каде што има 3 избори:
<ul>
	<li>Врската мора да се искористи за најефтиниот пат од S до T, печатиме <strong>YES</strong></li>
	<li>Врската може да се искористи за најефтиниот пат од S до T ако и се намали цената (цената сепак да е позитивен број), печатиме, <strong>CAN X </strong>(каде X означува за колку треба да се намали цената)</li>
	<li>Врската не може да се искористи за најефтиниот пат од S до Т во никој случај, печатиме <strong>NO</strong></li>
</ul>
За разјаснување на задачата, да разгледаме еден тест пример:

[caption id="attachment_174" align="aligncenter" width="296"]<a href="https://aandevski.files.wordpress.com/2015/08/screenshot_12.png"><img class="size-full wp-image-174" src="https://aandevski.files.wordpress.com/2015/08/screenshot_12.png" alt="Пример граф каде го бараме најкраткиот пат од S до T" width="296" height="351" /></a> Пример граф каде го бараме најефтиниот пат од S до T[/caption]

Во овој граф имаме два избора за најефтиниот пат од S до T:
<ul>
	<li>S -&gt; B -&gt; C -&gt; E -&gt; T</li>
	<li>S -&gt; B -&gt; D -&gt; E -&gt; T</li>
</ul>
И до двата случаи врските S-&gt;B и E-&gt;T се користат, така да за нив одговорот е YES. За останатите:
<ul>
	<li>Доколку ја намалиме цената на B-&gt;C за 1 тогаш таа врска ќе се користи сигурно наместо B-&gt;D, исто и обратно, така да за нив печатиме CAN 1</li>
	<li>Доколку се намали цената на S-&gt;C за 2, тогаш најефтиниот пат ќе е S-&gt;C-&gt;E-&gt;T, така да печатиме CAN 2</li>
	<li>Доколку ја намалиме цената на C-&gt;E за 1 тогаш таа врска ќе се користи сигурно наместо D-&gt;E, исто и обратно, така да за нив печатиме CAN 1</li>
</ul>
<h1>Како би ја решиле оваа задача?</h1>
Доколку би го пуштиле алгоритмот на Dijkstra од S кон T, тогаш би го добиле најефтиниот пат. Но тогаш при анализата на секоја врска не можеме да бидеме сигурни дали единствениот најефтин пат минува низ неа. Како решение на овој проблем можеме да направиме модификација на начинот на реконструкција на патот. Наместо користење на една променлива source за секое теме, можеме да користиме вектор кој ќе е способен да покаже повеќе од еден најефтин пат (доколку имаат иста должина). Додатно, би можеле да чуваме променлива paths за секое теме што означува колку различни најефтини патови имаме.

Иако со тоа би знаеле низ кои темиња поминува најефтиниот пат, проблемот доаѓа во печатење на резултатот. Во задачата се бара да ги изминуваме врските една по една во редоследот во кој се внесени и за секоја да го печатиме резултатот. На овој начин тоа не е можно (или многу е комплицирано). Затоа е потребен да направиме полесен начин со кој може да ги анализираме сите врски посебно.

Да се вратиме на примерот горе и да разгледаме од што се состои најефтиниот пат со било која врска. За пример може да земеме C-&gt;E. Доколку C-&gt;Е се содржи во најефтиниот пат, тогаш:

најефтин пат од S до C + цена C-&gt;E + најефтин пат од E до T

треба да е еднакво на најефтиниот пат од S до T. Додатно, за да утврдиме дали треба да печатиме YES, треба да сме сигурни дека сите најефтини патишта го користат C-&gt;E. Со други зборови, бројот на најефтини патови од S до T треба да е еднакво на:

број на најефтини патови од S до C + број на најефтини патови од E до Т

Доколку се задоволени тие два услови, тогаш со сигурност знаеме дека таа врска се користи секогаш и печатиме YES. Доколку само првиот услов е исполнет, тогаш потребно е да ја намалиме цената за 1 и со тоа патот да е најефтин. Доколку пак и двата услови не се исполнети, тогаш треба да ја намалиме цената на таа врска доволно за целиот пат да е поефтин од најефтиниот пат. Доколку не можеме толку да ја намалиме цената, печатиме NO.
<h1>Имплементација</h1>
Сега кога знаеме како се добива резултатот за секоја врска, потребно е да ги собереме податоците кои ни го даваат резултатот. Бидејќи бараме најефтин пат од S до сите темиња и од T до сите темиња, потребно е да пуштиме 2 пати Dijkstra, еднаш од двете темиња. Но бидејќи се работи за насочен граф, ќе мора да ги смениме насоките на сите врски за да го најдеме најкраткиот пат од T. За таа причина чувам два посебни графа, во две насоки. Додатно во 3 низи ги меморираме сите врски за да можеме да ги анализираме за резултатот. При внес на сите темиња им правам -1 за да започнуваат од 0 (глупа навика).

[code language="cpp"]
    int n,m,s,t; 
    scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;s,&amp;t);
    --s;
    --t;

    vector&lt;pair&lt;int, int&gt; &gt; graph[n]; 
    vector&lt;pair&lt;int, int&gt; &gt; invertedGraph[n];
    int from[m];
    int to[m];
    int weight[m];
    int a,b,c;
    for(int i=0;i&lt;m;++i)
    {
        scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);
        graph[--a].push_back(make_pair(--b,c));
        invertedGraph[b].push_back(make_pair(a,c));
        from[i]=a;
        to[i]=b;
        weight[i]=c;
    }
[/code]

Со завршување на внесот, следниот чекор е Dijkstra. Како што веќе објаснив, не можеме да користиме Dijkstra со O(N^2) сложеност заради големиот број на темиња во графот, така да мора да употребиме priority queue.

Priority queue е податочна структура која е цело време „сортирана“. Зошто наводници? Бидејќи таа не е во целост сортирана, туку само гарантира дека првиот елемент e најголемиот. Во оваа податочна структура вие можете само да пристапувате кон најголемиот елемент. Со други зборови, доколку имате priority queue со 100,000 броја, вие можете само да видите кој е најголемиот број. Исто така можете да го извадите најголемиот број од queue-от, при што вториот најголем број го завзема неговото место. Доколку ставите нов број, тој ќе е на врвот на queue-от само доколку е најголем. Во спротивно, тој ќе е изгубен некаде во остатокот од queue-от и нема да имате пристап до него се додека не извадите доволно броеви така да тој е најголем. Внесувањето на елементи се прави со O(log N) сложеност, но проверката на најголемиот број се прави со O(1) сложеност, додека вадењето на најголемиот број се прави со O(log N) сложеност.

Како можеме оваа податочна структура да ја искористиме во Dijkstra? Доколку го знаете алгоритмот, знаете дека при секоја итерација ние го бараме темето со најкраток пат кое веќе не е посетено. Стандардно тоа го правиме со линеарно изминување на сите темиња и барање на најблиското теме кое не е посетено, O(N) сложеност. Доколку за оваа акција искористиме priority queue, тогаш можеме многу побрзо да го наоѓаме темето кое треба следно да се посети, така да целиот алгоритам се намалува од O(N<sup>2</sup>) на O(NlogN).

Но рековме дека priority queue работи со традиционални променливи (кои можат да се споредуваат) и секогаш ја дава најголемата вредност, не најмалата. Така да потребно е да направиме наша посебна променлива (во вид на структура) на која ќе наместиме посебни правила за споредување, така да priority queue-от ќе ни го дава потребното теме. Ја правиме следнава структура:

[code language="cpp"]
struct el
{
    int to;
    long long weight;
    el(int a=0, long long b=0) //Конструктор за полесно внесување на темињата во PQ
    {
        to=a;
        weight=b;
    }
[/code]

Со ова имаме дефинирана структура, но фалат правилата за споредување. Потребно е да го преоптовариме операторот за споредување &lt;, со кој ќе дефинираме како ќе функционира priority queue-от.

[code language="cpp"]
    bool operator&lt;(const el &amp;a) const
    {
        return weight&gt;a.weight;
    }
};
[/code]

Со ова операторот &lt; го дефинираме да работи обратно од тоа што е наменето, така да priority queue-от сега ќе работи обратно (ќе ја наоѓа најмалата вредност наместо најголемата). Кога ова е спремно, можеме да започнеме со пишување на алгоритмот на Dijkstra. Бидејќи ни е потребен најефтиниот пат од две насоки, чуваме две низи: dist_s и dist_t. Исто така имаме две додатни низи paths_s и paths_t кои означуваат колку најефтини патишта постојат до секоја дестинација. За крај додаваме и низа visited која ќе ни е потребна за Dijkstra.

[code language="cpp"]
    long long dist_s[n];
    long long dist_t[n];
    long long paths_s[n];
    long long paths_t[n];
    bool visited[n];
    priority_queue&lt;el&gt; Q;

    for(int i=0;i&lt;n;++i)
    {
        dist_s[i]=dist_t[i]=99999999999999999;
        paths_s[i]=paths_t[i]=0;
        visited[i]=0;
    }
[/code]

За да пуштиме Dijkstra од S, потребно е да ги иницираме вредностите:

[code language="cpp"]
    dist_s[s]=0;
    paths_s[s]=1;
    Q.push(el(s,0));
[/code]

Наместо да броиме колку темиња сме веќе посетиле, може алгоритмот да ни работи додека има темиња во queue-от, така да условот за while циклусот ќе е while(!Q.empty()). Внатре во циклусот, со Q.top го добиваме минималниот елемент веднаш. Доколку тој елемент е веќе посетен, бараме нов од почеток. Во спротивно, го поставаме како посетен и ги менуваме далечините на сите негови соседни темиња (стандардна Dijkstra) со тоа што не забораваме да ги додаваме темињата во priority queue-от доколку најдеме најефтин пат. Исто така бидејќи бараме и број на најефтини патишта, проверуваме дали новиот пат што сме го пронашле е еднаков на патот кој веќе го знаеме, за да ја зголемиме променливата paths.

[code language="cpp"]
    while(!Q.empty())
    {
        int smallest=Q.top().to;
        Q.pop();

        if(visited[smallest])
            continue;

        visited[smallest]=true;

        for(int i=0;i&lt;graph[smallest].size();++i)
        {
            if(!visited[graph[smallest][i].first] &amp;&amp; dist_s[smallest] + graph[smallest][i].second &lt; dist_s[graph[smallest][i].first] )
            {
                dist_s[graph[smallest][i].first] = dist_s[smallest] + graph[smallest][i].second;
                paths_s[graph[smallest][i].first] = paths_s[smallest];
                Q.push(el(graph[smallest][i].first,dist_s[graph[smallest][i].first]));
            }
            else if(!visited[graph[smallest][i].first] &amp;&amp; dist_s[smallest] + graph[smallest][i].second == dist_s[graph[smallest][i].first])
            {
                paths_s[graph[smallest][i].first] += paths_s[smallest];
                paths_s[graph[smallest][i].first] %= MOD;
            }
        }
    }
[/code]

Променливата paths ја запишуваме по модул некој голем број (јас имав дефинирано MOD = 1000776999) бидејќи бројот на патишта може да го надмине ограничувањето на long long. Истото го правиме и за најефтиниот пат почнувајќи од T.

[code language="cpp"]
    memset(visited,false,sizeof(visited));
    dist_t[t]=0;
    paths_t[t]=1;
    Q=priority_queue&lt;el&gt;();
    Q.push(el(t,0));

    while(!Q.empty())
    {
        int smallest=Q.top().to;
        Q.pop();

        if(visited[smallest])
            continue;

        visited[smallest]=true;

        for(int i=0;i&lt;invertedGraph[smallest].size();++i)
        {
            if(!visited[invertedGraph[smallest][i].first] &amp;&amp; dist_t[smallest] + invertedGraph[smallest][i].second &lt; dist_t[invertedGraph[smallest][i].first] )
            {
                dist_t[invertedGraph[smallest][i].first] = dist_t[smallest] + invertedGraph[smallest][i].second;
                paths_t[invertedGraph[smallest][i].first] = paths_t[smallest];
                Q.push(el(invertedGraph[smallest][i].first,dist_t[invertedGraph[smallest][i].first]));
            }
            else if(!visited[invertedGraph[smallest][i].first] &amp;&amp; dist_t[smallest] + invertedGraph[smallest][i].second == dist_t[invertedGraph[smallest][i].first] )
            {
                paths_t[invertedGraph[smallest][i].first] += paths_t[smallest];
                paths_t[invertedGraph[smallest][i].first] %= MOD;
            }
        }
    }
[/code]

Се што преостанува е да ги провериме условите кои ги наведовме на почетокот на овој пост:

[code language="cpp"]
    for(int i=0;i&lt;m;++i)
    {
        long long current = weight[i] + dist_s[from[i]] + dist_t[to[i]];
        if(dist_s[t] == current)
        {
            if(paths_s[t] == (paths_s[from[i]] * paths_t[to[i]])%MOD)
                printf(&quot;YES\n&quot;);
            else if(weight[i]&gt;1)
                printf(&quot;CAN 1\n&quot;);
            else
                printf(&quot;NO\n&quot;);
        }
        else
        {
            if(current-(dist_s[t]-1)&lt;weight[i])
                printf(&quot;CAN %d\n&quot;,current-(dist_s[t]-1));
            else
                printf(&quot;NO\n&quot;);
        }
    }
[/code]

Со ова задачата е решена.]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>173</wp:post_id>
  <wp:post_date>2015-08-10 13:53:47</wp:post_date>
  <wp:post_date_gmt>2015-08-10 11:53:47</wp:post_date_gmt>
  <wp:post_modified>2015-08-10 13:53:47</wp:post_modified>
  <wp:post_modified_gmt>2015-08-10 11:53:47</wp:post_modified_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>dijkstra-%d1%81%d0%be-priority-queue</wp:post_name>
  <wp:status>publish</wp:status>
  <wp:post_parent>0</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>post</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <category domain="category" nicename="codeforces"><![CDATA[codeforces]]></category>
  <category domain="post_tag" nicename="dijkstra"><![CDATA[Dijkstra]]></category>
  <wp:postmeta>
    <wp:meta_key>_edit_last</wp:meta_key>
    <wp:meta_value><![CDATA[55813594]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>geo_public</wp:meta_key>
    <wp:meta_value><![CDATA[0]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_publicize_pending</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_publicize_job_id</wp:meta_key>
    <wp:meta_value><![CDATA[13585023239]]></wp:meta_value>
  </wp:postmeta>
</item>
<item>
  <title>Screenshot_12</title>
  <link>https://aandevski.wordpress.com/2015/08/10/dijkstra-%d1%81%d0%be-priority-queue/screenshot_12-2/</link>
  <pubDate>Sat, 08 Aug 2015 15:27:31 +0000</pubDate>
  <dc:creator>add1ctus</dc:creator>
  <guid isPermaLink="false">http://aandevski.files.wordpress.com/2015/08/screenshot_12.png</guid>
  <description/>
  <content:encoded><![CDATA[]]></content:encoded>
  <excerpt:encoded><![CDATA[Пример граф каде го бараме најкраткиот пат од S до T]]></excerpt:encoded>
  <wp:post_id>174</wp:post_id>
  <wp:post_date>2015-08-08 17:27:31</wp:post_date>
  <wp:post_date_gmt>2015-08-08 15:27:31</wp:post_date_gmt>
  <wp:post_modified>2015-08-08 17:27:52</wp:post_modified>
  <wp:post_modified_gmt>2015-08-08 15:27:52</wp:post_modified_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>screenshot_12-2</wp:post_name>
  <wp:status>inherit</wp:status>
  <wp:post_parent>173</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>attachment</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <wp:attachment_url>https://aandevski.files.wordpress.com/2015/08/screenshot_12.png</wp:attachment_url>
</item>
<item>
  <title>Codeforces Round #316</title>
  <link>https://aandevski.wordpress.com/2015/08/16/codeforces-round-316/</link>
  <pubDate>Sun, 16 Aug 2015 16:05:39 +0000</pubDate>
  <dc:creator>add1ctus</dc:creator>
  <guid isPermaLink="false">https://aandevski.wordpress.com/?p=177</guid>
  <description/>
  <content:encoded><![CDATA[Конечно назад во прва дивизија. Интересен натпревар со уште поинтересни задачи и многу хакирање. Успеав да ги решам првите 3 задачи и да извадам додатни 750 поени со хакирање што ме стави на 43-тото место, едно повисоко од мојот најдобар резултат (44-то). За жал покрај септемвриската испитна сесија немам време да ги решам останатите две задачи, така да на кратко само ќе ги објаснам првите 3 задачи кои ги решив. <!--more-->
<h1>A - Elections</h1>
<a href="http://codeforces.com/problemset/problem/570/A">Линк до задачата</a>

Ептен проста задача каде што само се бара да го имплементирате тоа што ви е објаснето. Потребно е да најдете најголем број во низа повеќе пати. Доколку има повеќе такви броеви, го земате оној со најмал индекс. Внимавајте на ограничувањата: постои тест пример каде сите кандидати во сите градови имаат 0 гласови. Во тој случај, првиот кандидат треба да е победник.

[code language="cpp"]
    int n,m,temp,biggest,biggestindex;
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    int votes[100];
    memset(votes,0,sizeof(votes));
    for(int i=0;i&lt;m;++i)
    {
        biggest=0;
        biggestindex=0;
        for(int j=0;j&lt;n;++j)
        {
            scanf(&quot;%d&quot;,&amp;temp);
            if(temp&gt;biggest)
            {
                biggest=temp;
                biggestindex=j;
            }
        }
        votes[biggestindex]++;
    }
    biggest=0;
    biggestindex=0;
    for(int i=0;i&lt;n;++i)
        if(votes[i]&gt;biggest)
        {
            biggest=votes[i];
            biggestindex=i;
        }
    printf(&quot;%d&quot;,biggestindex+1);
[/code]

<h1>B - Simple Game</h1>
<a href="http://codeforces.com/problemset/problem/570/B">Линк до задачата</a>

Мислам дека играта не е комплицирана за да ја разберете, така да ќе преминам веднаш на решението. Фактот дека вашиот противник ги добива сите броеви што се на еднакво растојание. Така да најдобра идеја е нашиот број да е претходник или следбеник на бројот на противникот. Ги проверуваме и двата случаи и бележиме кој број би ни дал повеќе поени и го избираме тој број. Специјален случај е каде N=1, при што и двата играчи го бираат истиот број.

[code language="cpp"]
    int n,m;
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    if(n==1 &amp;&amp; m==1)
        printf(&quot;1&quot;);
    else if(m-1&gt;=n-m)
       printf(&quot;%d&quot;,m-1);
    else
        printf(&quot;%d&quot;,m+1);
[/code]

<h1>C - Replacement</h1>
<a href="http://codeforces.com/problemset/problem/570/C">Линк до задачата</a>

Задачава на прв поглед многу ме потсети на задачата D од <a href="https://aandevski.wordpress.com/2015/08/08/codeforces-round-pi/">Codeforces #Pi натпреварот</a>. Но всушност се работи за многу попроста задача. За да провериме колку операции ќе се извршат за даден стринг, нема потреба за да ги заменуваме подстринговите туку доволно е само да изброиме колку точки се наоѓаат една до друга, т.е. колку пати „..“ стрингот се појавува.

[code language="cpp"]
    int n,m;
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    char s[n+1];
    scanf(&quot;%300001s&quot;,s);
    int totalOperations=0;

    for(int i=1;i&lt;n;++i)
        if(s[i]=='.' &amp;&amp; s[i-1]=='.')
            totalOperations++;
[/code]

Но со стринг од 300,000 букви и 300,000 операции, тој алгоритам би работел со O(N<sup>2</sup>) сложеност што е премногу. Клучната забелешка е што нема потреба целиот стринг да го проверуваме при секоја измена на буква, туку само буквите околу таа изменета буква. За секоја промена на буква, ги имаме следниве случаи:
<ul>
	<li>Буквата не е променета. На место каде што стоела точка е повторно ставена точка или на место каде што стоела буква е повторно ставена буква (може да е различна од претходната) - во овој случај го печатиме истиот резултат од претходно бидејќи тој не е сменет</li>
	<li>На место на буква е ставена точка - во овој случај проверуваме колку нови подстрингови „..“ сме добиле со оваа промена. Поточно, проверуваме дали на позициите -1 и +1 имаме точка. Го зголемуваме резултатот за секоја сретната точка.</li>
	<li>На место на точка е ставена буква - во овој случај го правиме обратното. Проверуваме колку подстрингови „..“ сме растуриле, така да го намалуваме резултатот за секоја сретната точка на позициите -1 и +1.</li>
</ul>
Потребно е само да внимавате да не излезете надвор од меморија при проверување на позициите +1 и -1.

[code language="cpp"]
    for(int i=0;i&lt;m;++i)
    {
        int position;
        char letter;
        scanf(&quot;%d %c&quot;,&amp;position,&amp;letter);
        if(!((letter!='.' &amp;&amp; s[position-1]!='.') || (letter=='.' &amp;&amp; s[position-1]=='.')))
        {
            s[position-1]=letter;
            if(letter=='.')
            {
                if(position-2&gt;=0 &amp;&amp; s[position-2]=='.')
                    totalOperations++;
                if(position&lt;n &amp;&amp; s[position]=='.')
                    totalOperations++;
            }
            else
            {
                if(position-2&gt;=0 &amp;&amp; s[position-2]=='.')
                    totalOperations--;
                if(position&lt;n &amp;&amp; s[position]=='.')
                    totalOperations--;
            }
        }
        printf(&quot;%d\n&quot;,totalOperations);
    }
[/code]

Доколку ве интересираат останатите задачи, мислам дека D се решава со дрва додека E се решава со динамичко. Веројатно ќе ги решам во септември откако ќе заврши испитната сесија.]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>177</wp:post_id>
  <wp:post_date>2015-08-16 18:05:39</wp:post_date>
  <wp:post_date_gmt>2015-08-16 16:05:39</wp:post_date_gmt>
  <wp:post_modified>2015-08-16 18:03:50</wp:post_modified>
  <wp:post_modified_gmt>2015-08-16 16:03:50</wp:post_modified_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>codeforces-round-316</wp:post_name>
  <wp:status>publish</wp:status>
  <wp:post_parent>0</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>post</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <category domain="category" nicename="%d0%b4%d1%80%d1%83%d0%b3%d0%be"><![CDATA[Друго]]></category>
  <wp:postmeta>
    <wp:meta_key>_rest_api_published</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_rest_api_client_id</wp:meta_key>
    <wp:meta_value><![CDATA[-1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_publicize_job_id</wp:meta_key>
    <wp:meta_value><![CDATA[13787141370]]></wp:meta_value>
  </wp:postmeta>
</item>
<item>
  <title>Предизвик по Веројатност и Статистика</title>
  <link>https://aandevski.wordpress.com/2015/12/10/%d0%bf%d1%80%d0%b5%d0%b4%d0%b8%d0%b7%d0%b2%d0%b8%d0%ba-%d0%bf%d0%be-%d0%b2%d0%b5%d1%80%d0%be%d1%98%d0%b0%d1%82%d0%bd%d0%be%d1%81%d1%82-%d0%b8-%d1%81%d1%82%d0%b0%d1%82%d0%b8%d1%81%d1%82%d0%b8%d0%ba/</link>
  <pubDate>Wed, 09 Dec 2015 23:39:40 +0000</pubDate>
  <dc:creator>add1ctus</dc:creator>
  <guid isPermaLink="false">https://aandevski.wordpress.com/?p=183</guid>
  <description/>
  <content:encoded><![CDATA[<i>За сите кои не слушаат веројатност / не студираат на ФИНКИ, се работи за <a href="http://mendo.mk/algoritmi/Task.do?competition=250&amp;id=604">оваа</a> задача (потребно е да се логирате на мендо)</i>

Да дефинираме состојба како даден момент во кој имаме проверено неколку компјутери и за нив знаеме која верзија ја имаат. Формално, состојба можеме да дефинираме како функција f(x,y) каде што x ни означува колку компјутери од тие што сме ги провериле ја имаат новата верзија а y ни означува колку компјутери од тие што сме ги провериле ја имаат старата верзија. За секоја дадена состојба f(x,y) знаеме дека имаме проверено вкупно x+y компјутери.<!--more-->

f(x,y) ќе ни означува уште колку компјутери се очекува да провериме кога веќе се наоѓаме во таа состојба. Решението на оваа задача се наоѓа во f(0,0), каде што немаме проверено ниту еден компјутер и треба да го пресметаме математичкото очекување на бројот на компјутери што мора да се проверат.

Како можеме да го пресметаме f(x,y)? (за случаите почнувајќи од вториот се претпоставува дека користиме else if)
<ol>
	<li>Доколку x+y = K, веќе сме ги провериле сите можни компјутери и нема веќе што да проверуваме, така да f(x,y) = 0 во тој случај.</li>
	<li>Доколку x = N-1, тогаш сите наредни компјутери мора да се со верзија y, бидејќи во спротивно не би биле пуштени K компјутери (асистентот би имал пуштено N компјутери од верзија x и би престанал). Така да f(x,y) = f(x,y+1)</li>
	<li>Доколку y = N-1, тогаш сите наредни компјутери мора да се со верзија x, бидејќи во спротивно не би биле пуштени K компјутери (асистентот би имал пуштено N компјутери од верзија y и би престанал). Така да f(x,y) = f(x+1,y)</li>
	<li>Доколку ни се потребни N компјутери со иста верзија да заврши проверувањето, значи има K-N пуштени компјутери од друга верзија (верзијата која нема да се користи).
Доколку x = K-N и y &gt; K-N, значи дека сите останати компјутери се со верзија y бидејќи во спротивно би имале повеќе од K-N пуштени компјутери од друга верзија. Така да f(x,y) = f(x,y+1)</li>
	<li>Доколку x &gt; K-N и y = K-N, значи дека сите останати компјутери се со верзија x бидејќи во спротивно би имале повеќе од K-N пуштени компјутери од друга верзија. Така да f(x,y) = f(x+1,y)</li>
	<li>Доколку ниту еден од горните случаи не е исполнет, тогаш мора да го проверме следниот компјутер, така да f(x,y) = 1 + (f(x+1,y) + f(x,y+1))/2</li>
</ol>
За да избегнеме пресметување на една состојба повеќе пати користиме меморизација. Пресметаните резултати ги меморизираме во матрица од дропки и пресметка правиме само доколку нема веќе внесено вредност во матрицата. Во најлош случај матрицата би била со големина (N+1)x(N+1), бидејќи не може да има повеќе од N компјутери со една верзија. Заради оптимизација, дропката ја скратуваме само еднаш на крај.

Решение: <a href="http://pastebin.com/PKphJMHw">http://pastebin.com/PKphJMHw</a>

Доколку обрнеме внимание на горенаведените случаи 2 и 3 и случаите 4 и 5 можеме да забележиме дека матрицата е симетрична. За секои x и y важи f(x,y) = f(y,x). Ова можеме да го искористиме како оптимизација така што ќе ограничиме x &gt;= y. Со ова нема да проверуваме една половина од матрицата. Додатно, бидејќи ќе имаме N компјутери со една верзија и K-N компјутери со друга верзија, матрицата може да е со големина (N+1) x (K-N+1).

Потребно е да ги отстраниме случаите 3 и 4 и исто така да направиме нова варијација на 6тото правило која не би дозволила да преминеме од другата страна на дијагоналата (каде што y &gt; x).
<ul>
	<li>Доколку x = y, тогаш f(x,y) = 1 + (f(x+1,y) + f(x+1,y))/2 = 1 + f(x+1,y)</li>
</ul>
Решение: <a href="http://pastebin.com/JrtxBfSE">http://pastebin.com/JrtxBfSE</a>

Дури и со оваа оптимизација решението користи многу меморија бидејќи имаме голем број на BigInteger променливи. Доколку го анализираме тест примерот со N = 7 и K = 9, матрицата би изгледала вака:

<a href="https://aandevski.files.wordpress.com/2015/12/d0b0.png" rel="attachment wp-att-184"><img class="size-full wp-image-184 alignleft" src="https://aandevski.files.wordpress.com/2015/12/d0b0.png" alt="а" width="207" height="484" /></a>

Доколку го искористиме фактот дека во матрицата имаме само собирање и делење со два можеме да забележиме дека сите именители на дропките се 2 на некој степен.

Матрицата можеме да ја претставиме на начин така што сите антидијагонали имаат исти именители. Во тој случај во матрицата наместо дропки би можеле да ги чуваме само именителите така што за секоја позиција според координатите можеме да провериме кој е именителот. Секоја антидијагонала можеме да ја претставиме преку бројот на компјутери проверени до тој момент.

Притоа секогаш кога на позиција x,y ставаме резултат од x+1,y или x,y+1, тој резултат го множиме со 2 бидејќи преминуваме во друга антидијагонала и ни се менува именителот.

Решение : <a href="http://pastebin.com/AHwSM5Yp">http://pastebin.com/AHwSM5Yp</a>

Слично на оптимизацијата на 0/1 Knapsack каде што користиме низа наместо матрица, можеме и тука да забележиме дека при пополнување на една антидијагонала ги користиме вредностите само од претходната антидијагонала (за x,y се користат само x+1,y и x,y+1). Така да би можеле да користиме само две низи за две антидијагонали: претходната антидијагонала и антидијагоналата што ја пополнуваме сега. Доколку низите ги пополнуваме во обратен редослед тогаш доволно е само една низа.

Во секоја антидијагонала Z (каде што Z = x+y), ги проверуваме само оние позиции кои спаѓаат во барем еден од случаите наведени погоре. За сите антидијагонали освен Z = 0, ги проверуваме сите x,y парови така што:
<ul>
	<li>x е помало или еднакво на N-1</li>
	<li>x e помало или еднакво на Z (значи y не е негативно)</li>
	<li>x &gt;= Z – x
<ul>
	<li>Доколку y го претставиме како Z – x, а бидејќи x мора да е поголемо или еднакво на y (заради симетријата објаснета погоре), x мора да е поголемо или еднакво на Z – x</li>
</ul>
</li>
</ul>
Решение: <a href="http://pastebin.com/4hxRMMa2">http://pastebin.com/4hxRMMa2</a>]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>183</wp:post_id>
  <wp:post_date>2015-12-10 01:39:40</wp:post_date>
  <wp:post_date_gmt>2015-12-09 23:39:40</wp:post_date_gmt>
  <wp:post_modified>2016-01-06 15:18:02</wp:post_modified>
  <wp:post_modified_gmt>2016-01-06 13:18:02</wp:post_modified_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>%d0%bf%d1%80%d0%b5%d0%b4%d0%b8%d0%b7%d0%b2%d0%b8%d0%ba-%d0%bf%d0%be-%d0%b2%d0%b5%d1%80%d0%be%d1%98%d0%b0%d1%82%d0%bd%d0%be%d1%81%d1%82-%d0%b8-%d1%81%d1%82%d0%b0%d1%82%d0%b8%d1%81%d1%82%d0%b8%d0%ba</wp:post_name>
  <wp:status>publish</wp:status>
  <wp:post_parent>0</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>post</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <category domain="category" nicename="%d0%b4%d1%80%d1%83%d0%b3%d0%be"><![CDATA[Друго]]></category>
  <wp:postmeta>
    <wp:meta_key>_edit_last</wp:meta_key>
    <wp:meta_value><![CDATA[55813594]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>geo_public</wp:meta_key>
    <wp:meta_value><![CDATA[0]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_publicize_job_id</wp:meta_key>
    <wp:meta_value><![CDATA[17643858501]]></wp:meta_value>
  </wp:postmeta>
</item>
<item>
  <title>а</title>
  <link>https://aandevski.wordpress.com/2015/12/10/%d0%bf%d1%80%d0%b5%d0%b4%d0%b8%d0%b7%d0%b2%d0%b8%d0%ba-%d0%bf%d0%be-%d0%b2%d0%b5%d1%80%d0%be%d1%98%d0%b0%d1%82%d0%bd%d0%be%d1%81%d1%82-%d0%b8-%d1%81%d1%82%d0%b0%d1%82%d0%b8%d1%81%d1%82%d0%b8%d0%ba/%d0%b0/</link>
  <pubDate>Wed, 09 Dec 2015 23:38:04 +0000</pubDate>
  <dc:creator>add1ctus</dc:creator>
  <guid isPermaLink="false">http://aandevski.files.wordpress.com/2015/12/d0b0.png</guid>
  <description/>
  <content:encoded><![CDATA[]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>184</wp:post_id>
  <wp:post_date>2015-12-10 01:38:04</wp:post_date>
  <wp:post_date_gmt>2015-12-09 23:38:04</wp:post_date_gmt>
  <wp:post_modified>2015-12-10 01:38:04</wp:post_modified>
  <wp:post_modified_gmt>2015-12-09 23:38:04</wp:post_modified_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>closed</wp:ping_status>
  <wp:post_name>%d0%b0</wp:post_name>
  <wp:status>inherit</wp:status>
  <wp:post_parent>183</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>attachment</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <wp:attachment_url>https://aandevski.files.wordpress.com/2015/12/d0b0.png</wp:attachment_url>
</item>
<item>
  <title>Тест за пракса во Microsoft</title>
  <link>https://aandevski.wordpress.com/2016/02/04/%d1%82%d0%b5%d1%81%d1%82-%d0%b7%d0%b0-%d0%bf%d1%80%d0%b0%d0%ba%d1%81%d0%b0-%d0%b2%d0%be-microsoft/</link>
  <pubDate>Wed, 03 Feb 2016 23:19:59 +0000</pubDate>
  <dc:creator>add1ctus</dc:creator>
  <guid isPermaLink="false">https://aandevski.wordpress.com/?p=190</guid>
  <description/>
  <content:encoded><![CDATA[Благодарение на <a href="http://www.bozidarevic.com/2011/05/utisci-sa-testa-za-praksu-u-microsoftu/">Ненад Божидаревиќ</a> (инаку и една од причините зошто го започнав овој блог) открив дека Microsoft имаат свои канцеларии во Белград, Србија, каде што работат на Microsoft Office пакетот, Bing и SQL Server. Уште поинтересно е тоа што нудат пракси за студенти во регионот, што е одлична прилика за било кој талентиран програмер што би сакал да работи како софтверски инженер.

Аплицирав за летна пракса со CV во кое има 0 работно искуство и само наброени натпревари на кои сум учествувал. Недела дена подоцна, добивам покана за тест каде што се поканети ~100 кандидати (некои од нив пријавени за full time работа, не за пракса). Во продолжение ќе ги наведам моите впечатоци од тестот.<!--more-->

Најпрвин, поканата, која стигна малку подоцна од очекувано. Поканите ги пратија едвај 6 дена пред самиот тест што не е идеално за кандидати кои не се од Србија. Додатно ми ги уништи и плановите за учествување на Global Game Jam, каде што веќе бев пријавен и имав купено карта. Вреди да се спомне дека дозволуваа решавање на тестот во некој друг термин доколку овој не ви одговара, но решив да идам заедно со сите наместо да ги комплицирам работите. Додатни пофалби за Microsoft бидејќи ги покриваат трошоците за пат доколку не сте од Белград (што се приближно 50 евра доколку се возите во пристојни автобуси и поаѓате од Скопје).

Сега, за тестот. Благодарение на блогот на Ненад (постот е линк-нат погоре) веќе имав прилично добра претстава за тоа што се случува таму. За разлика од било кој натпревар, тука немате никаков контакт со компјутер, туку од вас се очекува да пишувате код на лист со пенкало. Традиционално тестот се состоел од 7 задачи (од кои 5 алгоритамски и 2 математички) и имате 4 часа да ги решавате. Доколку прошетате низ коментарите на постот на Ненад можете да ги најдете скоро сите задачи што се паѓале од 2011 па наваму, што беше доста корисно за да знаеме што не чека сите таму.

Влегувајќи во математичката гимназија (таму се одржува тестот бидејќи не би можеле да организираат толкав број на кандидати во нивните канцеларии) ве прашуваат за вашето име, ве забележуваат на список и ви кажуваат во која просторија полагате и каде ќе е „свеченото“ отварање. Свечено во наводници бидејќи тоа се состоеше од влагање во хала каде што на кратко ни објаснија кои се правилата и како би изгледал тестот. Тоа што беше различно ова година е што математичките задачи беа исфрлени и имавме само 4 задачи за 3 часа.

<img class=" size-full wp-image-243 aligncenter" src="https://aandevski.files.wordpress.com/2016/02/1413572685_9531_600x0.jpg" alt="1413572685_9531_600x0" width="600" height="137" />

Краток говор од 5 минути и сите си влегуваме во своите простории каде што на секое место стои пенакло и куп празни листови. При влегување остававме јакни, ташни и било што друго што носевме со нас. За време на тестот ни беше дозволено да стануваме и излегуваме се додека не контактираме со било кој друг кандидат и не го напуштиме спратот. Во ходникот имаше огромен избор на сендвичи, колачи и пиење, за кое верувам дека ни половина не се потроши. Ни ги поделија задачите и започнавме со решавање.
<ol>
	<li>Имате дадени стрингови A и B од мали латинични букви. Од вас е потребно да најдете мапирање на буквите така што за секоја буква ја заменувате со некоја друга (или пак останува истата). Не можете една буква да ја замените со две различни (пример да ја замените 'a' со 'z' еднаш па 'a' со 'c' друг пат) и не може две букви да мапираат кон една (пример 'a' и 'c' да мапираат кон 'z'). Потребно е да направите функција која враќа true или false врз основа на тоа дали постои некакво мапирање за да се добие зборот B од зборот A.
<ul>
	<li>boats -&gt; teams : true</li>
	<li>boot -&gt; noon : false</li>
	<li>aab -&gt; ddp : true</li>
</ul>
</li>
	<li>За дадена низа од броеви да направите N-арно дрво (со било кое N) за кое што важи:
<ul>
	<li>Секој непарен број е внатрешен јазол во дрвото</li>
	<li>Секој парен број е лист на дрвото</li>
	<li>При изминување на дрвото во preorder треба да ја добиеме истата низа</li>
</ul>
</li>
	<li>Имате дадено низа со големина 2N. Потребно е да ја најдете должината на најкратката периода во таа низа. При тоа, периодата се повторува во низата комплетно (од почеток до крај, без да фали некој елемент или да има некој елемент вишок). Периода е некоја под-низа која се повторува во низата.
<ul>
	<li>2 4 2 4 2 4 2 4 : 2</li>
	<li>1 1 1 1 : 1</li>
	<li>2 3 1 3 2 3 1 3 : 4</li>
	<li>1 2 3 4 5 6 7 8 : 8</li>
</ul>
</li>
	<li>Имате дадено linked list од должина N каде што треба ефикасно да инвертирате дел од таа листа (кој се наоѓа измеѓу членовите A и B).
<ul>
	<li>q -&gt; e -&gt; t -&gt; r -&gt; 2, доколку се инвертира од втор до четврт член
q -&gt; r -&gt; t -&gt; e -&gt; 2</li>
</ul>
</li>
</ol>
За сите задачи имавте дадено како би требало да изгледа функцијата (името на функцијата, влезните параметри и што би требало да врати). Се бараше код во C, иако и јазици како C++, C# и Java беа признаени. Додатно се бараше да го документирате вашиот код што е можно подобро.

Иако не изгледаат толку тешко задачите, не беше лесно да се решаваат во таква околина. Постои притисокот да се смисли оптимален и паметен алгоритам, да се напише уреден код и истиот да се документира. Додатен проблем беше што мора целата функција да ја испланирате пред да почнете да пишувате било што, бидејќи за разлика од пишување на компјутер, тука не можете да бришете и било каква грешка во средина на кодот ќе ве натера да земете нов лист и почнете од почеток.

По тестот следи интервју каде што се повикани најдобрите кандидати од тестот (што се случува околу 2 недели по завршување на самиот тест). По селекција на интервју, кандидатите кои поминале добиваат платена пракса за 3 месеци.]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>190</wp:post_id>
  <wp:post_date>2016-02-04 01:19:59</wp:post_date>
  <wp:post_date_gmt>2016-02-03 23:19:59</wp:post_date_gmt>
  <wp:post_modified>2016-02-04 01:20:40</wp:post_modified>
  <wp:post_modified_gmt>2016-02-03 23:20:40</wp:post_modified_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>%d1%82%d0%b5%d1%81%d1%82-%d0%b7%d0%b0-%d0%bf%d1%80%d0%b0%d0%ba%d1%81%d0%b0-%d0%b2%d0%be-microsoft</wp:post_name>
  <wp:status>publish</wp:status>
  <wp:post_parent>0</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>post</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <category domain="category" nicename="%d0%b4%d1%80%d1%83%d0%b3%d0%be"><![CDATA[Друго]]></category>
  <category domain="post_tag" nicename="%d0%bf%d1%80%d0%b0%d0%ba%d1%81%d0%b0"><![CDATA[Пракса]]></category>
  <wp:postmeta>
    <wp:meta_key>_rest_api_published</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_rest_api_client_id</wp:meta_key>
    <wp:meta_value><![CDATA[-1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_publicize_job_id</wp:meta_key>
    <wp:meta_value><![CDATA[19439126864]]></wp:meta_value>
  </wp:postmeta>
</item>
<item>
  <title>1413572685_9531_600x0</title>
  <link>https://aandevski.wordpress.com/2016/02/04/%d1%82%d0%b5%d1%81%d1%82-%d0%b7%d0%b0-%d0%bf%d1%80%d0%b0%d0%ba%d1%81%d0%b0-%d0%b2%d0%be-microsoft/1413572685_9531_600x0/</link>
  <pubDate>Wed, 03 Feb 2016 23:19:24 +0000</pubDate>
  <dc:creator>add1ctus</dc:creator>
  <guid isPermaLink="false">http://aandevski.files.wordpress.com/2016/02/1413572685_9531_600x0.jpg</guid>
  <description/>
  <content:encoded><![CDATA[]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>243</wp:post_id>
  <wp:post_date>2016-02-04 01:19:24</wp:post_date>
  <wp:post_date_gmt>2016-02-03 23:19:24</wp:post_date_gmt>
  <wp:post_modified>2016-02-04 01:19:24</wp:post_modified>
  <wp:post_modified_gmt>2016-02-03 23:19:24</wp:post_modified_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>closed</wp:ping_status>
  <wp:post_name>1413572685_9531_600x0</wp:post_name>
  <wp:status>inherit</wp:status>
  <wp:post_parent>190</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>attachment</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <wp:attachment_url>https://aandevski.files.wordpress.com/2016/02/1413572685_9531_600x0.jpg</wp:attachment_url>
</item>
<item>
  <title>Мендо - Училишен натпревар 2016</title>
  <link>https://aandevski.wordpress.com/2016/02/21/%d0%bc%d0%b5%d0%bd%d0%b4%d0%be-%d1%83%d1%87%d0%b8%d0%bb%d0%b8%d1%88%d0%b5%d0%bd-%d0%bd%d0%b0%d1%82%d0%bf%d1%80%d0%b5%d0%b2%d0%b0%d1%80-2016/</link>
  <pubDate>Sat, 20 Feb 2016 23:36:30 +0000</pubDate>
  <dc:creator>add1ctus</dc:creator>
  <guid isPermaLink="false">https://aandevski.wordpress.com/?p=245</guid>
  <description/>
  <content:encoded><![CDATA[Бидејќи започнав традиција со минатогодишните натпревари, ќе продолжам и оваа година да постирам објаснувања за задачите од натпреварите на Мендо, повторно почнувајќи со училишниот натпревар.

По некоја слободна проценка би рекол дека овогодинешниов училишен натпревар беше полесен од оној лани, највеќе поради 5-тата задача која сега е делумно полесна (но бараше од вас да забележите нешто). Сепак имаше простор за грешка во другите задачи (посебно втора и трета) каде што погрешно сфаќање на задачата може да ви изгуби солиден број поени. Без да одолжувам повеќе, да преминам на самите задачи...<!--more-->
<h1>Гостин</h1>
<a href="http://mendo.mk/Task.do?id=607">Линк до задачата</a>

Задача која верувам дека е примарно наменета за учениците од основно образование и сите кои се нови во програмирањето. Од вас се бара да ги соберете двете пакетчиња, да ги поделите на два еднакви дела и резултатот да го помножите со 7. Заради самиот начин на кој работи делењето на цели броеви, нема потреба да се грижите за тоа дали може точно да се распределат сите бомбони (доколку има една вишок бомбона, таа ќе ја снема при делењето).

[code language="cpp"]
#include &lt;iostream&gt;

using namespace std;

int main()
{
    int x,y;
    cin&gt;&gt;x&gt;&gt;y;
    cout&lt;&lt;(x+y)/2*7;
    return 0;
}[/code]
<h1>Боење</h1>
<a href="http://mendo.mk/Task.do?id=611">Линк до задачата</a>

Прва задача која ќе почне да го тестира вашето алгоритамско размислување и ќе провери колку сте запознаени со сложеност на алгоритми. Најлесното решение би било да се измине целиот лист коцка по коцка и да се бројат сите бои. Но за ограничувања до 10<sup>6</sup> O(N*M) решение не е изводливо, така да се бара друга идеја.

Можеме најпрвин да ја разгледаме задачата за 1 ред коцки (почнувајќи со црвена коцка) и подоцна истото да го прошириме на повеќе редови кои би почнувале со разни бои. Да претпоставиме дека во редот имаме X коцки. Доколку X е деливо со 3, тогаш имаме X/3 црвени, X/3 жолти и X/3 зелени коцки во тој ред. Но што правиме доколку X не е деливо со 3? Имаме две можни ситуации: остатокот на X/3 да е 1 или 2. Доколку остатокот е 1, тогаш имаме уште една црвена коцка (вкупно X/3+1), а доколку остатокот е 2, тогаш имаме и црвена и жолта вишок коцка. Најпростиот начин да ги претставиме коцките во еден ред би бил:

[code language="cpp"]
    int crveniKocki = x/3;
    if(x % 3 &gt; 0)
        crveniKocki++;
    int zoltiKocki = x/3;
    if(x % 3 &gt; 1)
        zoltiKocki++;
    int zeleniKocki = x/3;
[/code]

Доколку сакате да заштедите на линии код, можете овие 3 променливи да ги претставите како (X+2)/3, (X+1)/3 и X/3.

Но што се случува доколку редот почнува со друга боја? Доколку редот би започнал со жолта боја, тогаш би имало (X+2)/3 жолти, (X+1)/3 зелени и X/3 црвени коцки. Исто, доколку би започнал со зелена боја, тогаш би имало (X+2)/3 зелени, (X+1)/3 црвени и X/3 жолти коцки (претпоставувам дека е јасно од каде доаѓа ова). Сега кога знаеме во кој ред колку коцки има, ни преостанува само да преброиме кој ред колку пати се појавува.

Ова го правиме со иста идеја. Доколку имаме Y редови, тогаш има (Y+2)/3 редови што започнуваат со црвена боја, (Y+1)/3 редови што започнуваат со жолта боја и Y/3 редови што започнуваат со зелена боја. Кога веќе знаеме кој ред колку пати се појавува и во секој од тие редови која боја колку пати се појавува, за крај само треба да ги помножиме тие броеви (број на редови * број на појавување на одредена боја во тој ред) и да ги собереме производите.

[code language="cpp"]
#include &lt;iostream&gt;

using namespace std;

int main()
{
    int x,y;
    cin&gt;&gt;x&gt;&gt;y;

    int prvaBoja = (x+2)/3;
    int vtoraBoja = (x+1)/3;
    int tretaBoja = x/3;
    int prvRed = (y+2)/3;
    int vtorRed = (y+1)/3;
    int tretRed = y/3;

    int crvena = prvRed*prvaBoja + vtorRed*tretaBoja + tretRed*vtoraBoja;
    int zolta = prvRed*vtoraBoja + vtorRed*prvaBoja + tretRed*tretaBoja;
    int zelena = prvRed*tretaBoja + vtorRed*vtoraBoja + tretRed*prvaBoja;

    cout&lt;&lt;crvena&lt;&lt;&quot; &quot;&lt;&lt;zolta&lt;&lt;&quot; &quot;&lt;&lt;zelena;

    return 0;
}[/code]
<h1>Аеродром</h1>
<a href="http://mendo.mk/Task.do?id=608">Линк до задачата</a>

За разлика од претходната задача, оваа е решлива со brute force пристап (и според мене е полесна од втората). Во најлош случај (кога времето на чекање е 23 часа и 59 минути) имаме помалку од 1500 состојби на часовникот што многу лесно би поминало за 1 секунда (всушност би поминало и за многу помалко од 0,1 секунди).

Ги внесуваме 4-те параметри во променливи h, m, fh, fm (каде што променливите што започнуваат со f го означуваат крајното време). И се додека овие две времиња се различни (или h е различно од fh или m е различно од fm (или и двете)), ги правиме следниве две работи:
<ul>
	<li>Проверуваме дали моменталното време (означено со h и m) е палиндром. Ова го правиме така што проверуваме дали првата цифра на h е еднаква со втората цифра на m и дали втората цифра на h е еднаква со првата цифра на m (се користи делење и модул со 10 за ова)</li>
	<li>Го зголемуваме времето за една минута. Доволно е само да го зголемиме бројот m за 1, и притоа доколку m стигне 60 го враќаме на 0 и зголемуваме h за 1. Истото го правиме и за h променливата, ставајќи ја на 0 доколку стигне до 24.</li>
</ul>
Едно нешто што не е спомнато во задачата е дека потребно е да го броите и времето на поаѓање на летот, така да по завршување на while циклусот потребна ни е уште една проверка.

[code language="cpp"]
#include &lt;iostream&gt;

using namespace std;

int main()
{
    int h,m,fh,fm;

    cin&gt;&gt;h&gt;&gt;m;
    cin&gt;&gt;fh&gt;&gt;fm;

    int rezultat = 0;

    while(h != fh || m != fm)
    {
        if(h%10 == m/10 &amp;&amp; h/10 == m%10)
            ++rezultat;

        ++m;
        if(m == 60)
        {
            m = 0;
            ++h;
        }
        if(h == 24)
            h = 0;
    }

    if(h%10 == m/10 &amp;&amp; h/10 == m%10)
        ++rezultat;

    cout&lt;&lt;rezultat;

    return 0;
}[/code]
<h1>Пакување подароци</h1>
<a href="http://mendo.mk/Task.do?id=609">Линк до задачата</a>

Уште една задача каде што O(N*M) решение не може да работи заради големите ограничувања. Доколку ја сортираме низата со кутии (сортирањето на една низа работи многу побрзо од проверување на сите парови) тогаш почнувајќи од почетокот на низата (од најмалата кутија), првата кутија која може да собере некој подарок е идеалната кутија за тој подарок (бидејќи сите кутии по неа ќе имаат поголема разлика). Со ова спречуваме проверка на парови кои не се оптимални според условот разликата во тежини да е минимална и преостанува да ја направиме оваа проверка за секој подарок.

Но доколку имаме случај со 100,000 кутии каде што сите се со капацитет 1 освен последната и сите подароци се потешки од 1 тогаш овој метод не ни заштедува ништо. За додатна оптимизација ќе ја сортираме и низата на подароци. За дадени подароци A и B така што знаеме дека B е потежок од A, знаеме дека сите кутии што не го собираат подарокот A сигурно нема да го соберат и подарокот B. Така да барањето за подарокот B наместо од почетокот на низата го правиме од кутијата во која го ставаме подарокот A.

Решението би било кога сортираните низи ги изминуваме во исто време (со два посебни бројачи) кои би покажувале кон еден подарок и една кутија. Имаме две можности:
<ul>
	<li>Подарокот го собира во кутијата. Во тој случај ја забележуваме разликата на овој пар (во една променлива памтиме минимална разлика и ја споредуваме) и го поместуваме бројачот на подароци</li>
	<li>Подарокот не го собира во кутијата. Во тој случај го поместуваме бројачот на кутии (ја бараме кутијата што ќе го собере нашиот подарок)</li>
</ul>
[caption id="attachment_314" align="alignnone" width="800"]<img class="alignnone size-full wp-image-314" src="https://aandevski.files.wordpress.com/2016/02/untitled-1.gif" alt="Untitled-1" width="800" height="400" /> Илустрација на алгоритмот[/caption]

Овој алгоритам прекинува кога ќе завршиме со изминување на било која низа (кога ќе снемаме или подароци или кутии). Во најлош случај ќе ги изминеме сите подароци и кутии, што е O(N+M) сложеност.

[code language="cpp"]
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

int main()
{
    int n,m;
    cin&gt;&gt;n;
    int podaroci[n];
    for(int i = 0 ; i &lt; n ; ++i)         cin&gt;&gt;podaroci[i];
    cin&gt;&gt;m;
    int kutii[m];
    for(int i = 0 ; i &lt; m ; ++i)         cin&gt;&gt;kutii[i];

    int minRazlika = 99999999;
    int rezultat = -1;

    sort(podaroci,podaroci+n);
    sort(kutii,kutii+m);

    int i = 0, j = 0;
    while(i &lt; n &amp;&amp; j &lt; m)
     {
         if(podaroci[i] &gt; kutii[j])
            ++j;
        else
        {
            if(kutii[j] - podaroci[i] &lt;= minRazlika)
            {
                minRazlika = kutii[j] - podaroci[i];
                rezultat = podaroci[i];
            }
            ++i;
        }
    }

    cout&lt;&lt;rezultat;

    return 0;
}[/code]
<h1>Телепатија</h1>
<a href="http://mendo.mk/Task.do?id=610">Линк до задачата</a>

Ќе бидам искрен, на прв поглед задачава ми изгледаше доста тешка. Но доволно е да ја размислите некое време (неколку минути во мој случај) и да најдете една забелешка што многу ја упростува задачата многу.

Првата идеја е задачава да ја претставиме како граф, каде што почетна позиција ни е (X,Y) и треба да стигнеме до позиција (EX,EY). Притоа од позиција (X,Y) во графот смееме да се движиме само кон позиции (X+1,Y-1) и (X-1-((2*X)%31), Y+1+((2*X)%31)). За да го постигнеме ова во минимален број на чекори (најкратко време) користиме BFS. Но проблемот е во сложеноста, со тоа што во графот имаме 10,000,000,000 можни позиции што би направил BFS да паѓа временски. Дури и да е огромен временскиот лимит, претставување на матриците за посетеност и далечина со таа големина би било невозможно.

Оптимизацијата се наоѓа во начинот на движење низ графот. Можете да забележите дека движењата се направени така што доколку едната променлива се зголеми за некој број тогаш другата променлива се намалува за истиот број. Според ова можеме да одредиме правило дека збирот X + Y ќе е константен, т.е. не можеме да го смениме преку тие две движења. Од ова можеме да го извлечеме заклучокот дека доколку X + Y е различно од EX + EY тогаш не постои начин да се стигне од една позиција од друга. Печатиме -1.

Сега бидејќи знаеме дека X + Y = EX + EY, тогаш знаеме дека доколку стигнеме во положба каде што X = EX тогаш со сигурност ќе мора и Y = EY. Значи само потребно ни е X вредноста да ја доведеме до EX во што помал број на чекори и нема воопшто потреба да внимаваме на Y променливата. Бројот на можни позиции ни се намалува на помалку од 100,000 што ја прави задачава лесна за BFS решение.

[code language="cpp"]
#include &lt;iostream&gt;
#include &lt;queue&gt;

using namespace std;

bool visited[100001];
int dist[100001];
queue&lt;int&gt; Q;

int main()
{
    int x,y,fx,fy;
    cin&gt;&gt;x&gt;&gt;y&gt;&gt;fx&gt;&gt;fy;
    if(x + y != fx + fy)
    {
        cout&lt;&lt;-1;
        return 0;
    }

    visited[x] = true;
    dist[x] = 0;
    Q.push(x);

    while(!visited[fx])
    {
        int curr = Q.front();
        Q.pop();

        int x1 = curr + 1;
        int x2 = curr - 1 - ((2*curr)%31);

        if(x1 &lt; 100001 &amp;&amp; !visited[x1])
         {
             visited[x1] = true;
             dist[x1] = dist[curr] + 1;
             Q.push(x1);
         }
         if(x2 &gt; 0 &amp;&amp; !visited[x2])
        {
            visited[x2] = true;
            dist[x2] = dist[curr] + 1;
            Q.push(x2);
        }
    }

    cout&lt;&lt;dist[fx];

    return 0;
}[/code]]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>245</wp:post_id>
  <wp:post_date>2016-02-21 01:36:30</wp:post_date>
  <wp:post_date_gmt>2016-02-20 23:36:30</wp:post_date_gmt>
  <wp:post_modified>2016-02-21 01:36:30</wp:post_modified>
  <wp:post_modified_gmt>2016-02-20 23:36:30</wp:post_modified_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>%d0%bc%d0%b5%d0%bd%d0%b4%d0%be-%d1%83%d1%87%d0%b8%d0%bb%d0%b8%d1%88%d0%b5%d0%bd-%d0%bd%d0%b0%d1%82%d0%bf%d1%80%d0%b5%d0%b2%d0%b0%d1%80-2016</wp:post_name>
  <wp:status>publish</wp:status>
  <wp:post_parent>0</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>post</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <category domain="post_tag" nicename="ad-hoc"><![CDATA[Ad hoc]]></category>
  <category domain="post_tag" nicename="bfs"><![CDATA[BFS]]></category>
  <category domain="post_tag" nicename="brute-force"><![CDATA[Brute force]]></category>
  <category domain="category" nicename="%d1%80%d0%b5%d1%88%d0%b5%d0%bd%d0%b8-%d0%b7%d0%b0%d0%b4%d0%b0%d1%87%d0%b8"><![CDATA[Решени задачи]]></category>
  <category domain="category" nicename="%d0%bc%d0%b5%d0%bd%d0%b4%d0%be"><![CDATA[мендо]]></category>
  <wp:postmeta>
    <wp:meta_key>_rest_api_published</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_rest_api_client_id</wp:meta_key>
    <wp:meta_value><![CDATA[-1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_publicize_job_id</wp:meta_key>
    <wp:meta_value><![CDATA[20010014631]]></wp:meta_value>
  </wp:postmeta>
  <wp:comment>
    <wp:comment_id>8</wp:comment_id>
    <wp:comment_author><![CDATA[filipd]]></wp:comment_author>
    <wp:comment_author_email>filipdimitrovski22@gmail.com</wp:comment_author_email>
    <wp:comment_author_url/>
    <wp:comment_author_IP>89.205.45.2</wp:comment_author_IP>
    <wp:comment_date>2016-02-27 13:42:08</wp:comment_date>
    <wp:comment_date_gmt>2016-02-27 11:42:08</wp:comment_date_gmt>
    <wp:comment_content><![CDATA[Odlichno objasneti zadachi!]]></wp:comment_content>
    <wp:comment_approved>1</wp:comment_approved>
    <wp:comment_type/>
    <wp:comment_parent>0</wp:comment_parent>
    <wp:comment_user_id>0</wp:comment_user_id>
    <wp:commentmeta>
      <wp:meta_key>akismet_history</wp:meta_key>
      <wp:meta_value><![CDATA[a:2:{s:4:"time";d:1456573329.3027179241180419921875;s:5:"event";s:9:"check-ham";}]]></wp:meta_value>
    </wp:commentmeta>
    <wp:commentmeta>
      <wp:meta_key>email_notification_notqueued</wp:meta_key>
      <wp:meta_value><![CDATA[1456573537]]></wp:meta_value>
    </wp:commentmeta>
    <wp:commentmeta>
      <wp:meta_key>jabber_published</wp:meta_key>
      <wp:meta_value><![CDATA[1456573537]]></wp:meta_value>
    </wp:commentmeta>
    <wp:commentmeta>
      <wp:meta_key>akismet_history</wp:meta_key>
      <wp:meta_value><![CDATA[a:3:{s:4:"time";d:1456573537.7043039798736572265625;s:5:"event";s:15:"status-approved";s:4:"user";s:8:"add1ctus";}]]></wp:meta_value>
    </wp:commentmeta>
    <wp:commentmeta>
      <wp:meta_key>akismet_result</wp:meta_key>
      <wp:meta_value><![CDATA[false]]></wp:meta_value>
    </wp:commentmeta>
  </wp:comment>
</item>
<item>
  <title>Untitled-1</title>
  <link>https://aandevski.wordpress.com/2016/02/21/%d0%bc%d0%b5%d0%bd%d0%b4%d0%be-%d1%83%d1%87%d0%b8%d0%bb%d0%b8%d1%88%d0%b5%d0%bd-%d0%bd%d0%b0%d1%82%d0%bf%d1%80%d0%b5%d0%b2%d0%b0%d1%80-2016/untitled-1-3/</link>
  <pubDate>Sat, 20 Feb 2016 23:20:56 +0000</pubDate>
  <dc:creator>add1ctus</dc:creator>
  <guid isPermaLink="false">http://aandevski.files.wordpress.com/2016/02/untitled-1.gif</guid>
  <description/>
  <content:encoded><![CDATA[]]></content:encoded>
  <excerpt:encoded><![CDATA[Илустрација на алгоритмот]]></excerpt:encoded>
  <wp:post_id>314</wp:post_id>
  <wp:post_date>2016-02-21 01:20:56</wp:post_date>
  <wp:post_date_gmt>2016-02-20 23:20:56</wp:post_date_gmt>
  <wp:post_modified>2016-02-21 01:21:06</wp:post_modified>
  <wp:post_modified_gmt>2016-02-20 23:21:06</wp:post_modified_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>closed</wp:ping_status>
  <wp:post_name>untitled-1-3</wp:post_name>
  <wp:status>inherit</wp:status>
  <wp:post_parent>245</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>attachment</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <wp:attachment_url>https://aandevski.files.wordpress.com/2016/02/untitled-1.gif</wp:attachment_url>
</item>
<item>
  <title>Алгоритми и сложеност - Шахистот Беџо</title>
  <link>https://aandevski.wordpress.com/2016/02/26/%d0%b0%d0%bb%d0%b3%d0%be%d1%80%d0%b8%d1%82%d0%bc%d0%b8-%d0%b8-%d1%81%d0%bb%d0%be%d0%b6%d0%b5%d0%bd%d0%be%d1%81%d1%82-%d1%88%d0%b0%d1%85%d0%b8%d1%81%d1%82%d0%be%d1%82-%d0%b1%d0%b5%d1%9f%d0%be/</link>
  <pubDate>Thu, 25 Feb 2016 22:07:33 +0000</pubDate>
  <dc:creator>add1ctus</dc:creator>
  <guid isPermaLink="false">https://aandevski.wordpress.com/?p=338</guid>
  <description/>
  <content:encoded><![CDATA[<a href="http://mendo.mk/algoritmi/Task.do?competition=258&amp;id=421">Задачава</a> ме мачи уште од националниот ACM натпревар кој беше одржан уште во септември, кога остана нерешена по повеќе од 10 погрешни решенија пратени од повеќе тимови. Уште од кога ја видов задачата на лабораториските вежби знаев дека е нерешлива за нас (фактот дека повторно не добив никаква идеја по скоро саат размислување го потврди тоа), но по доста гуглање и анализирање на решенија успеав да ја разберам идејата за да ја решам. <!--more-->
<h1>Оптимално решение</h1>
Грешката што ја правеа сите тимови на ACM е што пробувавме со greedy избор да го додадеме топот кој чини најмалку, што се испостави дека е погрешно. Решението се наоѓа на спротивна страна - бирање кој топ ќе го додадеме последен.

Идејата се базира околу фактот дека доколку А и B се двата топа кои се поставени најдалеку на таблата, тогаш во идеалниот редослед на поставување на топовите еден од овие топови ќе е последно поставен. Тоа можеме да го докажеме на следниов начин. Да претпоставиме дека во идеалниот редослед на поставување топот A е поставен пред топот B (A и B се двата најодалечени топови). Доколку топот B го ставиме на крајот на овој редослед, тогаш цената на секој топ што се наоѓал после B или би се намалила или би останала иста. Ова се забележува бидејќи за секој топ X што бил после B, доколку порано цената му била max(B, max од сите останати топови пред X) сега цената е само max од сите останати топови пред X. Исто така и цената на B не може да се зголеми, бидејќи во секој случај таа цена ќе е dist(A,B) (бидејќи A е пред B). Според ова заклучуваме дека за најодалечените топови A и B секогаш барем еден од нив ќе е последно додаден во низата.

Од ова лесно можеме да ја забележиме рекурентната релација на проблемов. Доколку имаме n топови означени со A1, A2, A3... An, при што (да претпоставиме дека) A1 и A2 се најодалечените топови, тогаш решение(A1, A2, A3... An) = min(решение(A2, A3... An), решение(A1, A3... An)). Бидејќи е очигледно дека потпроблемите ќе се повторуваат, решението се добива со динамичко програмирање.
<h1>Ротација</h1>
Да беше само толку од задачава, би била ептен лесна. Проблемот со горенаведеното решение е што немаме начин да претставиме такви состојби. Доколку состојбите би ги забележувале според тоа кои топови останале (како што е направено погоре), тогаш би имале 2^64 состојби, што не можеме да ги претставиме во меморија ниту да ги пресметаме во разумно време. Додатно би го имале и проблемот на проверување кои топови се најодалечени за секоја состојба, што би ја додатно зголемила сложеноста.

[caption id="attachment_390" align="alignleft" width="261"]<img class=" size-full wp-image-390 alignleft" src="https://aandevski.files.wordpress.com/2016/02/matrix1.jpg" alt="matrix" width="261" height="474" /> Горе: оргинална матрица, долу: ротирана матрица[/caption]

Наредната идеја е таа што ја упростува задачата доволно за да можеме да ја претставиме во помал број на состојби. Исто така е идејата што ретко на кого би му текнала (само 14 учесника од прва дивизија ја решиле задачава на Topcoder за време на натпревар). Доколку ја ротирате матрицата за 45 степени, задачава добива друга смисла.

&nbsp;

Како што можете да забележите од сликава, топовите кои беа најдалеку во оргиналната матрица (во спротивни агли од матрицата) сега се наоѓаат во ист ред или колона, но на два различни краја на матрицата. Ротацијава всушност ни овозможува многу лесно да го добиеме Manhattan растојанието помеѓу два топа. За топовите A(x1,y1) и B(x2,y2) растојанието е max(|x2-x1|, |y2-y1|)

Сега кога далечиниве ни се претставени вака, многу полесно можеме да го претставуваме динамичкото. Доколку на пример имаме топови во два спротивни агли (да кажеме првиот и последниот ред од новодобиената матрица), тогаш доколку го исфрлиме последниот ред од матрицата ние всушност сме го избршале последниот топ. Но што се случува доколку има повеќе топови во еден ред или колона што сакаме да ја избришеме? Во тој случај, можеме сите топови од тој ред да ги избришеме, бидејќи за сите знаеме дека ја имаат истата (максимална) далечина и евентуално сите би требало да ги избришеме едно по друго (во било кој редослед).

Ова ни помага значително, бидејќи сега состојбите ќе бидат сите можни под-матрици од матрицата наместо сите можни комбинации на топови. Бидејќи новата матрица ни е со големина 15х15, се работи за 15*15*15*15 =  50,625 можни состојби, за разлика од 2^64 состојби кои ги имавме со првата идеја.
<h1>Претставување на динамичкото</h1>
Решението го правам како top-down динамичко со меморизација, каде секоја состојба ни е претставена со 4 броеви: x1, y1 (почетокот на под-матрицата) и x2,y2 (крајот на под-матрицата). Притоа, доколку x1 == y1 и x2 == y2, тогаш сме стигнале до едно поле кое или ќе е празно, или ќе е топ кој се става со цена 0, така да во тој случај враќаме 0. Со ова го имаме зададено крајниот случај на рекурзијата.

Во спротивно, го наоѓаме парот на топови со најдолго растојание помеѓу нив и ги бришеме нивните редови или колони (во зависност од тоа според која димензија е најдолгото растојание). „Бришењето“ го правиме така што повикуваме нова рекурзија која не го вклучува тој ред или колона. Рекурзијата ја повикуваме и за двата топа и го бираме подобриот резултат. При тоа, на резултатот од рекурзијата го додаваме резултатот од додавањето на топот кој го „бришеме“.
<h1>Пишување на код</h1>
За почеток го читаме input-от кој можеме веднаш да го ротираме и да го запишеме во 15х15 матрица од boolean (каде што со true означуваме каде има топ). Исто така матрицата за меморизација на динамичко ја иницираме на -1. Тоа ќе ни ги означува состојбите за кои не сме пресметале резултат сеуште.

[code language="cpp"]
    memset(DP,-1,sizeof(DP));
    char input;
    for(int i = 0 ; i &lt; 8 ; ++i)
        for(int j = 0 ; j &lt; 8 ; ++j)
         {
             scanf(&quot; %c&quot;,&amp;input);
             if(input == '#')
                 rook[i+j][j-i+7] = true;
         }
 [/code]

Внатре во рекурзијата, прво што треба да провериме е дали сме стигнале до краен случај (1х1 матрица) или пак резултатот за некоја под-матрица е веќе пресметан. Доколку е потребно да направиме пресметка, тогаш резутлатот за таа под-матрица го иницираме на некоја голема вредност (за да можеме после со min да добиеме подобра вредност).

[code language="cpp"]
 int solve(int x1, int x2, int y1, int y2) {
     if(x1 == x2 &amp;&amp; y1 == y2)
         return DP[x1][x2][y1][y2] = 0;
     if(DP[x1][x2][y1][y2] != -1)
         return DP[x1][x2][y1][y2];
     DP[x1][x2][y1][y2] = 999999;
 [/code]

Пишуваме посебен код за одземање на ред/колона од сите 4 страни, со што повикуваме 4 нови рекурзии. Но бидејќи со секоја рекурзија одземаме по само еден ред/колона, потребно е да го направиме тоа за редот/колоната каде што би се наоѓал топот со најголема далечина. Затоа ги проверуваме разликите помеѓу x1,x2 и y1,y2 координатите. Доколку разликата помеѓу еден пар координати е поголема од разликата помеѓу друг пар координати, тогаш од таму би требало да одземаме редови/колони (заради веројатноста дека таму е најголемата разлика). Доколку разликата е еднаква, тогаш пробуваме да одземеме ред/колона од сите 4 страни. При одземање на страна, со for циклус проверуваме колку топови имало на страната што сме ја одземале и го додаваме тоа на резултатот од рекурзијата (додаваме колку би чинело да се додаде секој од тие топови, што е x2-x1 доколку далечината е хоризонтална или y2-y1 доколку далечината е вертикална.

[code language="cpp" firstline="7"]
    int sum;
 
    if(y2 - y1 &gt;= x2 - x1)
    {
        //Take top out
        sum = solve(x1,x2,y1+1,y2);
        for(int i = x1 ; i &lt;= x2 ; ++i)
            if(rook[i][y1])
                sum += y2-y1;
        DP[x1][x2][y1][y2] = min(DP[x1][x2][y1][y2], sum);
 
        //Take bot out
        sum = solve(x1,x2,y1,y2-1);
        for(int i = x1 ; i &lt;= x2 ; ++i)
            if(rook[i][y2])
                sum += y2-y1;
        DP[x1][x2][y1][y2] = min(DP[x1][x2][y1][y2], sum);
    }
 
    if(x2 - x1 &gt;= y2 - y1)
    {
        //Take left out
        sum = solve(x1+1,x2,y1,y2);
        for(int i = y1 ; i &lt;= y2 ; ++i)
            if(rook[x1][i])
                sum += x2-x1;
        DP[x1][x2][y1][y2] = min(DP[x1][x2][y1][y2], sum);
 
        //Take right out
        sum = solve(x1,x2-1,y1,y2);
        for(int i = y1 ; i &lt;= y2 ; ++i)
            if(rook[x2][i])
                sum += x2-x1;
        DP[x1][x2][y1][y2] = min(DP[x1][x2][y1][y2], sum);
    }
 
    return DP[x1][x2][y1][y2];
[/code]

Со оваа функција ја решаваме целата задача. Се што преостанува е да ја повикаме функцијата solve со параметри 0,14,0,14 (што ќе ја опфати целата матрица, инклузивно). <a href="http://pastebin.com/2qSKuM58">Линк</a> до комплетниот код]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>338</wp:post_id>
  <wp:post_date>2016-02-26 00:07:33</wp:post_date>
  <wp:post_date_gmt>2016-02-25 22:07:33</wp:post_date_gmt>
  <wp:post_modified>2016-02-26 00:07:33</wp:post_modified>
  <wp:post_modified_gmt>2016-02-25 22:07:33</wp:post_modified_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>%d0%b0%d0%bb%d0%b3%d0%be%d1%80%d0%b8%d1%82%d0%bc%d0%b8-%d0%b8-%d1%81%d0%bb%d0%be%d0%b6%d0%b5%d0%bd%d0%be%d1%81%d1%82-%d1%88%d0%b0%d1%85%d0%b8%d1%81%d1%82%d0%be%d1%82-%d0%b1%d0%b5%d1%9f%d0%be</wp:post_name>
  <wp:status>publish</wp:status>
  <wp:post_parent>0</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>post</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <category domain="post_tag" nicename="%d0%b4%d0%b8%d0%bd%d0%b0%d0%bc%d0%b8%d1%87%d0%ba%d0%be-%d0%bf%d1%80%d0%be%d0%b3%d1%80%d0%b0%d0%bc%d0%b8%d1%80%d0%b0%d1%9a%d0%b5"><![CDATA[Динамичко програмирање]]></category>
  <category domain="category" nicename="%d1%80%d0%b5%d1%88%d0%b5%d0%bd%d0%b8-%d0%b7%d0%b0%d0%b4%d0%b0%d1%87%d0%b8"><![CDATA[Решени задачи]]></category>
  <wp:postmeta>
    <wp:meta_key>_rest_api_published</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_rest_api_client_id</wp:meta_key>
    <wp:meta_value><![CDATA[-1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_publicize_job_id</wp:meta_key>
    <wp:meta_value><![CDATA[20178367961]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_last_editor_used_jetpack</wp:meta_key>
    <wp:meta_value><![CDATA[block-editor]]></wp:meta_value>
  </wp:postmeta>
</item>
<item>
  <title>matrix</title>
  <link>https://aandevski.wordpress.com/2016/02/26/%d0%b0%d0%bb%d0%b3%d0%be%d1%80%d0%b8%d1%82%d0%bc%d0%b8-%d0%b8-%d1%81%d0%bb%d0%be%d0%b6%d0%b5%d0%bd%d0%be%d1%81%d1%82-%d1%88%d0%b0%d1%85%d0%b8%d1%81%d1%82%d0%be%d1%82-%d0%b1%d0%b5%d1%9f%d0%be/matrix/</link>
  <pubDate>Thu, 25 Feb 2016 20:51:32 +0000</pubDate>
  <dc:creator>add1ctus</dc:creator>
  <guid isPermaLink="false">http://aandevski.files.wordpress.com/2016/02/matrix1.jpg</guid>
  <description/>
  <content:encoded><![CDATA[]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>390</wp:post_id>
  <wp:post_date>2016-02-25 22:51:32</wp:post_date>
  <wp:post_date_gmt>2016-02-25 20:51:32</wp:post_date_gmt>
  <wp:post_modified>2016-02-25 22:51:32</wp:post_modified>
  <wp:post_modified_gmt>2016-02-25 20:51:32</wp:post_modified_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>closed</wp:ping_status>
  <wp:post_name>matrix</wp:post_name>
  <wp:status>inherit</wp:status>
  <wp:post_parent>338</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>attachment</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <wp:attachment_url>https://aandevski.files.wordpress.com/2016/02/matrix1.jpg</wp:attachment_url>
</item>
<item>
  <title>Segment trees, lazy propagation</title>
  <link>https://aandevski.wordpress.com/2016/04/20/segment-trees-lazy-propagation/</link>
  <pubDate>Tue, 19 Apr 2016 22:22:14 +0000</pubDate>
  <dc:creator>add1ctus</dc:creator>
  <guid isPermaLink="false">https://aandevski.wordpress.com/?p=445</guid>
  <description/>
  <content:encoded><![CDATA[<blockquote>Ако има една структура што не ја знаете, а мора да ја научите, тоа е segment tree</blockquote>
За време на подготовките пред регионалниот ACM натпревар во Романија, ова беше муабетот што го слушнавме најмалку 5 пати во рок од саат време. Деновиве ја обработивме структурата по предметот алгоритми и сложеност, при што имав шанса да спремам неколку задачи за лабораториските вежби. Со тоа, би ја искористил шансава да направам поопширен пост за segment trees, кој би бил корисен и на тие што никогаш ја немаат сретнато оваа структура. Подоцна во постот ќе ги објаснам двете задачи кои ги спремив за лаб.<!--more-->
<h1>Мотивација</h1>
Пред да навлеземе во структурата, да го разгледаме проблемот кој таа го решава и да ја воочиме потребата за ваква структура. Да претпоставиме дека имаме низа од N броеви, и од нас ќе се бара да одговараме на барања во стилот „кој е збирот на броевите од x-тиот до y-тиот број“ или „кој е најмалиот број од x-тиот до y-тиот број“.

Најосновното решение би било пуштање на for циклус од x до y, проверувајќи / сумирајќи ги сите броеви, што би имало O(N) сложеност. Сите навлезени во динамичкото програмирање без проблем би се сетиле на Range Sum Query, каде што правиме низа со динамичко каде во DP[x] го чуваме збирот на броевите од 0-тиот до x-тиот број. Тогаш збирот од x до y е DP[y] - DP[x-1]. Ова бара една прекалкулација на низата DP во O(N) време, а секое барање се извршува во O(1).

Но што се случува кога сакаме да правиме промени во тек на извршувањето? Тогаш мораме да избереме еден од двата горенаведени начина: да имаме O(1) измени но O(N) барања или пак O(1) барања но O(N) прекалкулации при секоја измена. Бидејќи и двете се неефикасни (ако претпоставиме еднаков број на барања и измени), се појавува потреба за друга структура, која што може да изменува и извршува барања во оптимално време. Segment tree го прави тоа во O(logN).
<h1>Segment tree</h1>
Се работи за бинарно дрво кое во секоја точка чува информации за некој одреден сегмент. Во продолжетокот ќе давам примери за дрво кое дава сума на броеви во избран сегмент. Идејата на дрвото е дека во коренот ја имаме целата низа - збирот на сите броеви од 0 до N-1. Понатаму, за секоја точка дрвото го поделуваме на две еднакви половини, каде што тие точки чуваат збир за таа одредена половина. Ова се повторува се додека не стигнеме до точки што претставуваат само еден број од низата.

[caption id="attachment_470" align="aligncenter" width="843"]<img class=" size-full wp-image-470 aligncenter" src="https://aandevski.files.wordpress.com/2016/04/screenshot_37.png" alt="Screenshot_37" width="843" height="249" /> Пример за дрво направено на низа со 8 броеви: (0, 1, 2, 3, 4, 5, 6, 7)[/caption]

Во горниот пример со црвени букви ви е означено кој сегмент е покриен од страна на одредена точка во дрвото. Вкупно 2*N-1 точки се потребни да се претстави segment tree за низа со должина N. Бидејќи секоја точка треба да се измине еднаш, евидентно е дека времето за градење на вакво дрво е O(N).

Но како се извршуваат барањата и измените во ова дрво? Можеме да воочиме дека за некои сегменти веќе имаме пресметано резултати, така да доколку ни е потребен збирот на сегментот [4,7], можеме веднаш да вратиме 22. Но доколку сегментот не ни е претставен во дрвото како таков, тогаш мора да спојуваме повеќе сегменти. Така да на пример за барањето [3,5] ние би вратиле како резултат [3,3] + [4,5]. Бидејќи дрвото е балансирано (што ја прави неговата максимална длабочина logN), при што се посетуваат највеќе 2 точки од секое ниво (можете да го изгуглате доказот, нема до толку да навлегувам во ова), сложеноста на барањата е O(logN).

Измените ги правиме така што рекурзивно навлегуваме во дрвото се додека не стигнеме до листот. Кога стигнеме до листот, враќајки се назад ја изменуваме вредноста на сите точки што го имаат во нивниот сегмент бројот кој го изменуваме. Така да доколку би го смениле 3-тиот број, тогаш ќе ги смениме само точките кои ги содржат сегментите [3,3], [2,3], [0,3] и [0,7]. Бидејќи има logN вакви точки, сложенсота на измените исто така е O(logN).

За додатно разјаснување можете да го разгледате следниов <a href="http://visualgo.net/segmenttree.html">линк</a>.
<h1>Претставување во меморија, кодирање</h1>
Кога веќе ја разбравме идејата зад дрвото, сега преостанува да го имплементираме. Иако името наложува дека се работи за дрво, всушност оваа структура ја претставуваме во еднодимензионална низа со големина 2*2<sup>log<sub>2</sub>n</sup>-1. Но зошто оваа големина, кога веќе спомнавме дека ни се потребни само 2N-1 темиња во дрвото. Примерот што го прикажавме горе е со големина на низа степен на два, така да дрвото е комплетно. Но доколку земеме било кој друг број (на пример 10), ќе приметите дека некои темиња порано стигаат до листовите (едно ниво повисоко). Заради ова ни остануваат празни места во дрвото, така да мораме да дефинираме вишок променливи. Доколку ви е тешко да ја запомните формулава, најлесно е да правите 3*N низа за дрвото.

Дрвото е претставено во низата така што коренот се наоѓа на позиција 1. Децата на коренот се наоѓаат на позициите 2 и 3 (2*1 и 2*1+1). Оваа идеја се применува за сите останати точки. Децата на точката K се точките K*2 и K*2+1.

[caption id="attachment_492" align="aligncenter" width="850"]<img class=" size-full wp-image-492 aligncenter" src="https://aandevski.files.wordpress.com/2016/04/screenshot_38.png" alt="Screenshot_38" width="850" height="228" /> Редни броеви на точките на дрвото од претходниот пример[/caption]

Градењето на ова дрво се прави со функцијата build(l,r,p), каде што l го означува почетокот на сегментот, r го означува крајот на сегментот а p го означува редниот број на точката што го означува тој сегмент. Оваа функција се повикува со build(0,n-1,1) што ја става целата низа во коренот на дрвото. Понатаму вршиме рекурзивни повици со што се потполнува остатокот од дрвото. Рекурзиите се вршат се додека не стигнеме до лист на дрвото, каде што сегментот ни е само еден број, при што знаеме дека вредноста на тој сегмент е вредноста на самиот број.

[code language="cpp"]
int n;
int arr[100000];
int st[300000];

void build(int l = 0, int r = n - 1, int p = 1)
{
    if(l == r) //Доколку сегментот е само еден број, значи сме стигнале до лист
        st[p] = arr[l];
    else
    {
        build(l, (l+r)/2, p*2); //Го градиме левиот дел од дрвото
        build((l+r)/2+1, r, p*2+1); //Го градиме десниот дел од дрвото
        st[p] = st[p*2] + st[p*2+1]; //Го ставаме збирот на двата дела во точката
    }
}[/code]

За барањата имаме функција query(i,j,l,r,p), каде што l,r и p ни ја означуваат точката исто како претходната функција, додека i и j ни го означуваат сегментот кој сме го побарале. На пример доколку го сакаме збирот од 2 до 5, повикот би бил query(2,5,0,N-1,1). Рекурзивно го изминуваме дрвото се додека не стигнеме до состојба каде точката во која сме влегле е комплетно во сегментот или воопшто не е во сегментот. Доколку не се исполнети овие два услови, тогаш повикуваме рекурзија за двете половини на точката.

[code language="cpp"]
int query(int i, int j, int l = 0, int r = n - 1, int p = 1)
{
    if(i &gt; r || j &lt; l) //Бараниот сегмент не ја содржи точката p воопшто
        return 0;
    if(i &lt;= l &amp;&amp; r &lt;= j) //Бараниот сегмент целосно ја содржи точката p
        return st[p];
    return query(i, j, l, (l+r)/2, p*2) + query(i, j, (l+r)/2+1, r, p*2+1);
}[/code]

Преостанува функцијата за измени, update(index,value,l,r,p), со која во точката arr[index] ја ставаме вредноста value. l, r и p имаат исти значења повторно. Слично како build, повторно рекурзивно навлегуваме во дрвото се додека не стигнеме до листот, и од таму при враќање назад ја ажурираме вредноста на сите точки.

[code language="cpp"] void update(int index, int value, int l = 0, int r = n - 1, int p = 1)
{
     if(l == r) // Сме стигнале до листот, ја менуваме вредноста
         arr[l] = st[p] = value;
     else
     {
         if(index &gt; (l+r)/2) //Проверуваме дали бараниот елемент е во лева или десна половина
            update(index, value, (l+r)/2+1, r, p*2+1);
        else
            update(index, value, l, (l+r)/2, p*2);
        st[p] = st[p*2] + st[p*2+1];
    }
}[/code]
<h1>Lazy propagation, прва задача</h1>
Горенаведениот пример работи супер кога имаме барања за сегменти и правиме измени на само еден број. Но доколку би сакале да напраивме измена на некој сегмент (како во <a href="http://mendo.mk/algoritmi/Task.do?competition=268&amp;id=651">една од задачите</a> кои ги зададов за лабораториските вежби), тогаш би требало да ја повикаме функцијата update онолку пати колку што имаме броеви во сегментот. Со ова измените би биле O(NlogN), што воопшто не е оптимално. Со таа цел користиме lazy propagation, трик кој ни овозможува да правиме многу побрзи измени во дрвото.

Со иста големина како сегментното дрво чуваме нова низа lazy, која што меморира некои измени што треба да ги направиме, но уште не сме ги направиле. Зошто ни е потребно ова? Во сликите погоре, доколку би сакале да направиме измена на сегментот [0,3], тогаш би требало рекурзивно да влеземе и во точките [0,1], [2,3], [0,0], [1,1], [2,2] и [3,3] за да ја направиме измената секаде. Наместо да го правиме тоа, можеме за точките [0,1] и [2,3] да ја ставиме вредноста во lazy, и да ги измениме тие точки друг пат.

Доколку се прашувате зошто ги изменуваме тие точки, тоа се прави бидејќи во иднина можеби ќе провериме некој од тие под-сегменти. Доколку сме направиле измена на [0,3], тогаш можеби во иднина би направиле барање за сегментот [2,3], каде што измената мора да е одразена. Доколку измената сеуште не е направена, туку е само меморирана во lazy, тогаш при извршување на барањето ќе ја довршиме измената. Со ова измените ги правиме само доколку ни се потребни за барање, наместо да ги правиме секогаш. Бидејќи измените ги правиме во исто време со барањето, ова воопшто не ја зголемува сложеноста.

Кодот не е многу сменет. Во build функцијата доволно е да ја иницираме вредноста на lazy на 0, додека во query доволно е да го додадеме следниов код на почетокот на функцијата:

[code language="cpp"]
    if(lazy[p] &gt; 0) //Доколку треба да се направи некоја измена
    {
        st[p] += lazy[p] * (r - l + 1); //Има (r-l+1) точки во сегментот, сите ги зголемуваме за lazy[p]
        if(l != r) //Доколку сегментот има под-сегменти
        {
            lazy[p*2] += lazy[p]; //Додаваме lazy за под-сегментите
            lazy[p*2+1] += lazy[p];
        }
        lazy[p] = 0;
    }[/code]

Единствена функција која е поразлична е update функцијата, која сега треба да менува цели сегменти наместо само една точка. Прво во функцијата проверуваме дали има некои поранешни промени меморирани во lazy кои треба да ги извршиме. По тоа, ги правиме истите проверки како query (дали сегментот е комплетно во точката или пак целосно надвор од неа).

[code language="cpp"]
void update(int i, int j, int value, int l = 0, int r = n - 1, int p = 1)
{
    if(lazy[p] &gt; 0)
    {
        st[p] += lazy[p] * (r - l + 1);
        if(l != r)
        {
            lazy[p*2] += lazy[p];
            lazy[p*2+1] += lazy[p];
        }
        lazy[p] = 0;
    }
    if(i &gt; r || j &lt; l)
        return;
    if(i &lt;= l &amp;&amp; r &lt;= j)
    {
        st[p] += value * (r - l + 1);
        if(l != r)
        {
            lazy[p*2] += value;
            lazy[p*2+1] += value;
        }
    }
    else
    {
        update(i, j, value, l, (l+r)/2, p*2);
        update(i, j, value, (l+r)/2+1, r, p*2+1);
        st[p] = st[p*2] + st[p*2+1];
    }
} [/code]

Кога веќе имаме комплетно имплементиран код за segment tree со lazy propagation, останува само да го напишеме main-от кој ќе ја реши задачата.

[code language="cpp"] int main() {     cin&gt;&gt;n;
    for(int i = 0 ; i &lt; n ; ++i)         cin&gt;&gt;input[i];

    build();
    int queries;
    cin&gt;&gt;queries;
    for(int i = 0 ; i &lt; queries ; ++i)
    {
        char type;
        int l,r;
        cin&gt;&gt;type;
        if(type == 'U')
        {
            int l,r,amount;
            cin&gt;&gt;l&gt;&gt;r&gt;&gt;amount;
            update(l,r,amount);
        }
        else
        {
            int l,r;
            cin&gt;&gt;l&gt;&gt;r;
            cout&lt;&lt;query(l,r)&lt;&lt;&quot;\n&quot;;
        }
    }
    return 0;
}

[/code]
<h1>Истерување (втора задача)</h1>
<a href="http://mendo.mk/algoritmi/Task.do?competition=268&amp;id=652">Линк до задачата</a>

Клучна идеја за оваа задача е дека можеше да се претстави како низа од правоаголници, секој со ширина 1 и висина - гласност на фанот.

[caption id="attachment_541" align="aligncenter" width="397"]<img class=" size-full wp-image-541 aligncenter" src="https://aandevski.files.wordpress.com/2016/04/screenshot_39.png" alt="Screenshot_39" width="397" height="413" /> Тест пример: (2, 1, 5, 6, 2, 3)[/caption]

Кога вака ќе ги претставиме фановите, тогаш решението на задачата е плоштината на најголемиот правоаголник. Исфрлањето на фанови од лево и од десно е само друг начин за да се претстави фактот дека преостанатите фанови мора да седат еден до друг.

Идејата при решавање е divide and conquer, каде што почнуваме со сите фанови и во секој чекор го исфрламе најтивкиот фан (бидејќи доколку не го исфрлиме, само ќе го намалиме бројот на фанови а нивната гласност ќе остане иста). При исфрлање на некој фан може да добиеме две посебни групи на фанови (каде што само една ќе може да ја искористиме за резултатот на крај). Да разгледаме како би работело ова за примерот погоре.

На почетокот групата ги содржи сите фанови и нејзината гласност е 6 (6 фана * 1 гласност). Доколку го исфрлиме фанот со гласност 1, тогаш добиваме 2 групи: една со гласност 2 (1 фан * 2 гласност) и една со гласност 8 (4 фана * 2 гласност). Бидејќи првата група не можеме веќе да ја делиме, продолжуваме со втората. Доколку го исфрлиме фанот со гласност 2, тогаш добиваме две групи: една со гласност 10(2 фана * 5 гласност) и една со гласност 3 (1 фан * 3 гласност). Бидејќи втората не можеме да ја поделуваме, продолжуваме со првата. Го исфрламе фанот со гласност 5 и ни останува група со гласност 6 (1 фан * 6 гласност). Со ова веќе нема групи за поделба и сме го завршиле алгоритмот. Од сите групи кои сме ги направиле, забележуваме дека групата со гласност 10 е најгласната група, така да ја земаме таа вредност како резултат.

Во оваа задача можеме да искористиме segment tree за да можеме ефикасно да го наоѓаме најтивкиот фан во одредена група. Бидејќи во секоја итерација на овој алгоритам исфрламе по еден фан, можеме да заклучиме дека овој дел е O(N). Доколку би го барале најтивкиот фан помеѓу сите со for циклус, тогаш овој алгоритам би бил O(N^2), додека со segment tree овој алгоритам е O(NlogN).

Кога го имаме divide and conquer алгоритмот (кој исто е имплементиран рекурзивно), преостанува само да имплементираме segment tree (внимавајте, овој пат дрвото треба да ви го дава индексот на најтивкиот фан, не збирот на сегментот).

[code language="cpp"]
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

using namespace std;

int n;
int input[100000];
int st[300000];

void build(int l = 0, int r = n - 1, int p = 1)
{
    if(l == r)
    {
        st[p] = l;
        return;
    }
    build(l, (l+r)/2, p*2);
    build((l+r)/2+1, r, p*2+1);
    if(input[st[p*2]] &gt; input[st[p*2+1]])
        st[p] = st[p*2+1];
    else
        st[p] = st[p*2];
}

int query(int l, int r, int i = 0, int j = n - 1, int p = 1)
{
    if(l &gt; j || r &lt; i)
        return -1;
    if(l &lt;= i &amp;&amp; j &lt;= r)
        return st[p];

    int query1 = query(l, r, i, (i+j)/2, p*2);
    int query2 = query(l, r, (i+j)/2+1, j, p*2+1);

    if(query1 == -1)
        return query2;
    else if(query2 == -1)
        return query1;
    else if(input[query1] &gt; input[query2])
        return query2;
    else
        return query1;
}

int solve(int l = 0, int r = n - 1)
{
    int smallest = query(l, r);
    int solution = input[smallest] * (r - l + 1);

    if(smallest - 1 &gt;= l)
        solution = max(solution, solve(l, smallest - 1));
    if(smallest + 1 &lt;= r)
        solution = max(solution, solve(smallest + 1, r));

    return solution;
}

int main()
{
    scanf(&quot;%d&quot;,&amp;n);
    for(int i = 0 ; i &lt; n ; ++i)
        scanf(&quot;%d&quot;,&amp;input[i]);

    build();
    printf(&quot;%d&quot;,solve());

    return 0;
}
[/code]]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>445</wp:post_id>
  <wp:post_date>2016-04-20 00:22:14</wp:post_date>
  <wp:post_date_gmt>2016-04-19 22:22:14</wp:post_date_gmt>
  <wp:post_modified>2016-04-20 00:22:14</wp:post_modified>
  <wp:post_modified_gmt>2016-04-19 22:22:14</wp:post_modified_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>segment-trees-lazy-propagation</wp:post_name>
  <wp:status>publish</wp:status>
  <wp:post_parent>0</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>post</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <category domain="category" nicename="%d0%b4%d1%80%d1%83%d0%b3%d0%be"><![CDATA[Друго]]></category>
  <category domain="post_tag" nicename="segment-tree"><![CDATA[Segment tree]]></category>
  <wp:postmeta>
    <wp:meta_key>_rest_api_published</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_rest_api_client_id</wp:meta_key>
    <wp:meta_value><![CDATA[-1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_publicize_job_id</wp:meta_key>
    <wp:meta_value><![CDATA[21956872103]]></wp:meta_value>
  </wp:postmeta>
  <wp:comment>
    <wp:comment_id>11</wp:comment_id>
    <wp:comment_author><![CDATA[Bayern]]></wp:comment_author>
    <wp:comment_author_email>bmunichdd@gmail.com</wp:comment_author_email>
    <wp:comment_author_url/>
    <wp:comment_author_IP>89.185.219.201</wp:comment_author_IP>
    <wp:comment_date>2016-06-22 14:51:22</wp:comment_date>
    <wp:comment_date_gmt>2016-06-22 12:51:22</wp:comment_date_gmt>
    <wp:comment_content><![CDATA[Zosto si neaktiven]]></wp:comment_content>
    <wp:comment_approved>1</wp:comment_approved>
    <wp:comment_type/>
    <wp:comment_parent>0</wp:comment_parent>
    <wp:comment_user_id>0</wp:comment_user_id>
    <wp:commentmeta>
      <wp:meta_key>akismet_result</wp:meta_key>
      <wp:meta_value><![CDATA[false]]></wp:meta_value>
    </wp:commentmeta>
    <wp:commentmeta>
      <wp:meta_key>akismet_history</wp:meta_key>
      <wp:meta_value><![CDATA[a:2:{s:4:"time";d:1466599883.724668025970458984375;s:5:"event";s:9:"check-ham";}]]></wp:meta_value>
    </wp:commentmeta>
    <wp:commentmeta>
      <wp:meta_key>email_notification_notqueued</wp:meta_key>
      <wp:meta_value><![CDATA[1466676635]]></wp:meta_value>
    </wp:commentmeta>
    <wp:commentmeta>
      <wp:meta_key>akismet_history</wp:meta_key>
      <wp:meta_value><![CDATA[a:2:{s:4:"time";d:1466605006.75201702117919921875;s:5:"event";s:9:"check-ham";}]]></wp:meta_value>
    </wp:commentmeta>
    <wp:commentmeta>
      <wp:meta_key>jabber_published</wp:meta_key>
      <wp:meta_value><![CDATA[1466676635]]></wp:meta_value>
    </wp:commentmeta>
    <wp:commentmeta>
      <wp:meta_key>akismet_history</wp:meta_key>
      <wp:meta_value><![CDATA[a:3:{s:4:"time";d:1466676635.515943050384521484375;s:5:"event";s:15:"status-approved";s:4:"user";s:8:"add1ctus";}]]></wp:meta_value>
    </wp:commentmeta>
  </wp:comment>
  <wp:comment>
    <wp:comment_id>12</wp:comment_id>
    <wp:comment_author><![CDATA[Александар]]></wp:comment_author>
    <wp:comment_author_email>a.andevski@gmail.com</wp:comment_author_email>
    <wp:comment_author_url>http://add1ctus.wordpress.com</wp:comment_author_url>
    <wp:comment_author_IP>77.28.24.8</wp:comment_author_IP>
    <wp:comment_date>2016-06-23 12:11:20</wp:comment_date>
    <wp:comment_date_gmt>2016-06-23 10:11:20</wp:comment_date_gmt>
    <wp:comment_content><![CDATA[Проекти, испити, пракса... Немам решавано задачи на натпревари со месеци. Ќе пробам викендов да напишам нешто]]></wp:comment_content>
    <wp:comment_approved>1</wp:comment_approved>
    <wp:comment_type/>
    <wp:comment_parent>11</wp:comment_parent>
    <wp:comment_user_id>55813594</wp:comment_user_id>
    <wp:commentmeta>
      <wp:meta_key>jabber_published</wp:meta_key>
      <wp:meta_value><![CDATA[1466676680]]></wp:meta_value>
    </wp:commentmeta>
    <wp:commentmeta>
      <wp:meta_key>akismet_result</wp:meta_key>
      <wp:meta_value><![CDATA[false]]></wp:meta_value>
    </wp:commentmeta>
    <wp:commentmeta>
      <wp:meta_key>akismet_history</wp:meta_key>
      <wp:meta_value><![CDATA[a:3:{s:4:"time";d:1466676680.3936359882354736328125;s:5:"event";s:9:"check-ham";s:4:"user";s:8:"add1ctus";}]]></wp:meta_value>
    </wp:commentmeta>
    <wp:commentmeta>
      <wp:meta_key>email_notification_notqueued</wp:meta_key>
      <wp:meta_value><![CDATA[1466676680]]></wp:meta_value>
    </wp:commentmeta>
  </wp:comment>
</item>
<item>
  <title>Screenshot_37</title>
  <link>https://aandevski.wordpress.com/2016/04/20/segment-trees-lazy-propagation/screenshot_37/</link>
  <pubDate>Tue, 19 Apr 2016 21:04:39 +0000</pubDate>
  <dc:creator>add1ctus</dc:creator>
  <guid isPermaLink="false">http://aandevski.files.wordpress.com/2016/04/screenshot_37.png</guid>
  <description/>
  <content:encoded><![CDATA[]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>470</wp:post_id>
  <wp:post_date>2016-04-19 23:04:39</wp:post_date>
  <wp:post_date_gmt>2016-04-19 21:04:39</wp:post_date_gmt>
  <wp:post_modified>2016-04-19 23:04:39</wp:post_modified>
  <wp:post_modified_gmt>2016-04-19 21:04:39</wp:post_modified_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>closed</wp:ping_status>
  <wp:post_name>screenshot_37</wp:post_name>
  <wp:status>inherit</wp:status>
  <wp:post_parent>445</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>attachment</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <wp:attachment_url>https://aandevski.files.wordpress.com/2016/04/screenshot_37.png</wp:attachment_url>
</item>
<item>
  <title>Screenshot_38</title>
  <link>https://aandevski.wordpress.com/2016/04/20/segment-trees-lazy-propagation/screenshot_38/</link>
  <pubDate>Tue, 19 Apr 2016 21:24:47 +0000</pubDate>
  <dc:creator>add1ctus</dc:creator>
  <guid isPermaLink="false">http://aandevski.files.wordpress.com/2016/04/screenshot_38.png</guid>
  <description/>
  <content:encoded><![CDATA[]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>492</wp:post_id>
  <wp:post_date>2016-04-19 23:24:47</wp:post_date>
  <wp:post_date_gmt>2016-04-19 21:24:47</wp:post_date_gmt>
  <wp:post_modified>2016-04-19 23:24:47</wp:post_modified>
  <wp:post_modified_gmt>2016-04-19 21:24:47</wp:post_modified_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>closed</wp:ping_status>
  <wp:post_name>screenshot_38</wp:post_name>
  <wp:status>inherit</wp:status>
  <wp:post_parent>445</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>attachment</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <wp:attachment_url>https://aandevski.files.wordpress.com/2016/04/screenshot_38.png</wp:attachment_url>
</item>
<item>
  <title>NkAsV</title>
  <link>https://aandevski.wordpress.com/2016/04/20/segment-trees-lazy-propagation/nkasv/</link>
  <pubDate>Tue, 19 Apr 2016 22:06:51 +0000</pubDate>
  <dc:creator>add1ctus</dc:creator>
  <guid isPermaLink="false">http://aandevski.files.wordpress.com/2016/04/nkasv.png</guid>
  <description/>
  <content:encoded><![CDATA[]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>536</wp:post_id>
  <wp:post_date>2016-04-20 00:06:51</wp:post_date>
  <wp:post_date_gmt>2016-04-19 22:06:51</wp:post_date_gmt>
  <wp:post_modified>2016-04-20 00:06:51</wp:post_modified>
  <wp:post_modified_gmt>2016-04-19 22:06:51</wp:post_modified_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>closed</wp:ping_status>
  <wp:post_name>nkasv</wp:post_name>
  <wp:status>inherit</wp:status>
  <wp:post_parent>445</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>attachment</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <wp:attachment_url>https://aandevski.files.wordpress.com/2016/04/nkasv.png</wp:attachment_url>
</item>
<item>
  <title>Screenshot_39</title>
  <link>https://aandevski.wordpress.com/2016/04/20/segment-trees-lazy-propagation/screenshot_39/</link>
  <pubDate>Tue, 19 Apr 2016 22:08:23 +0000</pubDate>
  <dc:creator>add1ctus</dc:creator>
  <guid isPermaLink="false">http://aandevski.files.wordpress.com/2016/04/screenshot_39.png</guid>
  <description/>
  <content:encoded><![CDATA[]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>541</wp:post_id>
  <wp:post_date>2016-04-20 00:08:23</wp:post_date>
  <wp:post_date_gmt>2016-04-19 22:08:23</wp:post_date_gmt>
  <wp:post_modified>2016-04-20 00:08:23</wp:post_modified>
  <wp:post_modified_gmt>2016-04-19 22:08:23</wp:post_modified_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>closed</wp:ping_status>
  <wp:post_name>screenshot_39</wp:post_name>
  <wp:status>inherit</wp:status>
  <wp:post_parent>445</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>attachment</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <wp:attachment_url>https://aandevski.files.wordpress.com/2016/04/screenshot_39.png</wp:attachment_url>
</item>
  </channel>
</rss>

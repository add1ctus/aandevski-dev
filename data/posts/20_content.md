Изминатиот викенд се одржа првата рунда од квалификациите за годишниот CodeFu натпревар. Доста интересен натпревар со не многу тешки задачи, кој имаше 90 учесника (повеќето студенти, но исто така и по некој средношколец). Но и покрај тежината на задачите, успеав едвај да извадам 450 од 1500 поени за 25-тото место заради багови во две задачи (кои ме чинеа 550 поени и 20 места во пласманот). Ова е лекција за да ги тестирам повеќе задачите пред да праќам финални решенија следен пат. <!--more-->
<h1>100 - TableTennisScore</h1>
<a href="http://codefu.mk/codefu2015-round1.html?subpage=problem&problemid=2165">Линк до задачата</a>

Традиционално, првата задача се базира само на имплементација. Потребно е да се парсира стринг кој содржи резултати од пинг-понг, така да го испечатиме победникот и резултатот во партии. Потребни ни се две функции, една за претворање на `int` во `string` и уште една што го прави обратното:

```
int getnumber(string score)
{
    int result=0;
    for(int i=0;i<score.size();i++)
    {
        result*=10;
        result+=score[i]-'0';
    }
return result;
}
```


```
string getstring(int number)
{
    string result;
    while(number>0)
    {
        result+=(number%10)+'0';
        number/=10;
    }
    reverse(result.begin(),result.end());
    if(result=="")
        return "0";
    return result;
}
```

Се што преостанува е да ги употребиме овие функции за парсирање на стрингот. Тоа го правиме така што го изминуваме стрингот буква по буква и секоја буква ја ставаме во друг привремен стринг, се додека не сретнеме празно место. Кога сретнеме празно место или две точки тогаш ги обработуваме податоците што се внатре во привремениот стринг па потоа го празниме истиот стринг. Првин го правиме тоа за имињата, кои ги зачувуваме во два посебни стринга, па потоа до крај на стрингот ги парсираме резултатите. Но бидејќи резултатот го пресметуваме кога сретнеме празно место, додаваме на крајот на стрингот уште едно празно место за да се пресмета последниот меч.

```
string whoWon(string score)
{
    score+=' ';
    
    int parser=0;
    string parsed="";
    string names[2];
    int scores[2]={0};
    
    while(score[parser]!=' ')
        names[0]+=score[parser++];
        
    parser++;
    
    while(score[parser]!=' ')
        names[1]+=score[parser++];
        
    parser++;
    
    for(;parser<score.size();parser++)
    {
        int sc[2];
        if(score[parser]==':')
        {
            sc[0]=getnumber(parsed);
            parsed="";
        }
        else if(score[parser]==' ')
        {
            sc[1]=getnumber(parsed);
            if(sc[0]>sc[1])
                scores[0]++;
            else if(sc[1]>sc[0])
                scores[1]++;
            parsed="";
        }
        else
            parsed+=score[parser];
    }
    
    string result;
    
    if(scores[0]>scores[1])
        result=names[0]+' '+getstring(scores[0])+':'+getstring(scores[1]);
    else
        result=names[1]+' '+getstring(scores[1])+':'+getstring(scores[0]);
        
    return result;
}
```

## 200 - TheSubsequences

[Линк до задачата](http://codefu.mk/codefu2015-round1.html?subpage=problem&problemid=2166)

Доколку досега не знаевте, временскиот лимит на CodeFu е 5 секунди, што дава многу повеќе простор за brute force решенија. Токму тој факт, заедно со фактот дека треба да се изминат највеќе милион броеви ќе ги искористиме за решението на оваа задача. Потребна ни е функција која за два броја ќе проверува дали првиот е субсеквенца на вториот. При ова повикување, првиот број е секогаш поголемиот (измеѓу `А` и `B`), а вториот е помал (`C`). Тоа го правиме така што првиот број го делиме со 10 (ја отфрламе цифрата од десно) се додека последната цифра на првиот број е различна од последната цифра на вториот број. Кога последните цифри се исти, тогаш ги делиме и двата броја со 10. Ова се прави се додека еден од броевите не стигне до 0. Доколку првиот број стигне до 0, тогаш бројот не е субсеквенца. Доколку вториот број е 0, тогаш се работи за субсеквенца.

```
bool check(int A, int C)
{
    while(A>0 && C>0)
    {
        if(A%10==C%10)
            C/=10;
        A/=10;
    }
    return (C==0)?true:false;
}
```

Се што преостанува е да ги изминеме сите броеви од A до B и да провериме за колку броеви функцијата ќе врати true.

```
int count(int A, int B, int C)
{
    int result=0;
    for(;A<=B;A++)
        if(check(A,C))
            result++;
    return result;
}
```

# 300 - CandyCrush
[Линк до задачата](http://codefu.mk/codefu2015-round1.html?subpage=problem&problemid=2167)

Замислете ја низата како граф, каде што секое теме е поврзано со двете соседни темиња. Со BFS можеме да ја откриеме далечината до сите други темиња. Со `dist[x]` го означуваме времето потребно да се стигне до некое теме `x` од почетокот, а во `times[x]` го имаме времето кога тоа поле се руши. Тогаш некое поле можеме да посетиме (и да посетуваме други негови соседни полиња преку него) само доколку `times[x]>=dist[x]`. Во спротивно, тоа поле би било срушено и не може да се поминува низ него. Кога завршиме со посетување на сите можни полиња (притоа не посетуваме ниту едно поле два пати - користиме низа `boolean`), тогаш проверуваме кое е полето со најголемо `times[x]` кое е посетено, и го печатиме тој број.

```
#include <string>
#include <vector>
#include <queue>
#include <cstring>
using namespace std;

class CandyCrush
{
  public:
    int howLong(vector<int> times, int position)
    {
        queue<int> Q;
        int dist[times.size()];
        bool visited[times.size()];
        memset(visited,false,times.size());

        Q.push(position);
        visited[position]=true;
        dist[position]=1;

        int reachedmaximum=times[position];

        while(!Q.empty())
        {
            int current=Q.front();
            if(times[current]>reachedmaximum)
                reachedmaximum=times[current];
            Q.pop();
            if(current-1>=0 && !visited[current-1] && dist[current]+1<=times[current-1])
            {
                Q.push(current-1);
                dist[current-1]=dist[current]+1;
                visited[current-1]=true;
            }
            if(current+1<times.size() && !visited[current+1] && dist[current]+1<=times[current+1])
            {
                Q.push(current+1);
                dist[current+1]=dist[current]+1;
                visited[current+1]=true;
            }
        }

        return reachedmaximum;
  }
};
```


## 400 - EternalDiamonds

[Линк до задачата](http://codefu.mk/codefu2015-round1.html?subpage=problem&problemid=2168)

Интересна и предизвикувачка задача, која успеа да ми помине на сите 10 претест примери, но ми падна на сите останати 90 заради глупа грешка. Решението е top-down динамичко. Чуваме две матрици:

 * `int pole[202][202]`, каде што `pole[x][y]` ќе е 1 доколку има дијамант на тоа поле, 0 доколку нема, а -1 доколку има ѕид.
 * `int DP[202][202]`, каде што `DP[x][y]` го означува колку највеќе дијаманти може да се собере доколку го изберете оптималниот пат од точката `(0,0)` до точката `(x,y)`. Доколку не постои пат помеѓу `(0,0)` и `(x,y)`, тогаш `DP[x][y]` е -1

Матрицата DP ја иницираме со вредности -2. Зошто? Можеме да го искористиме ова, така што доколку `DP[x][y]` е различно од -2, тогаш знаеме дека сме го пресметале најдобриот пат за тоа поле и може да се искористи резултатот. Но доколку е -2, тогаш ова поле не било посетено и го наоѓаме најдобриот пат за тоа поле.

![Пример за мапа со големина 5](https://aandevski.files.wordpress.com/2015/04/screenshot_5.png)

Бидејќи се работи за top-down динамичко, тогаш решаваме од десно кон лево. Да ја разгледаме мапата со големина 5, која има 8 колони (што се добива со `size*2-2`) .Решението е во `DP[8][0]`. До точката `(8,0)` може да се стигне од две други точки (ова важи за сите точки), `(7,0)` и `(7,1)`. Проверуваме која од овие две точки има поголема вредност во `DP` матрицата, ја земаме поголемата вредност и додаваме `pole[8][0]`. Доколку и двете точки `DP[7][0]` и `DP[7][1]` се еднакви на -1, тогаш не постои пат од `(0,0)` до `(8,0)` (заради ѕидови). Истото се случува и рекурзивно: за точката `(7,0)` ги проверуваме точките `(6,0)` и `(6,1)`, а за точката `(7,1)` ги проверуваме точките `(6,1)` и `(6,2)`. При тоа, `(6,1)` само еднаш ќе го провериме, а за вториот пат ќе го имаме резултатот во `DP[6][1]`, и со тоа ќе спречиме вишок проверки.

![Пример за поделба на мапа со големина 5](https://aandevski.files.wordpress.com/2015/04/screenshot_6.png)

Мапата ја делиме на две половини, прикажано како на сликата. Едната половина е од колона 0 па до колона `size-1`, додека другата половина е од колона `size` до колона `size*2-2`, каде што `size` е големината на мапата. Зошто го правиме ова? Има две причини:

 * Да знаеме кон кои полиња треба да се движиме. Во левата половина, од точка `(x,y)` се движиме кон `(x-1,y)` и `(x-1,y+1)`, додека во десната половина се движиме кон `(x-1,y)` и `(x-1,y-1)`
 * Да знаеме колку полиња има во таа колона. Во левата половина, секоја колона `X` има `X` полиња, додека во десната половина, секоја колона има `2*size-X-1` полиња. Ова го користиме така да не искочиме надвор од границите (пример, во мапа со големина 5 не постои поле `5,4`, додека во мапа со големина 7 постои).

Правиме функција `solve`, која доколку `DP[x][y]==-2`, ќе ја пресмета вредноста на `DP[x][y]`. Во функцијата прво правиме две променливи:

 * `int best`, чија почетна вредност е -1. Во `best` го ставаме поголемиот број од двете точки од лево од точката `(x,y)` (на пример, доколку повикаме `solve(4,1)`, тогаш `best` ќе е поголемиот број од `DP[3][0]` и D`P[3][1]`.
 * `int verticalsize`, кој ќе означува колку полиња има во колоната `x-1` (за да знаеме да не излеземе надвор од границите. Оваа променлива добива вредност така што проверуваме во која половина се наоѓа колоната `x-1`, и ја добиваме вредноста со помош на горе наведените формули.

Се што преостанува е сега да ги провериме полињата од лево и да го вратиме поголемиот број како резултат. Едно од полињата лево ќе е секогаш `(x-1,y)`, освен кога тоа не постои (објаснето погоре). Проверуваме дали `y` е помало или еднакво на `verticalsize`, и доколку е, тогаш проверуваме дали има ѕид на тоа поле (дали `pole[x-1][y]==-1`). Доколку полето постои и нема ѕид, тогаш доколку `DP[x-1][y]==-2`, повикуваме `solve(x-1,y)`, а во спротивно го земаме резултатот од `DP[x-1][y]`.

Со ова ја имаме проверено едната насока на движење, останува другата. За таа, прво треба да провериме во која половина се наоѓаме (доколку сме во левата, се движиме кон `(x-1,y+1)`, во спротивно, кон `(x-1,y-1)`. Кога веќе знаеме кон кое поле треба да се движиме, ги правиме истите проверки напишани во претходниот параграф, и доколку добиениот резултат е поголем од `best`, тогаш го ставаме резултатот во `best`.

Се што преостанува е да се врати резултатот кој е `best` (најдоброт пат до `(x,y)`) `+ pole[x][y]`. При тоа, доколку `best==-1`, значи дека не постои пат од `(0,0)` до `(x,y)`, во кој случај враќаме -1. Резулатот исто така го запишуваме во `DP[x][y]`.

```
int solve(int x, int y)
{
    int best=-1;
    int verticalsize;
    
    if(x-1<sz)
        verticalsize=x-1;
    else
        verticalsize=sz*2-x-1;
    
    if(y<=verticalsize && dp[x-1][y]==-2 && pole[x-1][y]!=-1)
        best=solve(x-1,y);
    else if(y<=verticalsize && pole[x-1][y]!=-1)
        best=dp[x-1][y];
        
    if(x>=sz)
    {
        if(y+1<=verticalsize && dp[x-1][y+1]==-2 && pole[x-1][y+1]!=-1)
            best=max(best,solve(x-1,y+1));
        else if(y<=verticalsize && pole[x-1][y+1]!=-1)
            best=max(best,dp[x-1][y+1]);
    }
    else
    {
        if(y-1>=0 && dp[x-1][y-1]==-2 && pole[x-1][y-1]!=-1)
            best=max(best,solve(x-1,y-1));
        else if(y-1>=0 && pole[x-1][y-1]!=-1)
            best=max(best,dp[x-1][y-1]);
    }
    
    if(best==-1)
        dp[x][y]=-1;
    else
        dp[x][y]=best+pole[x][y];
        
    return dp[x][y];
}
```

Кога веќе знаеме како се добива решението, се што преостанува е да ги пополниме матриците со почетни вредности и да повикаме `solve(size*2-2,0)`. Матрицата `DP` има почетни вредности -2, додека матрицата pole има почетни вредности 0. Додатно, `DP[0][0]=0` (бидејќи никогаш нема дијамант на почетокот, и не мора да се проверува лево од `0,0`). Потребно е само во `pole` да се стави 1 каде има дијамант во мапата и -1 каде што има ѕид. Тоа го правиме на сличен начин како и со првата задача - парсираме стрингови. При тоа, ја користиме истата `getnumber` функција од првата задача.

```
int getMaxScore(int size, vector<string> diamonds, vector<string> walls)
{
    sz=size;
    for(int i=0;i<202;i++)
        for(int j=0;j<202;j++)
            dp[i][j]=-2;
    memset(pole,0,202*202);
    dp[0][0]=0;
    for(int i=0;i<diamonds.size();i++)
    {
        int parser=0;
        string parsed=";
        while(diamonds[i][parser]!=';')
            parsed+=diamonds[i][parser++];
        int x=getnumber(parsed);
        parser++;
        parsed=";
        while(parser<diamonds[i].size())
            parsed+=diamonds[i][parser++];
        int y=getnumber(parsed);
        pole[x][y]=1;
    }
    for(int i=0;i<walls.size();i++)
    {
        int parser=0;
        string parsed=";
        while(walls[i][parser]!=';')
            parsed+=walls[i][parser++];
        int x=getnumber(parsed);
        parsed=";
        parser++;
        while(walls[i][parser]!=';')
            parsed+=walls[i][parser++];
        int y1=getnumber(parsed);
        parsed=";
        parser++;
        while(parser<walls[i].size())
            parsed+=walls[i][parser++];
        int y2=getnumber(parsed);
        for(;y1<=y2;y1++)
        {
            pole[x][y1]=-1;
        }
    }
    return solve(size*2-2,0);
}
```

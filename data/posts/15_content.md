Се приближува државниот натпревар по програмирање, така да одлучив оваа недела да решам некои од (според мене) поинтересни задачи кои се паднале на претходните државни натпревари. Една од тие е задачата Код од државниот натпревар во 2009.

[Линк до задачата](http://mendo.mk/Task.do?id=21)

Бидејќи се работи за број со должина 250 цифри, читање на влезот како било каков тип на број отпада (најголемиот број што можеме да го прочитаме е 18-цифрен со `long long`), така да ни преостанува да го читаме бројот како низа од карактери или `string` (било кое би работело без проблеми).

Да го разгледаме пример стрингот, `25114`. Стрингот можеме да го прочитаме на следниве начини:
 * 2 5 1 1 4 - `BEAAD`
 * 2 5 1 14 - `BEAN`
 * 2 5 11 4 - `BEKD`
 * 25 1 1 4 - `YAAD`
 * 25 1 14 - `YAN`
 * 25 11 4 - `YKD`

Што можеме да приметиме од овој пример? Сите броеви во стрингот можеме да ги гледаме како едноцифрени броеви (освен доколку го имаме бројот 0, бидејќи нема буква еквивалент на 0). Но кога го гледаме бројот како двоцифрен број? Само доколку првата цифра е 1 или пак првата цифра е 2 но втората цифра е измеѓу 0 и 6.

Според ова би можеле да го изминеме стрингот линеарно, при тоа забележувајќи која цифра на колку начини може да се искористи. За секоја цифра гледаме дали може да се искористи како едноцифрен број и дали може да се искористи како втората цифра на двоцифрен број (со тоа што ја проверуваме и цифрата пред неа повторно). Бидејќи цифра пред првата нема, знаеме дека таа може само на еден начин да се брои и линеарното изминување го започнуваме од втората цифра.

Како на овој начин го добиваме резултатот? Правиме еднодимензионална низа од `integer`-и и ја пополнуваме со динамичко програмирање. `DP[x]` ќе ни означува на колку различни начини може да се декодира стрингот кој ги содржи сите цифри од првата до `x`-тата цифра во стрингот.

Така на пример за горниот пример

 * `DP[1] = 1` (2 може да се декодира само на еден начин)
 * `DP[2] = 2` (25 може да се декодира како : 25 или 2 5)
 * `DP[3] = 2` (251 може да се декодира како : 2 5 1 или 25 1)
 * `DP[4] = 4` (2511 може да се декодира како : 2 5 1 1, 25 1 1, 2 5 11 или 25 11)
 * `DP[5] = 6` (наброени се горе сите начини за декодирање на целиот стринг)

Низата ја пополнуваме со bottom-up пристап, почнувајќи од 2рата буква (бидејќи знаеме дека секогаш `DP[1] = 1` и `DP[0] = 1`). За `i`-тата буква од стрингот:

 * Доколку таа е различна од 0, тогаш `DP [i] += DP[i-1]`
 * Доколку таа може да се искористи како втора цифра на двоцифрен број, `DP [i] += DP[i-2]`

Но бидејќи стрингот ни е индексиран почнувајќи од 0, а низата со динамичко ја започнуваме од 1, мора на бројачот i да додаваме +1. Со тоа го добиваме овој код:

```
#include <iostream>
#include <string>

using namespace std;

int main()
{
    string input;
    cin>>input;
    int dp[251];
    dp[0]=dp[1]=1;
    for(int j=1;j<input.size();j++)
    {
        if(input[j]!='0')dp[j+1]=dp[j];
        if((input[j-1]=='1') || (input[j-1]=='2' && input[j]<='6'))dp[j+1]+=dp[j-1];
    }
    cout<<dp[input.size()];
    return 0;
}
```

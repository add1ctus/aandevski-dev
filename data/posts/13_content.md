Изминатава недела немаше многу натпревари. Освен CodeChef March Challenge и HackerRank Weekly Challenge (кои траеа помеѓу 5 и 10 дена), се одржа и првиот CodeFu натпревар за оваа година, Winter Seasonal. За оние кои не се запознаени со CodeFu, се работи за македонски натпревар наменет за студентите (но сепак отворен за сите). Има 3 онлајн натпревари годишно (Winter, Summer и Autumn seasonal), но исто така го има главниот CodeFu натпревар кој се состои од 2 онлајн квалификациони рунди и офлајн финале со најдобрите 32 натпреварувачи.

Натпреварот го започнав супер и успеав да пратам точно решение на првите 3 задачи во првите 15-20 минути од почетокот на натпреварот (веројатно како последица од учеството на TopCoder и Codeforces натпревари, каде што времето е клучно за добивање поени), пред било кој друг. Но нажалост тука и застанав, потрошувајќи ги следните час и половина поправајќи погрешни идеи за четвртата задача. Успеав да го добијам 18-тото место(кое го делев заедно со уште 6 учесника) од вкупно 62 учесника. Ова беа моите решенија на првите 3 задачи:

## 100 - LargestPart

[Линк до задачата](http://codefu.mk/codefu2015winter.html?subpage=problem&amp;problemid=2145)

Мислам дека станува збор за задача која не е потребно да се објаснува и е ставена за да ги тестира основните познавања од програмирање на натпреварувачот (ако земеме во обзир дека вакви задачи би се паѓале и на колоквиуми од прв семестар). Бидејќи секогаш имаме број на елементи во низа кој е делив со 3, потребно беше само да ги провериме збировите на елементите во низата од овие три интервали (доколку `N` е големината на низата, а низата ја индексираме од 0):

 * од 0 до `N/3-1`
 * од `N/3` до `N*2/3-1`
 * од `N*2/3` до `N-1`

Го чуваме збирот на сите 3 интервали во посебни променливи, и ги споредуваме. Враќаме резултат.

```
string getLargest(vector<int> array)
{
    int sum[3]={0,0,0};
    for(int i=0;i<array.size()/3;i++)
        sum[0]+=array[i];
    for(int i=array.size()/3;i<array.size()*2/3;i++)
        sum[1]+=array[i];
    for(int i=array.size()*2/3;i<array.size();i++)
        sum[2]+=array[i];
    if(sum[0]>sum[1] && sum[0]>sum[2])
        return "First";
    if(sum[1]>sum[0] && sum[1]>sum[2])
        return "Second";
    if(sum[2]>sum[1] && sum[2]>sum[0])
        return "Third";
    return "Ambiguous";
  }
```

## 200 - Backwards Compatible

[Линк до задачата](http://codefu.mk/codefu2015winter.html?subpage=problem&amp;problemid=2146)

За оваа задача веќе е потребно некое размислување. Клучната забелешка е ограничувањето на задачата. Со највеќе 50 лаптопи/полначи, не се потребни големи оптимизации за да ја решите задачата. Решението е greedy избор.

Да замислиме дека имаме 2 лаптопа, `A` и `B`, при што лаптопот `A` е понов лаптоп. Сите полначи кои што се компатибилни со лаптопот `B` се компатибилни и со лаптопот `A`, но обратното не важи. Така да за да ја решиме задачата почнуваме од најстарите лаптопи, што е всушност greedy изборот.

Доколку имаме повеќе полначи компатибилни со еден лаптоп, кој го избираме? Одговорот е било кој, а сега ќе видиме зошто. Да замислиме дека имаме полначи `A` и `B` кои се компатибилни со некој лаптоп `X`. Заради greedy изборот, ние сме сигурни дека лаптопот `X` е најстариот лаптоп кој го имаме (кој сеуште нема пронајдено полнач). Доколку и двата полначи `A` и `B` се компатибилни со `X`, тогаш тие се компатибилни со било кој друг лаптоп (бидејќи сите други лаптопи се понови од `X`), така да и да избереме било кој полнач, резултатот нема да се смени.

Фактот дека имаме 2 вектора наместо 2 низи ни ја прави оваа задача полесна. Наместо да внимаваме кои полначи сме ги веќе искористиле, можеме едноставно да ги избришеме од векторот. Така да почнувајќи од најстариот, за сите лаптопи еден по еден наоѓаме некој полнач и ги бришеме од векторот (дури и да не најдеме компатибилен полнач). При тоа, секогаш кога ќе најдеме компатибилен полнач, и него го бришеме од векторот на полначи. Задачата прекинува кога некој од векторите ќе е празен.

```
int countMaxMatches(vector<int> laptops, vector<int> chargers)
{
    int rez=0;
    sort(laptops.begin(),laptops.end());
    while(!laptops.empty() && !chargers.empty())
    {
        int currentlaptop=laptops[0];
        for(int i=0;i<chargers.size();i++)
            if(currentlaptop<=chargers[i])
            {
                rez++;
                chargers.erase(chargers.begin()+i);
                break;
            }
        laptops.erase(laptops.begin()+0);
    }
    return rez;
}
```

## 300 - Merging

[Линк до задачата](http://codefu.mk/codefu2015winter.html?subpage=problem&amp;problemid=2147)

Изненадно за мене, оваа задача беше помалку пати решена од 4тата задача, но беше значително полесна (веројатно текстот бил збунувачки за некои од натпреварувачите). Бидејќи станува збор за 50 компании, можеме да провериме за сите дали може нејзиното име да се искористи за главната компанија. Повторно се користи greedy за да ја направиме таа проверка.

Да го разгледаме првиот тест пример со компаниите 10, 7, 1, 3, 7 и 5. Прво нешто што можеме да заклучиме е дека компанијата со 10 вработени може да стане главна компанија така што сите други компании ги спојуваме со неа една по една. Но дали може другите компании да се искористат? Да ја земеме за пример компанијата 5, која може да стане главна на овој начин:

 * Ја спојуваме со компанијата 1. Сега има 6 вработени.
 * Ја спојуваме со компанијата 3. Сега има 9 вработени.
 * Ја спојуваме со компанијата 7. Сега има 16 вработени.
 * Ја спојуваме со компанијата 7. Сега има 23 вработени.
 * Ја спојуваме со компанијата 10. Има 33 вработени, веќе сите компании се споени во една.

Можете да приметите дека спојувањето се врши во растечки редослед (иако постојат и други редоследи кои би дале точен одговор). За некоја компанија `X` знаеме дека таа секогаш ќе остане со своето име доколку ја спојуваме со сите компании кои имаат помалку од `X` вработени. Така да за секоја компанија наместо да претпоставиме дека има `X` вработени на почетокот, можеме да претпоставиме дека има вработени колку збирот на сите компании помали од `X + X`.

Потоа ни преостанува да ги додаваме поголемите компании една по една, така што секогаш ја земаме најмалата достапна компанија. Доколку најмалата достапна компанија е поголема од нашата изберена компанија, тогаш знаеме дека не постои начин нашата изберена компанија да стане главна.

Бидејќи секогаш ја избираме најмалата компанија, можеме да ја сортираме низата и линеарно да ја изминуваме. Секогаш кога ќе стигнеме до крајот на низата (сме ги поминале сите компании), додаваме +1 на резултатот. Знаеме дека првата компанија нема никогаш да е главна (бидејќи нема помали компании од неа) и последната секогаш ќе е главна, така да тие две не мора да ги тестираме.

```
int countNames(vector<int> companies)
{
    sort(companies.begin(),companies.end());
    int rez=0;
    int sum[companies.size()];
    sum[0]=companies[0];
    for(int i=1;i<companies.size();i++)
        sum[i]=sum[i-1]+companies[i];
    for(int i=1;i<companies.size()-1;i++)
        {
            bool valid=true;
            int currentsum=sum[i];
            for(int j=i+1;j<companies.size();j++)
            {
                if(currentsum<=companies[j])
                    currentsum+=companies[j];
                else
                {
                    valid=false;
                    break;
                }
            }
            if(valid)
                rez++;
        }
    return rez;
}
```

Тоа беа решенијата на задачите кои успеав да ги решам на натпреварот. Ќе го надополнам постот со останатите 2 задачи кога/доколку успеам да ги решам.

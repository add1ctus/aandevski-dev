Напрвин збунувачка задача, но доста интересна. За сите кои имаат искуство со графови, брзо станува очигледно дека групите се добиваат со DFS. За сите кои немаат, веќе е крајно време да почнете да учите (посебно кога земете во предвид дека и регионалниот и државниот натпревар имаа DFS задача). Да ја разгледаме.

[Линк до задачата](http://mendo.mk/Task.do?id=545)

Имаме дадено две или повеќе групи на граѓани, и треба да го испечатиме бројот на начини за избирање на двајца кандидати така да тие се од различна група. Најпрвин, потребно е да можеме да одредиме кои граѓани се заедно во група.

![](https://aandevski.files.wordpress.com/2015/04/screenshot_12.png)

Да замислиме граф каде што темињата се граѓаните. Тие се поврзани само доколку имало телефонски разговор помеѓу нив. Иако можеби не е јасно од првото читање на задачата, доколку две граѓани се дел од ист сврзан подграф, тие се дел од иста група. На сликата имате прикажано пример за граф со 5 граѓани, каде што има телефонски повик меѓу граѓаните `A` и `B`, меѓу граѓаните `C` и `D` и меѓу граѓаните `D` и `E`. Тука граѓаните `A` и `B` прават еден сврзан подграф (една група), а граѓаните `C`, `D` и `Е` прават втор сврзан подграф (втора група).

Групите ги добиваме така што пуштаме DFS од секое непосетено теме. Сите темиња што ќе се посетат се од иста група. Така да доколку пуштите DFS од темето `C`, тоа ќе се прошири до темињата `D` и `E`, кои се дел од иста група. За ова изминување потребно ви е само да чувате низа од `boolean` која ќе означува кое теме е веќе посетено.

Но како да се претстави графот? Најлесниот начин е секако матрица на поврзаност, каде што `mat[a][b]` е 1 доколку темињата `a` и `b` се поврзани, и 0 во спротивно. Но во случај каде што имаме 100,000 граѓани, станува збор за матрица со големина од 10,000,000,000, која би зафаќала нешто над 9.3 гигабајти меморија. Но бидејќи има само 10,000 повици, тука можеме да употребиме вектор од вектори (или низа од вектори), каде што во векторот `graf[a]` ќе ги ставиме сите темиња кои се поврзани со темето `a`. Во најлош случај користиме 78 килобајти меморија, што е огромна разлика (и како додатна бенефиција - побрзо ќе работи DFS-то! ).

Сега кога веќе знаеме кои се групите, треба само да го добиеме резултатот. Доколку имаме две групи, тогаш знаеме дека бројот на различни комбинации на претставници е производот на бројот на членови во двете групи. Така за горниот пример имаме 2*3 = 6 комбинации, кои се:

 * `A` и `C`
 * `A` и `D`
 * `А` и `E`
 * `B` и `C`
 * `B` и `D`
 * `B` и `E`

Но што се случува кога имаме повеќе од две групи? Тогаш повеќе групи се спојуваат на различни начини за да добиеме 2 групи како резултат. На пример со 4 групи на граѓани, ги имаме следниве комбинации:

 * 1 / 2+3+4
 * 1+2 / 3+4
 * 1+2+3 / 4
 * 1+3 / 2+4
 * 1+3+4 / 2
 * 1+4 / 2+3
 * 1+2+4 / 3
 
Доколку ги проверуваме сите овие комбинации, ова може да трае повеќе време (бидејќи можеме да имаме 100,000 различни групи). Дури и кога би се правело ова побрзо, на овој начин би добиле многу дупликат кандидати, така да мора да се најде пооптимален начин. Клучната забелешка тука е дека доколку две темиња `A` и `B` не се во иста група, тогаш тие може да се изберат како претставници за обединетите нации најмалку еднаш (и како такви, треба да ги броиме). Можеме да го искористиме овој факт и гледајќи поопширно, така што за дадена група `X`, сите членови од `X` можат да бидат претставници заедно со било кој граѓанин што не е член на `X`. Според ова својство, на нас ни е само потребно да ги изминеме сите групи и да го забележиме бројот `grupa[i] * (brojNaGragjani - grupa[i])`. Збирот на овие броеви ќе ни го даде бројот на различни начини за бирање на два кандидата од различна група. Но бидејќи секој избор на кандидати ќе се претставува два пати (еднаш како `A` и `B`, еднаш како `B` и `A`), резултатот го делиме со 2.

```
#include <iostream>
#include <vector>
#include <cstring>

using namespace std;

vector<vector<int> > graf(100001);
bool poseteno[100001];
int goleminaNaGrupa;

void dfs(int n)
{
    poseteno[n]=true;
    goleminaNaGrupa++;
    for(int i=0;i<graf[n].size();i++)
        if(!poseteno[graf[n][i]])
            dfs(graf[n][i]);
}

int main()
{
    int n,i,a,b;
    cin>>n>>i;

    memset(poseteno,false,100001);

    for(;i;i--)
    {
        cin>>a>>b;
        graf[a].push_back(b);
        graf[b].push_back(a);
    }

    long long rezultat=0;

    for(int i=0;i<n;i++)
    {
        if(!poseteno[i])
        {
            goleminaNaGrupa=0;
            dfs(i);
            rezultat+=goleminaNaGrupa*(n-goleminaNaGrupa);
        }
    }

    rezultat/=2;
    cout<<rezultat;

    return 0;
}
```

*Note to self: Не ги потценувај задачите од училишни натпревари, читај и решавај внимателно*

Во споредба со тежината на првите 4 задачи (обични ad hoc задачки), оваа е значително потешка и бара знаење од динамичко програмирање (доколку не сте запознаени, можете да почнете од [тука](http://mendo.mk/wiki/attach/%D0%9C%D0%B0%D1%82%D0%B5%D1%80%D0%B8%D1%98%D0%B0%D0%BB%D0%B8%20%D0%97%D0%B0%20%D0%9F%D0%BE%D0%B4%D0%B3%D0%BE%D1%82%D0%BE%D0%B2%D0%BA%D0%B0/DinamickoProgramiranje1.pdf) - внимание, напредна материја!). 0-1 knapsack проблем, да бидам попрецизен. Бидејќи решението е доста поопширно, решив да го ставам во посебен пост наместо да го едитирам стариот.

Во [оваа задача](http://mendo.mk/Task.do?id=531) имаме дадено патека со должина `M` метри, на која што имаме поставени канделабри за осветлување. Канделабрите имаат 3 параметри:
 * `Xi` - Растојание од почетокот на патеката
 * `Ci` - Дневна потрошувачка во денари
 * `Ri` - Радиус на осветлување

Од вас се бара со буџет од `K` денари дневно да осветлите што поголем дел од патеката. Потребно е да се испечати должината на осветлениот пат и должината на најдолгиот сегмент од патот каде патеката не е осветлена.

Првото нешто кое може да ве збуни и да доведе до погрешни одговори доколку не го расчистите веднаш се вредностите со кои работиме. Се работи за далечини помеѓу две точки, кои ги претставуваме со затворени интервали (`[a,b]` значи дека е осветлен патот помеѓу точките `a` и `b`). За полесно решавање можеме да ја замислиме патеката како низа од полиња, сите долги по 1 метар.

![Пример за патека со должина 4](https://aandevski.files.wordpress.com/2015/02/untitled-1.png)

Од тука можеме да заклучиме дека секоја патека ги осветлува полињата од `Xi-Ri` до `Xi+Ri-1`, вклучувајќи ги и тие полиња. Но притоа, треба да внимаваме да не излеземе надвор од опсегот (да осветлиме полиња помали од 0 или пак поголеми од должината на патеката).

При првото читање на задачата не приметив дека осветлените делови од канделабрите нема никогаш да се поклопуваат, што ја правеше задачата многу потешка. Но, бидејќи во задачата нема да се поклопуваат две светла никогаш, тогаш единственото нешто што е потребно е да избереме кои канделабри ќе се пуштени а кои не, така да го максимизираме бројот на осветлени полиња. Бирање на канделабри со greedy пристап според односот `број на осветлени полиња/цена` нема да работи, како што покажуваат дадените тест примери. Од друга страна пак, доколку ги пробаме сите комбинации со битмаски, се работи за 2^100 комбинации, за чија проверка би биле потребни нешто повеќе од 394 трилиони века (доколку пресметуваме со 100 милиони операции во секунда), што е значително повеќе од временското ограничување од 1 секунда. :)

Оваа задача е варијација на 0-1 knapsack проблемот (проблем со ранец каде што секој предмет се појавува еднаш). Во овој случај, предметите се канделабрите, нивните вредности се бројот на полиња кои ги осветлуваат, волуменот е цената а капацитетот на ранецот е буџетот со кој располагаме. Правиме матрица `DP[][]`, каде што `DP[x][y]` означува број на осветлени полиња при користење на првите `x` канделабри и буџет `y`.

Доколку бараме колку полиња ќе се осветлат со првите `x` канделабри и буџет `y`, тогаш имаме еден од овие два избора (го бираме поголемото):

 * Ја користиме `x`-тата канделабра. Вредноста на овој израз е бројот на полиња осветлени од `x`-тата канделабра + бројот на полиња осветлени со канделабрите од 1 до `x-1` при буџет `y-Ci[x]`
   * `DP[x][y] = osvetleni_polinja + DP[x-1][y-Ci[x]]`
 * Не ја користиме `x`-тата канделабра. Вредноста на овој израз е бројот на полиња осветлени со канделабрите од 1 до `x-1` при буџет `y`. 
   * `DP[x][y] = DP[x-1][y]`

Тргнувајќи од `DP[n][budget]`, каде што `n` е бројот на канделабри и `budget` е буџетот со кој располагаме, рекурзивно ги откриваме помалите вредности кои ни се потребни за да го добиеме резултатот.

Бидејќи во задачата исто така се бара и најдолгиот дел од патеката што не е осветлен, мораме да знаеме кои канделабри сме ги одбрале за да го добиеме решението. Затоа правиме додатна `boolean` матрица `iskoristeno[n][budget]`, каде `iskoristeno[x][y]` е `true` само доколку со буџет `y` сме ја избрале `x`-тата канделабра.

Потоа ја претставуваме патеката со низа од `int` или `boolean` вредности, `osvetleno`, каде што `osvetleno[i]=1` (или `true`) доколку `i`-тото поле е осветлено. Изминувајќи ја матрицата `iskoristeno` во обратен редослед (од буџет `budget` до буџет 0), проверуваме кои канделабри ги имаме искористено и според тоа ја пополнуваме низата `osvetleno`. Се што преостанува е да го најдеме најдолгиот интервал од 0 или `false` елементи во низата, и да го испечатиме нивниот број заедно со бројот на осветлени полиња.

[Решение во C++](http://pastebin.com/AM0nN5Jt)

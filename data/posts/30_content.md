*За сите кои не слушаат веројатност / не студираат на ФИНКИ, се работи за [оваа](http://mendo.mk/algoritmi/Task.do?competition=250&amp;id=604) задача (потребно е да се логирате на мендо)*

Да дефинираме состојба како даден момент во кој имаме проверено неколку компјутери и за нив знаеме која верзија ја имаат. Формално, состојба можеме да дефинираме како функција `f(x,y)` каде што `x` ни означува колку компјутери од тие што сме ги провериле ја имаат новата верзија а `y` ни означува колку компјутери од тие што сме ги провериле ја имаат старата верзија. За секоја дадена состојба `f(x,y)` знаеме дека имаме проверено вкупно `x+y` компјутери.

`f(x,y)` ќе ни означува уште колку компјутери се очекува да провериме кога веќе се наоѓаме во таа состојба. Решението на оваа задача се наоѓа во `f(0,0)`, каде што немаме проверено ниту еден компјутер и треба да го пресметаме математичкото очекување на бројот на компјутери што мора да се проверат.

Како можеме да го пресметаме `f(x,y)`? (за случаите почнувајќи од вториот се претпоставува дека користиме else if)
1. Доколку `x+y = K`, веќе сме ги провериле сите можни компјутери и нема веќе што да проверуваме, така да `f(x,y) = 0` во тој случај.
1. Доколку `x = N-1`, тогаш сите наредни компјутери мора да се со верзија `y`, бидејќи во спротивно не би биле пуштени `K` компјутери (асистентот би имал пуштено `N` компјутери од верзија `x` и би престанал). Така да `f(x,y) = f(x,y+1)`
1. Доколку `y = N-1`, тогаш сите наредни компјутери мора да се со верзија `x`, бидејќи во спротивно не би биле пуштени `K` компјутери (асистентот би имал пуштено `N` компјутери од верзија `y` и би престанал). Така да `f(x,y) = f(x+1,y)`
1. Доколку ни се потребни `N` компјутери со иста верзија да заврши проверувањето, значи има `K-N` пуштени компјутери од друга верзија (верзијата која нема да се користи).
Доколку `x = K-N` и `y > K-N`, значи дека сите останати компјутери се со верзија y бидејќи во спротивно би имале повеќе од `K-N` пуштени компјутери од друга верзија. Така да `f(x,y) = f(x,y+1)`
1. Доколку `x > K-N` и `y = K-N`, значи дека сите останати компјутери се со верзија `x` бидејќи во спротивно би имале повеќе од `K-N` пуштени компјутери од друга верзија. Така да `f(x,y) = f(x+1,y)`
1. Доколку ниту еден од горните случаи не е исполнет, тогаш мора да го проверме следниот компјутер, така да `f(x,y) = 1 + (f(x+1,y) + f(x,y+1))/2`

За да избегнеме пресметување на една состојба повеќе пати користиме меморизација. Пресметаните резултати ги меморизираме во матрица од дропки и пресметка правиме само доколку нема веќе внесено вредност во матрицата. Во најлош случај матрицата би била со големина `(N+1)x(N+1)`, бидејќи не може да има повеќе од `N` компјутери со една верзија. Заради оптимизација, дропката ја скратуваме само еднаш на крај.

[Решение](http://pastebin.com/PKphJMHw)

Доколку обрнеме внимание на горенаведените случаи 2 и 3 и случаите 4 и 5 можеме да забележиме дека матрицата е симетрична. За секои `x` и `y` важи `f(x,y) = f(y,x)`. Ова можеме да го искористиме како оптимизација така што ќе ограничиме `x >= y`. Со ова нема да проверуваме една половина од матрицата. Додатно, бидејќи ќе имаме `N` компјутери со една верзија и `K-N` компјутери со друга верзија, матрицата може да е со големина `(N+1) x (K-N+1)`.

Потребно е да ги отстраниме случаите 3 и 4 и исто така да направиме нова варијација на 6тото правило која не би дозволила да преминеме од другата страна на дијагоналата (каде што `y > x`).

* Доколку `x = y`, тогаш `f(x,y) = 1 + (f(x+1,y) + f(x+1,y))/2 = 1 + f(x+1,y)`

[Решение](http://pastebin.com/JrtxBfSE)

Дури и со оваа оптимизација решението користи многу меморија бидејќи имаме голем број на `BigInteger` променливи. Доколку го анализираме тест примерот со `N = 7` и `K = 9`, матрицата би изгледала вака:

![](https://aandevski.files.wordpress.com/2015/12/d0b0.png)

Доколку го искористиме фактот дека во матрицата имаме само собирање и делење со два можеме да забележиме дека сите именители на дропките се 2 на некој степен.

Матрицата можеме да ја претставиме на начин така што сите антидијагонали имаат исти именители. Во тој случај во матрицата наместо дропки би можеле да ги чуваме само именителите така што за секоја позиција според координатите можеме да провериме кој е именителот. Секоја антидијагонала можеме да ја претставиме преку бројот на компјутери проверени до тој момент.

Притоа секогаш кога на позиција `x,y` ставаме резултат од `x+1,y` или `x,y+1`, тој резултат го множиме со 2 бидејќи преминуваме во друга антидијагонала и ни се менува именителот.

[Решение](http://pastebin.com/AHwSM5Yp)

Слично на оптимизацијата на 0/1 Knapsack каде што користиме низа наместо матрица, можеме и тука да забележиме дека при пополнување на една антидијагонала ги користиме вредностите само од претходната антидијагонала (за `x,y` се користат само `x+1,y` и `x,y+1`). Така да би можеле да користиме само две низи за две антидијагонали: претходната антидијагонала и антидијагоналата што ја пополнуваме сега. Доколку низите ги пополнуваме во обратен редослед тогаш доволно е само една низа.

Во секоја антидијагонала `Z` (каде што `Z = x+y`), ги проверуваме само оние позиции кои спаѓаат во барем еден од случаите наведени погоре. За сите антидијагонали освен `Z = 0`, ги проверуваме сите `x,y` парови така што:
 * `x` е помало или еднакво на `N-1`
 * `x` e помало или еднакво на `Z` (значи `y` не е негативно)
 * `x >= Z – x`
   * Доколку y го претставиме како `Z – x`, а бидејќи `x` мора да е поголемо или еднакво на `y` (заради симетријата објаснета погоре), `x` мора да е поголемо или еднакво на `Z – x`

[Решение](http://pastebin.com/4hxRMMa2)

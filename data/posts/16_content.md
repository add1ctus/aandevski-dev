Без многу вовед, веднаш ќе навлезам во задачата. Иако веројатно постои некое ad hoc решение, задачата е најлесно решлива доколку имате познавања од графови, поточно Flood fill алгоритмот (што е всушност варијација на DFS).

[Линк до задачата](http://mendo.mk/Task.do?id=140)

Пред да преминеме на flood fill и на решавањето, првин треба да знаеме која е оптималната стратегија за поставување на роботите. Бидејќи роботите можат само да се движат само на рамен терен или по угорници, идеално решение е доколку ги поставуваме на најниското можно место. Со ова ќе се осигураме дека еден робот може да се прошири на што повеќе места (со што ќе ни бидат потребни помалку роботи). Но дали според оваа логика би можел еден робот да го покрие целиот град? Во некои случаи, да.

Да го разгледаме следниов пример:
```
1 4 1
1 4 1
```
Според правилото што го утврдивме, треба да поставиме робот на некое поле со висина 1. Но само еден робот не би можел да го покрие целиот град, бидејќи за да се стигне од левиот крај до десниот крај, тој робот би требало да се качува нагоре па да се спушта надолу (што не може). Така да не секогаш еден робот ќе може да го покрие градот. Во вакви случаи ни се формираат повеќе „групи“ на позиции. За горниот пример би можеле да ги направиме групите вака:

```
[1 4] 1
[1 4] 1
```

или 

```
1 [4 1]
1 [4 1]
```

Бројот на групи ни е всушност бројот на потребни роботи за да се покрие целиот град. Прашањето е како да ги добиеме групите. Веќе претходно заклучивме дека идеалното решение е кога почнуваме од најниското можно поле. Така да во овој случај го бараме најниското поле кое не е во група, и од него се прошируваме во сите 4 насоки (се додека не стигнеме до удолница). Ова се изведува со помош на flood fill алгоритмот и ќе се врши се додека не ги ставиме сите полиња во некоја група.

## Пишување на кодот

Бидејќи flood fill алгоритмот се имплементира како посебна рекурзивна функција (има и други начини, но нема да ги разгледуваме сега), потребно е мапата што ја внесуваме да е сместена во глобална променлива. Затоа правиме матрица од `int mapa[50][50]` каде што `mapa[i][j]` ќе ни означува која е висина на полето со координати `i,j`. За да водиме евиденција кое поле е веќе ставено во група а кое не, додаваме уште една матрица `poseteno[50][50]` од тип `boolean` каде што `poseteno[i][j]` е `true` додека полето е веќе ставено во група, а `false` во спротивно. На крајот додаваме една променлива `poseteniTeminja` која ни означува колку темиња сме веќе поминале (ставиле во група). Кога овој број ќе стигне до вредноста `R*C` значи сите темиња се посетени и програмот завршува.

Кога веќе ја знаеме податочната структура, да го размислиме flood fill кодот. Потребно е да имаме функција која кога ќе се повика за некое теме `x,y`:

 * Ќе го означи темето `x,y` како посетено во матрицата `poseteno`
 * Ќе го зголеми бројачот за посетени темиња за 1.
 * Ќе проба да ги посети сите околни **непосетени** темиња кои се поголеми или еднакви од темето на кое се наоѓаме (притоа треба да внимавате да не излезете надвор од меморискиот опсег)

Првите две можеме да ги средиме со два реда код:

```
void floodfill (int x, int y)
{
    poseteno[x][y]=true;
    poseteniTeminja++;
```

Сега потребно е да се посетат сите околни темиња - да ја повикнеме функцијата flood fill рекурзивно за сите 4 поврзани темиња. Доколку се наоѓаме на позицијата `x,y`, тогаш 4-те соседни темиња се наоѓаат на координатите

 * `x+1, y`
 * `x-1, y`
 * `x, y+1`
 * `x, y-1`

Прво што треба да направиме е да провериме дали секоја од овие позиции е валидна (да не е некоја координата помала од 0 или поголема од `R` или `C`, зависи од тоа дали се работи за `X` или `Y` координатата). Доколку позицијата е валидна, тогаш треба да провериме дали таа веќе е ставена во некоја група. Доколку не е ставена (вредноста poseteno на тоа поле е `false`), тогаш останува само да провериме дали роботот може да се движи во таа насока (дали полето на кое стои е пониско или на иста висина со полето кон кое сакаме да се движиме). Доколку сите овие услови се исполнети, тогаш ја повикуваме функцијата flood fill за тоа поле.

```
    if(x+1<r && !visited[x+1][y] && mapa[x][y]<=mapa[x+1][y])
        floodfill(x+1,y);
    if(x-1>=0 && !visited[x-1][y] && mapa[x][y]<=mapa[x-1][y])
        floodfill(x-1,y);
    if(y+1<;c && !visited[x][y+1] && mapa[x][y]<=mapa[x][y+1])
        floodfill(x,y+1);
    if(y-1>=0 && !visited[x][y-1] && mapa[x][y]<=mapa[x][y-1])
        floodfill(x,y-1);
}
```

Со ова е завршена flood fill функцијата. Единственото нешто што ни преостанува е да ја искористиме таа функција. Се додека не се одредени сите полиња (се додека `poseteniTeminja` е помало од `R*C`), потребно е да ја повикаме функцијата floodfill со параметри - најниската точка која сеуште не е посетена. Бидејќи се работи за мала мапа (со големини 30х30), можеме слободно да ја изминеме целата и да го најдеме најниското место. Кога ја добиваме таа точка, ја повикуваме функцијата flood fill за неа. Секогаш кога ја повикуваме floodfill функцијата од main функцијата ние всушност создаваме нова група, така да секогаш кога ќе ја повикуваме функцијата ќе го зголемуваме резултатот за 1.

```
while(poseteniTeminja<r*c)
{
    int najmalBroj=32; //Не постои поле повисоко од 32
    int najmalX,najmalY;

    for(int i=0;i<r;i++)
        for(int j=0;j<c;j++)
            if(najmalBroj>mapa[i][j] && !poseteno[i][j])
            {
                najmalBroj=mapa[i][j];
                najmalX=i;
                najmalY=j;
            }

    rezultat++;
    floodfill(najmalX,najmalY);
}
```

Со прекинување на овој `while` циклус ќе го добиеме резултатот во променливата `rezultat`, кој го печатиме.

Вообичаено при барање на решение на некој проблем или задача, размислувам за повеќе начини на решавање, дури и да не се очигледни. Понекогаш и ќе се изненадите колку различни проблеми можете да претставите како некој вид на граф, каква релација можете да најдете со динамичко програмирање или на какви задачи може greedy да даде точен резултат. Едно од нештата на кое не ми текнува вообичаено се бројните системи и како може тие да се искористат за упростување на некоја задача.

Една таква задача е [Бонбони](http://mendo.mk/Task.do?id=44), од регионалниот натпревар по програмирање од 2010. Во задачата имаме двајца браќа, Нино и Тино, на кои нивната тетка треба да им купи бонбони. Проблемот е во следново : таа има купено само еден пакет од `N` бонбони кој треба да го даде на Нино. За да не ги разочара децата, мора да купи и додатни пакети за Тино, така да Нино и Тино имаат еднаков број на бонбони.<!--more-->

Секако, оваа задача би била прелесна на овој начин. Додатното ограничување што ја прави оваа задача интересна е тоа што можете да купувате само пакети со број на бонбони - степен на 3. Така да можеме да користиме само пакети со 1, 3, 9, 27, 81, 243 бонбони итн.. (множиме со 3). На пример, доколку Нино има 12 бонбони, единственото решение е да се купат пакети со 3 и 9 бонбони за Тино (и двата броја се степен на 3). Друг пример би бил со 17 бонбони, каде што на Нино би требало да му додадеме пакети од 1 и 9 бонбони, а на Тино пакет од 27 бонбони, така да тие би имале еднаков број.

## Бројни системи
Со промените во програмите секоја година, веќе и не сум сигурен кои ученици имаат учено за бројни системи, а кои не, па решив да објаснам во случај некој да ги нема сретнато. Доколку знаете што се бројни системи, можете да прескокнете до наредниот дел, каде ги користиме за решавање на задачата.

Сите знаеме дека компјутерите работат само со броевите 0 и 1, кои внатре во деловите се претставени како висока или ниска струја (волтажа, поточно). Така да кога компјутерот на пример треба да пресмета збир на два броја, тој треба тие два броја од нашиот декаден систем (со 10 цифри, од 0 до 9) да го претвори во бинарен броен систем (со 2 цифри, 0 и 1).

И двата бројни системи се позициони бројни системи, што значи дека редоследот на броевите е важен, и секоја цифра има различна тежина. Така да броевите 21 и 12 се различни, иако имаат исти цифри.

На пример, бројот 123 би можеле да го претставиме како `1 * 100 + 2 * 10 + 3 * 1`, што е исто еднакво како 123. Доколку броевите 100, 10 и 1 ги претставиме како степен со основа 10 (зошто 10? бидејќи како што рековме, декадниот систем има 10 цифри), тогаш овој број би бил `1 * 10^2 + 2 * 10^1 + 3 * 10^0`. Го приметувате шаблонот? Почнувајќи од десно со тежина 10^0, секоја наредна цифра има поголема тежина за 1 степен. 4-тата цифра би имала степен 10^3, 5-тата цифра степен 10^4, итн..

На ист начин функционираат сите други бројни системи. На пример, доколку сакаме да го претставиме бројот 5 во бинарниот систем, тоа би изгледало вака: `1 * 2^2 + 0 * 2^1 + 1 * 2^0`. За да претвориме некој број од декаден во друг броен систем, го делиме бројот со основата на новиот броен систем и го запишуваме остатокот.

* 5 / 2 = 2 и остаток 1
* 2 / 2 = 1 и остаток 0
* 1 / 2 = 0 и остаток 1

Кога стигнеме до бројот 0, завршуваме со делењето, и го запишуваме остатокот, во обратен редослед (во овој случај, од доле - нагоре). Така да бројот 5 во декадниот систем може да се запише како 101. Истово правило важи за било кој броен систем како окталниот (со основа 8), хексадецималниот (со основа 16) итн.

Собирањето на два броја се врши на ист начин. Можеме да ги ставиме двата броја еден врз друг (порамнето од десна страна), и почнувајќи од десната страна да ги собираме цифрите кои се една врз друга. Притоа, доколку на пример работиме со бинарниот броен систем, и треба да собереме 1 + 1, не смееме да запишеме 2  (бидејќи бројниот систем работи само со 0 и 1), туку запишуваме 0, и 1 го додаваме во колоната лево (го паметиме).

## Назад на задачата

Сега кога веќе знаеме како работат бројните системи, како може нив да ги искористиме во задачата? Клучна забелешка е фактот дека пакетите со бонбони кои можеме да ги купиме секогаш содржат 3^x бонбони, каде што x е некој произволен број. Доколку ги претставиме пакетите во броен систем со основа 3, тогаш пакетите 1, 3, 9, 27 би изгледале вака :

* 1 (декаден) = 1 (основа 3)
* 3 (декаден) = 10 (основа 3)
* 9 (декаден) = 100 (основа 3)
* 27 (декаден) = 1000 (основа 3)

Приметуваме дека секој број има 1 како прва цифра, и сите останати се 0. Се што преостанува е како да го искористиме ова. Знаеме дека Нино веќе има добиено некој број на бонбони, што можеби и не може да се претстави со прва цифра 1 и останати 0 во овој броен систем. На пример, бројот 17 (примерот ставен заедно со задачата) е 122 во систем со основа 3. Но бидејќи ние на Тино не можеме да му земаме само бонбони кои имаат 1 и 0 како цифри, и не можеме да земеме два или повеќе исти пакета, знаеме дека бројот 122 не можеме да го добиеме никогаш.

Првото нешто што е потребно е да му дадеме на Нино неколку пакети, така да добиеме број само со цифри 0 и 1, за да можеме на Тино да му ја дадеме истата количина. Почнувајќи од десната страна, треба да се ослободиме од двојките во тој број. Го додаваме бројот 1 (пакет со една бонбона) на 122 за да се ослободиме од двојката десно.

```
 122
+001
-------
 200
```
Сега имаме двојка на третата позиција, така да треба да го додадеме бројот 100 (пакет од 9 бонбони) за да се ослободиме и од таа двојка.

```
 200
+100
-------
1000
```

Значи откако ќе му дадеме на Нино пакет со 1 и 9 бонбони, тој има 27 бонбони. Се што преостанува е да го изедначиме тој број за Тино, или да му го дадеме пакетот со 27 бонбони, и со ова е решена задачата.
## Пишување на кодот
Според објаснетиот начин на решавање, ние би требало да го претвориме `N` во број со основа 3, да го зачуваме во некоја низа цифра по цифра, па тогаш да му додаваме други броеви со основа 3 (и да запишуваме кои сме ги додале), па да го претвориме резултатот назад во декаден броен систем за да го испечатиме. Дали можеме поефикасно од тоа?

Клучна забелешка тука е дека запишувањето на броеви во основа 3 и нивното собирање се врши на ист начин - од десно кон лево. Така да наместо да го претвораме бројот па после да вршиме собирање, ние можеме во исто време да ги правиме и двете работи.

Како го делиме бројот `N` со 3 и добиваме остаток, тој остаток не го запишуваме, туку веднаш го користиме. Доколку остатокот е 2, значи имаме двојка од која треба да се ослободиме, и му додаваме на Нино пакет кој има 1 на таа позиција. Доколку остатокот е 1, тогаш треба и на Тино да му додадеме пакет кој има 1 на таа позиција (за да имаат и двајцата ист број на бонбони). И доколку остатокот е 0, тогаш на никого не даваме пакет (бидејќи ќе имаат ист број на бонбони на таа позиција). Притоа е важно правилото за собирање на броеви, каде што рековме дека доколку некој број ги надминува границите (на пример кога на некоја двојка додадеме 1, станува 3), не запишуваме 3, туку запишуваме 0 и паметиме 1 за следната цифра. Така да секогаш кога остатокот е 2, му даваме пакет на Нино, но на бројот што го делиме додаваме +1. Исто како што претворањето на број во друг броен систем се врши со делење се додека не стигнеме до 0, исто така и овој алгоритам работи се додека бројот не стигне до 0.

За да паметиме кој пакет на кого го имаме дадено, најпрактично е да користиме вектор. Доколку не сте запознаени со вектори, ви препорачувам да го прочитате [ова](http://mendo.mk/Lecture.do?id=19) (на кратко, векторите во програмирање се нешто налик низи, само со променлива големина и додатни функции). Се што преостанува е да ги сортираме двата вектора и да ги испечатиме на крајот.

[Решение во C++](http://pastebin.com/zNVKd0pH)

Најпрвин би сакал да се извинам што го пишувам постов толку касно. Натпреварот се поклопи со почетокот на колоквиумската недела, така да од учење и немав многу време да посветам на програмирање. По неколку дена одмор, сега повторно се враќам на решавање задачи и подготовки за натпревари, така да очекувајте многу поредовни постови. А сега, назад на натпреварот.

Честитки до сите што учествуваа, посебно до Христијан кој успеа да го земе првото место со само еден поен разлика, што укажува на тоа колку беше јака конкуренцијата. Во овој пост ќе ги објаснам првите три задачи, додека наредните две ќе ги објаснам во посебни (и поголеми) постови наредните денови. Па, да започнеме..

## Пакети

[Линк до задачата](http://mendo.mk/Task.do?id=543)

Како и вообичаено, првата задача се базира на имплементација која ќе провери колку добро ученикот владее со програмирање, а не со решавање на проблеми. Имено, имаме дадени два броја, `A` и `B` - број на чоколади од двата типа. Од вас се бара да го испечатите бројот на различни начини на кои можете да ги поделите чоколадите во еднакви пакети.

На пример, доколку имате 4 чоколади од тип `A` и 8 чоколади од тип `B`, тогаш имате 3 начина на поделба:
 * 1 пакет со 4 A и 8 B чоколади
 * 2 пакети со 2 A и 4 B чоколади
 * 4 пакети со 1 A и 2 B чоколади

Можете да забележите дека броевите 1,2 и 4 се делители на броевите 4 и 8, што насочува дека резултатот го сочинуваат сите броеви кои се делители на броевите `A` и `B`, што можеме и да го докажеме. Доколку 4 и 8 чоколади пробаме да поделиме на 3 пакета (број што не е делив со `A` и `B`), тогаш во секој пакет би имале 1 `A` и 2 `B` чоколади, при што ни остануваат една `A` и две `B` чоколади вишок. Ова важи за било кој друг број кој не е делив со `A` и `B`. Секогаш ќе има неколку чоколада останати вишок, што значи дека таква респределба не може да се направи.

Се што преостанува е да ги испечатиме сите броеви кои се деливи со `A` и `B`. Бидејќи се работи за мал број (највеќе 10,000 чоколади), можеме да ги провериме сите броеви од 1 до 10,000 и да провериме кој од нив е делив со `A` и `B` и да го испечатиме.

```
#include <iostream>

using namespace std;

int main()
{
    int a,b;
    cin>>a>>b;

    for(int i=1;i<=10000;i++)
        if(a%i==0 && b%i==0)
            cout<<i<<endl;

    return 0;
}
```

## Арч

[Линк до задачата](http://mendo.mk/Task.do?id=541)

Повторно се работи за имплементација, која во овој случај е малку потешка од првата задача. Доколку го пратите мојот блог веројатно имате веќе видено дека секогаш кога треба да се внесе некој број кој што ќе го поделуваме на цифри, добра навика е бројот да се внесе како string, освен доколку не треба да се прават и други операции на бројот. Тоа ни овозможува многу лесно и брзо проверување на секоја цифра посебно, без потреба на делење на бројот и без ограничување на големината на бројот (со `long long` највеќе можете да прочитате 18-цифрен број).

Така да што треба да направиме е да внесеме `N` броја како стрингови, и за секој од нив да провериме дали се состои само од карактерите '0', '2', '4', '6' и '8'. Доколку се состои само од тие карактери, тогаш зголемуваме два бројачи:
 * `broevi++` - што ни означува колку вкупно броеви можеме да искуцаме
 * `tipki+=broj.size()` - означува колку вкупно типки сме притиснале

```
#include <iostream>
#include <string>

using namespace std;

int main()
{
    int broevi=0,tipki=0,n;
    string broj;

    cin>>n;

    for(int i=0;i<n;i++) 
    { 
        cin>>broj;
        bool mozeDaSeIskuca=true;

        for(int j=0;j<broj.size();j++)
            if(broj[j]=='1' || broj[j]=='3' || broj[j]=='5' || broj[j]=='7' || broj[j]=='9')
                mozeDaSeIskuca=false;

        if(mozeDaSeIskuca)
        {
            broevi++;
            tipki+=broj.size();
        }
    }

    cout<<broevi<<endl<<tipki;

    return 0;
}
```

## Програмери

[Линк до задачата](http://mendo.mk/Task.do?id=544)

Веќе стигнуваме до малку попредизвикувачките задачи. На прв поглед ни оваа задача не е тешка, но доколку обрнете внимание на ограничувањата, задачата станува потешка. Доколку би пробале да направите низа со должина 1,000,000,000 која би означувала кој број колку пати се појавува, таа низа би зафаќала 3.72 гигабајти, што е многу над мемориското ограничување од 64 мегабајти. Од друга страна пак, доколку би ги внеле сите 100,000 броеви во низа (со големина едвај 0.38 мегабајти), тогаш немате брз начин да проверите кој број колку пати се појавува (мислам дека најдобриот случај би бил сортирање со `O(N logN)` алгоритам па линеарно изминување, кој е најверојатно спор за 200 милисекунди).

Решението (можеби не единствено) се наоѓа во мапа од тип `<int, int>`. Ја користите на ист начин како што би употребиле обична низа за да забележите кој број колку пати се појавува. Но разликата е во тоа што додека низа би алоцирала 1,000,000,000 елементи во меморијата веднаш, мапата алоцира елементи во меморијата само кога ги повикувате. Така да иако вие можеби пристапувате до броевите 0 и 999,999,999,999 во мапата, таа никогаш нема да алоцира повеќе од 100,000 броја при внес (бидејќи толку различни броја може највеќе да се внесат).

Кога веќе имате информација кој број колку пати се појавува, потребно е само да проверите за секој број `X`, колку пати се појавуваат броевите `X-k` и `X+k` и да го помножите тоа со колку пати се појавува бројот `X`. На овој начин ќе добиете дупликат вредности (бидејќи секој пар ќе се рачуна два пати), така да потребно е или да го поделите резултатот со 2, или да пресметувате само со `X+k` или само со `X-k` (само во една насока). Но како знаеме кои броеви `X` се внесени во мапата?

Иако постои начин со итератори да ја изминеме содржината на мапата, постои многу полесен начин за кодирање каде што ги пресметуваме паровите веднаш при внесување. Веднаш кога ќе внесеме број `X`, знаеме дека од него можеме да направиме `mapa[X-k] + mapa[X+k]` парови во тој момент. Ова правило важи секогаш освен кога `k` е 0. Да го разгледаме тој случај:

 * Доколку имаме 2 исти броја, тогаш имаме само 1 пар. Горниот алгоритам би дал резултат 0 или 2.
 * Доколку имаме 3 исти броја, тогаш имаме 3 пара (прв и втор, прв и трет, втор и трет). Горниот алгоритам би дал резултат 3 или 12.
 * Доколку имаме 4 исти броја, тогаш имаме 6 пара. Нашиот алгоритам би дал резултат 12 или 20.

Резултатот зависи од тоа дали прво ја зголемуваме мапата па додаваме резултат или обратно. Бидејќи знаеме дека алгоритмот не е точен, да обрнеме внимание на резултатите со `k = 0`

 * 2 броја - 1 пар
 * 3 броја - 3 пара
 * 4 броја - 6 пара
 * 5 броја - 10 пара
 * 6 броја - 15 пара

Можеме да го забележиме шаблонот: кога ќе се внесе `X`-тиот ист број, тогаш бројот на парови се зголемува за `X-1`.

Се што преостанува е да ја имплементираме идејата во код, при што користиме `sync_with_stdio(false)` за да го оптимизираме влезот (да работи побрзо):

```
#include <iostream>
#include <map>

using namespace std;

int main()
{
    ios_base::sync_with_stdio(false);

    int n,k,broj;
    long long rezultat=0;
    cin>>n>>k;

    map<int, int> mapa;

    if(k==0)
        for(int i=0;i<n;i++)
        {
            cin>>broj;
            mapa[broj]++;
            rezultat+=mapa[broj]-1;
        }
    else
        for(int i=0;i<n;i++)
        {
            cin>>broj;
            mapa[broj]++;
            rezultat+=mapa[broj-k]+mapa[broj+k];
        }
    
    cout<<rezultat;
    
    return 0;
}
```

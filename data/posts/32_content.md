Бидејќи започнав традиција со минатогодишните натпревари, ќе продолжам и оваа година да постирам објаснувања за задачите од натпреварите на Мендо, повторно почнувајќи со училишниот натпревар.

По некоја слободна проценка би рекол дека овогодинешниов училишен натпревар беше полесен од оној лани, највеќе поради 5-тата задача која сега е делумно полесна (но бараше од вас да забележите нешто). Сепак имаше простор за грешка во другите задачи (посебно втора и трета) каде што погрешно сфаќање на задачата може да ви изгуби солиден број поени. Без да одолжувам повеќе, да преминам на самите задачи...

## Гостин

[Линк до задачата](http://mendo.mk/Task.do?id=607)

Задача која верувам дека е примарно наменета за учениците од основно образование и сите кои се нови во програмирањето. Од вас се бара да ги соберете двете пакетчиња, да ги поделите на два еднакви дела и резултатот да го помножите со 7. Заради самиот начин на кој работи делењето на цели броеви, нема потреба да се грижите за тоа дали може точно да се распределат сите бомбони (доколку има една вишок бомбона, таа ќе ја снема при делењето).

```
#include <iostream>

using namespace std;

int main()
{
    int x,y;
    cin>>x>>y;
    cout<<(x+y)/2*7;
    return 0;
}
```

## Боење

[Линк до задачата](http://mendo.mk/Task.do?id=611)

Прва задача која ќе почне да го тестира вашето алгоритамско размислување и ќе провери колку сте запознаени со сложеност на алгоритми. Најлесното решение би било да се измине целиот лист коцка по коцка и да се бројат сите бои. Но за ограничувања до 10^6 `O(N*M)` решение не е изводливо, така да се бара друга идеја.

Можеме најпрвин да ја разгледаме задачата за 1 ред коцки (почнувајќи со црвена коцка) и подоцна истото да го прошириме на повеќе редови кои би почнувале со разни бои. Да претпоставиме дека во редот имаме `X` коцки. Доколку `X` е деливо со 3, тогаш имаме `X/3` црвени, `X/3` жолти и `X/3` зелени коцки во тој ред. Но што правиме доколку `X` не е деливо со 3? Имаме две можни ситуации: остатокот на `X/3` да е 1 или 2. Доколку остатокот е 1, тогаш имаме уште една црвена коцка (вкупно `X/3+1`), а доколку остатокот е 2, тогаш имаме и црвена и жолта вишок коцка. Најпростиот начин да ги претставиме коцките во еден ред би бил:

```
int crveniKocki = x/3;
if(x % 3 > 0)
    crveniKocki++;
int zoltiKocki = x/3;
if(x % 3 > 1)
    zoltiKocki++;
int zeleniKocki = x/3;
```

Доколку сакате да заштедите на линии код, можете овие 3 променливи да ги претставите како `(X+2)/3`, `(X+1)/3` и `X/3`.

Но што се случува доколку редот почнува со друга боја? Доколку редот би започнал со жолта боја, тогаш би имало `(X+2)/3` жолти, `(X+1)/3` зелени и `X/3` црвени коцки. Исто, доколку би започнал со зелена боја, тогаш би имало `(X+2)/3` зелени, `(X+1)/3` црвени и `X/3` жолти коцки (претпоставувам дека е јасно од каде доаѓа ова). Сега кога знаеме во кој ред колку коцки има, ни преостанува само да преброиме кој ред колку пати се појавува.

Ова го правиме со иста идеја. Доколку имаме `Y` редови, тогаш има `(Y+2)/3` редови што започнуваат со црвена боја, `(Y+1)/3` редови што започнуваат со жолта боја и `Y/3` редови што започнуваат со зелена боја. Кога веќе знаеме кој ред колку пати се појавува и во секој од тие редови која боја колку пати се појавува, за крај само треба да ги помножиме тие броеви (`број на редови * број на појавување на одредена боја во тој ред`) и да ги собереме производите.

```
#include <iostream>

using namespace std;

int main()
{
    int x,y;
    cin>>x>>y;

    int prvaBoja = (x+2)/3;
    int vtoraBoja = (x+1)/3;
    int tretaBoja = x/3;
    int prvRed = (y+2)/3;
    int vtorRed = (y+1)/3;
    int tretRed = y/3;

    int crvena = prvRed*prvaBoja + vtorRed*tretaBoja + tretRed*vtoraBoja;
    int zolta = prvRed*vtoraBoja + vtorRed*prvaBoja + tretRed*tretaBoja;
    int zelena = prvRed*tretaBoja + vtorRed*vtoraBoja + tretRed*prvaBoja;

    cout<<crvena<<" "<<zolta<<" "<<zelena;

    return 0;
}
```

## Аеродром
[Линк до задачата](http://mendo.mk/Task.do?id=608)

За разлика од претходната задача, оваа е решлива со brute force пристап (и според мене е полесна од втората). Во најлош случај (кога времето на чекање е 23 часа и 59 минути) имаме помалку од 1500 состојби на часовникот што многу лесно би поминало за 1 секунда (всушност би поминало и за многу помалко од 0,1 секунди).

Ги внесуваме 4-те параметри во променливи `h`, `m`, `fh`, `fm` (каде што променливите што започнуваат со `f` го означуваат крајното време). И се додека овие две времиња се различни (или `h` е различно од `fh` или `m` е различно од `fm` (или и двете)), ги правиме следниве две работи:

 * Проверуваме дали моменталното време (означено со `h` и `m`) е палиндром. Ова го правиме така што проверуваме дали првата цифра на `h` е еднаква со втората цифра на `m` и дали втората цифра на `h` е еднаква со првата цифра на `m` (се користи делење и модул со 10 за ова)
 * Го зголемуваме времето за една минута. Доволно е само да го зголемиме бројот `m` за 1, и притоа доколку `m` стигне 60 го враќаме на 0 и зголемуваме `h` за 1. Истото го правиме и за `h` променливата, ставајќи ја на 0 доколку стигне до 24.

Едно нешто што не е спомнато во задачата е дека потребно е да го броите и времето на поаѓање на летот, така да по завршување на `while` циклусот потребна ни е уште една проверка.

```
#include <iostream>

using namespace std;

int main()
{
    int h,m,fh,fm;

    cin>>h>>m;
    cin>>fh>>fm;

    int rezultat = 0;

    while(h != fh || m != fm)
    {
        if(h%10 == m/10 && h/10 == m%10)
            ++rezultat;

        ++m;
        if(m == 60)
        {
            m = 0;
            ++h;
        }
        if(h == 24)
            h = 0;
    }

    if(h%10 == m/10 && h/10 == m%10)
        ++rezultat;

    cout<<rezultat;

    return 0;
}
```

## Пакување подароци

[Линк до задачата](http://mendo.mk/Task.do?id=609)

Уште една задача каде што `O(N*M)` решение не може да работи заради големите ограничувања. Доколку ја сортираме низата со кутии (сортирањето на една низа работи многу побрзо од проверување на сите парови) тогаш почнувајќи од почетокот на низата (од најмалата кутија), првата кутија која може да собере некој подарок е идеалната кутија за тој подарок (бидејќи сите кутии по неа ќе имаат поголема разлика). Со ова спречуваме проверка на парови кои не се оптимални според условот разликата во тежини да е минимална и преостанува да ја направиме оваа проверка за секој подарок.

Но доколку имаме случај со 100,000 кутии каде што сите се со капацитет 1 освен последната и сите подароци се потешки од 1 тогаш овој метод не ни заштедува ништо. За додатна оптимизација ќе ја сортираме и низата на подароци. За дадени подароци `A` и `B` така што знаеме дека `B` е потежок од `A`, знаеме дека сите кутии што не го собираат подарокот `A` сигурно нема да го соберат и подарокот `B`. Така да барањето за подарокот `B` наместо од почетокот на низата го правиме од кутијата во која го ставаме подарокот `A`.

Решението би било кога сортираните низи ги изминуваме во исто време (со два посебни бројачи) кои би покажувале кон еден подарок и една кутија. Имаме две можности:
 * Подарокот го собира во кутијата. Во тој случај ја забележуваме разликата на овој пар (во една променлива памтиме минимална разлика и ја споредуваме) и го поместуваме бројачот на подароци
 * Подарокот не го собира во кутијата. Во тој случај го поместуваме бројачот на кутии (ја бараме кутијата што ќе го собере нашиот подарок)

![илустрација на алгоритмот](https://aandevski.files.wordpress.com/2016/02/untitled-1.gif)

Овој алгоритам прекинува кога ќе завршиме со изминување на било која низа (кога ќе снемаме или подароци или кутии). Во најлош случај ќе ги изминеме сите подароци и кутии, што е `O(N+M)` сложеност.

```
#include <iostream>
#include <algorithm>

using namespace std;

int main()
{
    int n,m;
    cin>>n;
    int podaroci[n];
    for(int i = 0 ; i < n ; ++i)         cin>>podaroci[i];
    cin>>m;
    int kutii[m];
    for(int i = 0 ; i < m ; ++i)         cin>>kutii[i];

    int minRazlika = 99999999;
    int rezultat = -1;

    sort(podaroci,podaroci+n);
    sort(kutii,kutii+m);

    int i = 0, j = 0;
    while(i < n && j < m)
     {
         if(podaroci[i] > kutii[j])
            ++j;
        else
        {
            if(kutii[j] - podaroci[i] <= minRazlika)
            {
                minRazlika = kutii[j] - podaroci[i];
                rezultat = podaroci[i];
            }
            ++i;
        }
    }

    cout<<rezultat;

    return 0;
}
```

## Телепатија

[Линк до задачата](http://mendo.mk/Task.do?id=610)

Ќе бидам искрен, на прв поглед задачава ми изгледаше доста тешка. Но доволно е да ја размислите некое време (неколку минути во мој случај) и да најдете една забелешка што многу ја упростува задачата многу.

Првата идеја е задачава да ја претставиме како граф, каде што почетна позиција ни е `(X,Y)` и треба да стигнеме до позиција `(EX,EY)`. Притоа од позиција `(X,Y)` во графот смееме да се движиме само кон позиции `(X+1,Y-1)` и `(X-1-((2*X)%31)`, `Y+1+((2*X)%31))`. За да го постигнеме ова во минимален број на чекори (најкратко време) користиме BFS. Но проблемот е во сложеноста, со тоа што во графот имаме 10,000,000,000 можни позиции што би направил BFS да паѓа временски. Дури и да е огромен временскиот лимит, претставување на матриците за посетеност и далечина со таа големина би било невозможно.

Оптимизацијата се наоѓа во начинот на движење низ графот. Можете да забележите дека движењата се направени така што доколку едната променлива се зголеми за некој број тогаш другата променлива се намалува за истиот број. Според ова можеме да одредиме правило дека збирот `X + Y` ќе е константен, т.е. не можеме да го смениме преку тие две движења. Од ова можеме да го извлечеме заклучокот дека доколку `X + Y` е различно од `EX + EY` тогаш не постои начин да се стигне од една позиција од друга. Печатиме -1.

Сега бидејќи знаеме дека `X + Y = EX + EY`, тогаш знаеме дека доколку стигнеме во положба каде што `X = EX` тогаш со сигурност ќе мора и `Y = EY`. Значи само потребно ни е `X` вредноста да ја доведеме до `EX` во што помал број на чекори и нема воопшто потреба да внимаваме на `Y` променливата. Бројот на можни позиции ни се намалува на помалку од 100,000 што ја прави задачава лесна за BFS решение.

```
#include <iostream>
#include <queue>

using namespace std;

bool visited[100001];
int dist[100001];
queue<int> Q;

int main()
{
    int x,y,fx,fy;
    cin>>x>>y>>fx>>fy;
    if(x + y != fx + fy)
    {
        cout<<-1;
        return 0;
    }

    visited[x] = true;
    dist[x] = 0;
    Q.push(x);

    while(!visited[fx])
    {
        int curr = Q.front();
        Q.pop();

        int x1 = curr + 1;
        int x2 = curr - 1 - ((2*curr)%31);

        if(x1 < 100001 && !visited[x1])
         {
             visited[x1] = true;
             dist[x1] = dist[curr] + 1;
             Q.push(x1);
         }
         if(x2 > 0 && !visited[x2])
        {
            visited[x2] = true;
            dist[x2] = dist[curr] + 1;
            Q.push(x2);
        }
    }

    cout<<dist[fx];

    return 0;
}
```

Катастрофална недела со натпревари. Изненадно тешки задачи на последниве Codeforces и TopCoder натпревари (интересен факт: никој од Македонија не успеа да ја реши првата задача од првата дивизија од било кој од овие натпревари). Еден натпревар на кој успеав да извадам некој резултат е HackerRank Weekly Challenge, решавајќи 3 од 5 задачи (од кои една не помина целосно нажалост). Да ги разгледаме задачите:

## Largest Permutation
[Линк до задачата](https://www.hackerrank.com/challenges/largest-permutation)

Задачата се решаваше со greedy. Заради природата на лексикографското споредување (почнуваме да ги споредуваме елементите од првиот), мора секогаш да се осигураме дека првиот елемент е најголем можен, потоа вториот, итн. Ја изминуваме линеарно низата и проверуваме дали елементот на таа позиција е поголем од сите елементи десно од него. Доколку е, продолжуваме, доколку не е најголем, тогаш го заменуваме со најголемиот. Можеме да го искорситиме фактот дека работиме со броевите од 1 до `N`. Според тоа, на `i`-тата позиција треба да го имаме бројот `N-i`, доколку не е таму, тогаш го наоѓаме бројот `N-i` во низата и ги заменуваме нивните места. Дозволено ни е да направиме најмногу `K` замени. Кога ќе стигнеме до тој број (или до крајот на низата), завршуваме со изминувањето и го печатиме резултатот.

```
#include <iostream>
#include <algorithm>

using namespace std;

int main() {
    int n,k;
    cin>>n&>>k;
    
    int arr[n];
    for(int i=0;i<n;i++)
        cin>>arr[i];
    
    for(int i=0;i<n && k;i++)
        if(arr[i]!=n-i)
            for(int j=i+1;j<n;j++)
                if(arr[j]==n-i)
                {
                    swap(arr[j],arr[i]);
                    k--;
                    break;
                }    
    
    for(int i=0;i<n;i++)
    {
        cout<<arr[i]<<" ";
    }
    
    return 0;
}
```

## Number List

[Линк до задачата](https://www.hackerrank.com/challenges/number-list)

Рекурзивно решение. Имаме функција `solve (int pocetok, int kraj)` која за тој интервал ќе ни го даде бројот на под-стрингови за кои најголемиот број е поголем од `k`. На кој начин го правиме тоа? Го наоѓаме најголемиот број во тој интервал и гледаме на која позиција е. Според тоа можеме да одредиме во колку подстрингови тој е најголемиот број.

Доколку се работи за интервал со должина `S` каде што најголемиот број е на позиција `P`, тогаш бројот на подстрингови од левата страна е `P+1` додека бројот на подстрингови од десната страна е `S-P`. Доколку ги помножиме тие два броја ги добиваме сите можни подстрингови што го содржат најголемиот број.

Бидејќи сме ги пресметале сите подстрингови со бројот на позиција `P`, сега е потребно да ја направиме пресметката за подстринговите кои не го вклучуваат тој број. Ја повикуваме рекурзивно функцијата за интервалите од почетокот на интервалот до `P-1` и од `P+1` до крајот на интервалот. На овој начин ги пресметуваме сите интервали што имаат барем еден број поголем од `k`. Доколку не постои таков број во интервалот, враќаме 0.

```
#include <iostream>
#include <algorithm>

using namespace std;

int arr[200000];
int n,k;

long long no_substrings(int s, int p)
{
    return (p+1)*(s-p);
}

long long solve(int start, int finish)
{
    if(start>finish)
        return 0;
    int maks=0,maksid;
    for(int i=start;i<=finish;i++)
    {
        if(arr[i]>maks)
        {
            maks=arr[i];
            maksid=i;
        }
    }
    if(maks<=k)
        return 0;
    return no_substrings(finish-start+1,maksid-start)+solve(start,maksid-1)+solve(maksid+1,finish);
}

int main()
{
    ios_base::sync_with_stdio(false);
    int t;
    cin>>t;
    while(t--)
    {
        cin>>n>>k;

        for(int i=0;i<n;i++)
            cin>>arr[i];

        cout<<solve(0,n-1)<<endl;
    }
    return 0;
}
```

Заради големиот број на внесени податоци, користиме `sync_with_stdio(false)` за да ја забрзаме задачата. Овој код успеа да падне на 3 тест примери кои се преголеми за да ги анализирам. Доколку ја најдам грешката ќе го едитирам кодот.

## Superman Celebrates Diwali

[Линк до задачата](https://www.hackerrank.com/challenges/superman-celebrates-diwali)

Оваа задача ми се најде полесна од втората, така што успеав да ја решам и пред неа. Доколку имате искуство со динамичко програмирање, просто решение е веднаш воочливо. Правиме матрица `people[N][H]` која ни означува во која зграда на кој кат колку луѓе има. Мислам дека не треба да се објаснува многу во детали овој дел бидејќи е лесен.

Правиме матрица `DP` со големини `N * H` (број на згради помножено по нивната висина). Така да бројот `DP[i][j]` ни означува колку луѓе можеме да спасиме доколку се наоѓаме на `i`-тата зграда на `j`-тиот кат.  Кога се наоѓаме на зграда `DP [i][j]`, имаме два избора:
 * Да се спуштиме еден кат подолу во истата зграда `DP[i][j] = people[i][j] + DP[i][j-1]`
 * Да скокнеме на друга зграда (онаа која има најголем `DP` на катот `j - I`)

Првобитното решение кое го пробав е со `O(N^3)` сложеност. Според точките горе, со bottom-up динамичко ја решавав задачата. За секој кат `(i,j)` во секоја зграда (почнувајќи од сите згради со првиот кат, па сите згради со вториот кат, итн) ги споредував катот `(i,j-1)` со сите катови на висина `j-I`. Но заради големата сложеност овој алгоритам паѓаше временски, што значи дека `O(N^3)` сложеноста не поминува.

Овој код можеше да се оптимизира на следниов начин: наместо секогаш да проверуваме кој кат има најголем `DP` на висината `j-I`, можевме да провериме еднаш и да го запишеме бројот на најголемиот кат на таа висина. Бидејќи сега имаме еден циклус помалку (за секој кат во секоја зграда имаме само `if` услови наместо `for` циклус), ја намаливме сложеноста на `O(N^2)` која е доволна да помине решението. Кога е пополнета целата матрица, го печатиме најголемиот елемент од врвот на сите згради.

```
#include <iostream>
#include <cstring>

using namespace std;

int DP[1900][1901];
int people[1900][1901];
int n,h,I;

int main()
{
    ios_base::sync_with_stdio(false);
    cin>>n>>h>>I;

    memset(DP,0,3611900*sizeof(int));
    memset(people,0,3611900*sizeof(int));

    for(int i=0;i<n;i++)
    {
        int temp;
        cin>>temp;
        while(temp--)
        {
            int floor;
            cin>>floor;
            people[i][floor]++;
        }
    }

    int bestonfloor[h+1];
    int tempbest=0;

    bestonfloor[0]=0;

    for(int i=1;i<=h;i++)
    {
        tempbest=0;
        bestonfloor[i]=0;
        for(int k=0;k<n;k++)
        {
            DP[k][i]=DP[k][i-1];
            if(i-I>=0)
                DP[k][i]=max(DP[k][i],DP[bestonfloor[i-I]][i-I]);
            DP[k][i]+=people[k][i];
            if(DP[k][i]>tempbest)
            {
                tempbest=DP[k][i];
                bestonfloor[i]=k;
            }
        }
    }

    cout<<DP[bestonfloor[h]][h];
    
    return 0;
}
```

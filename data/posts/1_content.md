За прв пост на овој блог ќе го искористам неодамнешниот Codeforces натпревар. По кратката посета на прва дивизија (само еден натпревар, каде не решив ништо), за овој натпревар повторно бев во втората. Со други зборови, прелесна прва задача и многу страшни кодови за читање при хакирање туѓи решенија.

Успеав да решам 3 задачи и да стигнам до 53-тото место, моето најголемо достигнување досега на Codeforces. Релативно лесни задачи, со исклучок на последните две кои едвај имаа 50 точни решенија (двете задачи заедно). Без да одолговлекувам многу, ова беа моите решенија.

## A - Drazil and Date
[Текст од задачата](http://codeforces.com/contest/515/problem/A)

Во задачата се работи за Drazil кој тврди дека од точка `(0,0)` до точка `(a,b)` има стигнато за `S` чекори (се работи за Декартов координатен систем). Тој може да се движи само во 4 насоки (горе, доле, лево, десно) Вашата задача е да проверите дали тоа е вистина или не (да испечатите "yes" или "no").

Стандардно за прва задача, решението беше доста просто. Бидејќи имаме само 4 насоки на движење, секогаш најкраткиот пат до `(a,b)` ќе е `|a| + |b|` (збир на апсолутните вредности на овие два броја). Доколку `S` е помало од `|a| + |b|`, знаеме дека не може да се стигне до таа точка. Доколку `S` е еднакво, тогаш најкраткиот пат е решението. Но доколку `S` е поголемо, тогаш Drazil би требало да оди напред/назад неколку чекори за да заврши на `(a,b)` после `S` чекори. За да го направи ова, потребни му се парен број на преостанати чекори `(S - (|a| + |b|) )`, бидејќи во спротивно нема да може да го направи напред/назад движењето и ќе остане на некое друго поле, а не на `(a,b)`.

Така да решението беше : доколку `s>= |a| + |b|` и `(s - (|a| + |b|))%2==0`, печатиме "Yes". Во спротивно, "No".

[Решение во C++](http://codeforces.com/contest/515/submission/9885156)
## B - Drazil and his happy friends
[Текст од задачата](http://codeforces.com/contest/515/problem/B)

За оваа задача немав идеја при првото читање, туку и се вратив на неа по решавање на третата. Во проблемот нашиот лик има `N` машки и `M` женски пријатели (нумерирани од 0 до `M` или `N`, највеќе 100), од кои некои се среќни, а некои тажни. Тој решава да ги направи сите среќни така што секој ден (почнувајќи од 0) тој ги поканува `(i%n)`-тото момче и `(i%m)`-тата девојка заедно на вечера. Доколку една од овие две личности е среќна, и другата станува среќна (и така остануваат среќни засекогаш). Но доколку не е никој од нив среќен, си остануваат несреќни. Од вас се бара да откриете дали со овој план сите ќе станат среќни (не е битно по колку дена).

Мојата грешка во натпреварот е што претпоставив дека brute-force решение нема да заврши за 2 секунди. Се испостави дека можеме да ги симулираме деновите еден по еден до некоја голема бројка (пример, милион дена), следејќи ги правилата. По тоа, доволно беше само да ги проверите сите пријатели (максимум 200), да проверите дали се сите среќни. Печатиме "Yes" доколку се, во спротивно "No".

![Пример за граф со 2 машки и 4 женски](https://aandevski.files.wordpress.com/2015/02/screenshot_2.png)

Моето решение беше малку поинакво. Доколку бројот на момчиња и девојчиња е ист, секогаш истите парови ќе се повторуваат. Но, доколку бројот е различен, тогаш ќе имаме повеќе различни парови (момче 1 може да излезе со девојка 1, па следниот пат со девојка 3, итн). Според ова направив граф, каде што темињата се машките и женските пријатели, а има врска помеѓу нив доколку некогаш би излегле на вечера. За да утврдам дали би излегле некогаш на вечера морав да употребам brute-force симулација, но за разлика од горенаведената, мојата симулација требаше да се изврши само за N*M дена за да ги добијам сите можни парови. Со добиениот граф, се што преостануваше е да извршам пребарување низ него (користев DFS во овој случај), започнувајќи од сите пријатели што се среќни и проширувајќи се кон сите поврзани темиња. На крајот само останува да провериме дали се сите среќни и да го испечатиме резултатот.

[Решение во C++](http://codeforces.com/contest/515/submission/9895082)
## C - Drazil and factorial
[Текст од задачата](http://codeforces.com/contest/515/problem/C)

Вообичаено третата задача е многу потешка, но не и на овој натпревар. Имаме дефинирано функција `F(x)` како производ од факториелите на неговите цифри. На пример, `F(135) = 1! * 3! * 5!`. За оние што не знаат што е факториел, тоа е производ на сите броеви од 1 до тој број. Пример, `5! = 1 * 2 * 3 * 4 * 5`.

Сега, назад на задачата. За даден број `A`, потребно беше да го најдеме најголемиот можен број `X` така што `F(A) = F(X)`. При тоа, не смееме да ги користиме цифрите 0 и 1 во `X`.

За да добиеме најголем број, треба да го добиеме најголемиот можен број на цифри. Така да потребно е сите факториели на броевите 2-9 да ги разложиме на што помали факториели. Бидејќи нема многу комбинации, ова можете да го пресметате и со лист и пенкало. Пресметките се следни:

* `9! = 7! * 3! * 3! * 2!`
* `8! = 7! * 2! * 2! * 2!`
* `6! = 5! * 3!`
* `4! = 3! * 2! * 2!`

Останатите броеви не можат да се разложат.

Кога веќе го знаеме ова, потребно беше само да го прочитаме бројот (што јас го направив со `char`, за да не мора да ги вадам цифрите од бројот една по една) и секоја цифра од горенаведената листа да ја разложиме на повеќе помали цифри. Бидејќи само цифрите 2, 3, 5 и 7 се појавуваат, можеме само да броиме која цифра колку пати ќе треба да ја има во резултатот. Потоа само треба да го испечатиме резултатот, со тоа што прво ги печатиме сите цифри 7, па 5, па 3 и на крајот 2 (за да добиеме што е можно поголем број).

[Решение во C++](http://codeforces.com/contest/515/submission/9891225)
## D - Drazil and tiles
[Текст од задачата](http://codeforces.com/contest/515/problem/D)

Како и вообичаено, не успеав да ја решам 4тата задача, и овој пат заради лоша претпоставка. Имаме `NxM` табла која треба да ја пополниме со 1x2 коцки (замислете домино коцки). При тоа, на некои полиња (означени со *), не треба да ставиме коцка. Нашата задача е да провериме дали е тоа возможно, и на колку начина. Доколку постои само еден распоред на коцките, го печатиме распоредот, во спротивно (доколку има повеќе од еден начин или пак нема ниту еден), печатиме "Not unique".

![Трите начина да ставиме коцка на некое поле од работ.](https://aandevski.files.wordpress.com/2015/02/screenshot_31.png)

На сите полиња кои се наоѓаат на работ на таблата можат да се стават коцки на 3 различни начина. На сите полиња од средина пак можеме да ставиме коцки на 4 начина, и 2 начина за ќошевите. Така да секогаш имаме повеќе начини за решавање. Но, благодарение на полињата означени со * (каде што не смееме да ставиме коцка), постојат полиња каде што имаме само еден начин на поставување. Во некој случај, доколку ставиме коцка на такво поле, се створаат нови полиња со само еден начин на поставување (бидејќи вториот им сме го покриле). Така продолжуваме се додека не стигнеме до полна табла. Доколку во некој момент немаме полиња со еден начин на поставување, печатиме "Not unique".

Пристапот за решавање е greedy (а мојата претпоставка беше дека greedy нема да даде точен одговор). И во оваа задача правиме граф, каде што секое поле е теме во графот и е поврзано со неговите соседни полиња. Правиме додатна низа каде што за секое поле бележиме со колку други полиња е поврзано (колку начини на поставување на коцка постојат). И за крај правиме queue во кој ги ставаме сите полиња кои имаат само едно соседно поле. Потоа, се додека има полиња во queue, ги вадиме едно по едно, и за сите негови соседни полиња им го намалуваме бројот на поврзани полиња за еден (и ги додаваме во queue доколку е потребно). Кога ќе стигнеме до празен queue, проверуваме дали сите полиња се покриени. Доколку не се, нема решение.

Оваа задача сеуште ја немам решено, а петата ја немам ни прочитано. Се надевам дека ќе ги решам во блиска иднина и ќе го изменам постот.

Неодамна добив една доста интересна задача за решавање, задачата <a href="http://mendo.mk/Task.do?id=555" target="_blank">Политичка Партија</a> од овогодинешните МОИ. При првото читање на задачата, првото решение што ми текна е претставување на партијата како кореново дрво и greedy бришење на темиња (што се испостави да не работи во секој случај). Како и да е, бидејќи порано немав решавано задачи со дрва (или воопшто користено дрва), иако успеав да ја решам задачата само 16/20, искуството со дрва ми се покажа доста корисно. Во продолжение ќе го објаснам моето решение на задачата.

## Што се дрва?

Доколку би ја сретнал оваа задача пред година дена, повторно би се сетил на greedy идејата, но би го имплементирал ова со граф. Кодот би бил доста посложен да се напише и најверојатно не би работел толку бргу (моето решение со дрва поминува за 0.1 секунда на најтешкиот пример со уште простор за оптимизација). Што е разликата помеѓу графови и дрва тогаш?

Технички гледано, дрвата се графови. Структура која содржи темиња и мостови кои ги поврзуваат тие темиња. Додатно, дрвото има некои додатни спецификации. Тоа не е насочено и нема циклуси. Кореново дрво е дрво каде што темињата кои се поврзани се во врска родител - дете. За секои две темиња кои се поврзани, едното е родител, другото е дете. Темето кое нема ниту еден родител се нарекува корен. Секогаш постои само еден корен во кореново дрво.

![Кореново дрво каде што A е коренот](http://www.csee.umbc.edu/courses/undergraduate/341/fall98/frey/ClassNotes/Class14/RootedTree.jpg)

Најголемата разлика е во начинот на претставување на дрвата во код. Додека за граф би користеле матрица на соседност или листи (низа од вектори) кои покажуваат која точка со кои е поврзана, за дрво користиме посебна структура за темињата. Во структурата зачувуваме покажувачи кон родителот на тоа теме и неговите деца. Подоцна правиме низа од таа структура и со покажувачите ги дефинираме врските помеѓу темињата.

```
struct Node
{
    Node* parent;
    vector<Node> children;
}

Node nodes[50000];
```

За да работите дрва треба да имате основни познавања од објектно-ориентирано програмирање (структури) и покажувачи. Нема да навлегувам многу во детали за нешто што можете да го научите онлајн, туку ќе преминам на задачата.

## Решавање на Политички партии со дрва

Доколку не забележавте досега, политичката партија е секогаш кореново дрво, каде што членот 1 е секогаш коренот. За секое теме освен родителот и децата, треба исто така и да забележиме колкава е неговата лична моќ, и вкупната моќ (неговата моќ + вкупната моќ на сите негови деца). Додатно, чувам уште една `boolean` променлива која ми означива дали тој член е веќе избришан. Тука можете да забележите колкава предност ни даваат дрвата во однос на графови во оваа задача.

```
void calculateSubtree()
{
    sum=power; //Ставаме почетна вредност на сумата, личната моќ на тоа теме
    for(int i=0;i<children.size();++i) //Ги изминува сите деца
    {
        children[i]->calculateSubtree(); //Ја пресметува рекурзивно моќта на детето i
        sum+=children[i]->sum; //Ја додава пресметаната моќ на детето i на сумата
    }
}
```

Откако ќе го имаме внесено дрвото (врските родител-дете за сите темиња) и личната моќ на сите членови, доколку ја повикаме оваа функција за коренот на дрвото, рекурзивно ќе се пресмета вкупната моќ за сите членови во целото дрво. Уште полесно ни е бришењето на членови од партијата, што го правиме со две функции:

```
void deleteIt()
{
    for(int i=0;i<children.size();++i) //Ги изминува сите деца
        children[i]->deleteIt(); //Ги брише децата едно по едно
    changeParentSum(sum); //Ја намалува сумата на родителот
    deleted=true; //Го поставува темето како избришано
}
```

```
void changeParentSum(long long n)
{
    sum-=n; //Ја намалува сумата за дадениот број
    if(parent!=NULL) //Доколку темето има родител, ја намалува и сумата на родителот рекурзивно
        parent->changeParentSum(n);
}
```
Повторно, благодарение на рекурзија многу лесно можеме да бришеме членови од дрвото. Со ова задачата ни се сведува на:
 * Внесување на дрвото
 * Повикување calculateSubtree на коренот
 * Извршување K-пати
   * Наоѓање на членот со најмала вкупна моќ кој не е избришан
   * Бришење на тој член доколку вкупната моќ му е помала од 0
 * Печатење на сумата на коренот

```
    nodes[0].calculateSubtree();

    while(k--)
    {
        int smallest=-1;
        for(int i=0;i<n;++i)
        {
            if(!nodes[i].deleted && (smallest==-1 || nodes[i].sum < nodes[smallest].sum))
                smallest=i;
        }

        if(nodes[smallest].sum>0)
            break;

        nodes[smallest].deleteIt();
    }

    printf("%I64d",nodes[0].sum);
```

Единственото нешто што преостанува е конструкција на дрвото, што се испостави малку потешко за оваа задача.

## Конструкција на дрвото

За конструкција на дрвото користиме две додатни функции:

```
void addChild(Node* child)
{
    children.push_back(child);
}
```

```
void setParent(Node* p)
{
    parent=p;
}
```

Доколку имаме врска помеѓу `a` и `b` каде што `а` е родителот а `b` е детето, тогаш повикуваме

```
nodes[a].addChild(&nodes[b]);
nodes[b].setParent(&nodes[a]);
```

Но за дадена врска, како знаеме кој е родителот а кој е детето? Единствено што знаеме во задачата е дека 1 е коренот на ова дрво. Да го разгледаме следниов тест пример

```
3 2
1 3
```

Бидејќи знаеме дека 1 е коренот на дрвото, тогаш знаеме дека 1 е родителот на 3. Доколку го забележиме својството во задачата дека секое теме може да има само еден родител, тогаш со сигурност знаеме дека 3 е родителот на 2 (бидејќи 3 не може да има два родитела). Но бидејќи прво внесуваме 3 2, не знаеме дека 3 има родител и не можеме да ја запишеме оваа врска.

Едно решение би било изминување на целата низа се додека не се разрешат сите врски. Доколку и двете темиња немаат најдено родител, ги меморираме, прескокнуваме и пробуваме подоцна. Но доколку би имале тест пример што личи на :

```
5 4
4 3
3 2
2 1
```

овој алгоритам би работел многу поспоро. Со максимум (50,000) темиња, се работи за 1,250,025,000 проверки додека да се прочита целото дрво. Сигурно би можеле нешто побрзо да смислиме.

Друго решение е доколку користиме нешто слично на граф (низа од вектори) каде што ги зачувуваме сите врски кај кои немаме најдено родител. Доколку прочитаме броеви `a` и `b` и немаме најдено родители и кај двата, тогаш во `vec[a]` го додаваме бројот `b` и во `vec[b]` го додаваме бројот `а`. Подоцна, кога ќе најдеме родител на некое теме (да кажеме теме `x`), тогаш сите темиња од `vec[x]` ги поставаме да се деца на `x`. Ова се извршува рекурзивно за да го генерираме целото дрво. Користиме додатна `boolean` низа `found` која ни означува дали родителот на некое теме е пронајден (иако може да се имплементира ова и со `parent` покажувачот)

```
for(int i=0;i<n-1;++i)
{
    scanf("%d%d",&a,&b);
    --a; //Ги намалуваме броевите бидејќи низата започнува од 0
    --b;
    if(!found[a]) //Доколку не е пронајден родителот на а, ги заменуваме да провериме дали е пронајден родителот на b
    {
        swap(a,b);
    }
    if(!found[a]) //Доколку не е пронајден ниту овој родител, тогаш ги запишуваме во векторите
    {
        vec[a].push_back(b);
        vec[b].push_back(a);
    }
    else //Пронајден е родител, така да можеме да ја поставиме врската, и да повикаме реконструкција на b за да се додадат врските од векторот
    {
        nodes[a].addChild(&nodes[b]); 
        nodes[b].setParent(&nodes[a]);
        reconstruct(b);
    }
}
```


```
void reconstruct(int n)
{
    if(found[n]) //Доколку е веќе пронајден родителот на темето, нема што да смениме, се враќаме назад
        return;
    found[n]=true;
    for(int i=0;i<vec[n].size();++i)
    {
        if(!found[vec[n][i]])
        {
            nodes[n].addChild(&nodes[vec[n][i]]);
            nodes[vec[n][i]].setParent(&nodes[n]);
            reconstruct(vec[n][i]);
        }
    }
}
```

За ова да работи потребно е низата `found` да е иницирана на `false`, освен коренот на дрво кој е поставен на `true` (бидејќи не треба да има родител). Ова го заклучува решението на задачата, кое поминува на 16/20 тест примери.

## Зошто решението не работи целосно
Идејата не е добра. Да го разгледаме следниов тест пример.

![](https://aandevski.files.wordpress.com/2015/07/screenshot_19.png)

Замислете дека дрвото уште продолжува нагоре. Сумата на темето 1 од лева страна би била -26, додека сумата на темето 1 кое е родител на сите би била -39.

Според нашата greedy идеја, најдобро решение би било да го избришеме горното теме 1, со што вкупната вредност ќе ни се зголеми за 39. Но дали секогаш е така? Да замислиме дека сите други темиња во дрвото се позитивни. Тогаш:

 * Доколку смееме да избришеме еден член, го бршеме родителот и збирот ни се зголемува за 39.
 * Доколку смееме да избришеме два члена, ги бришеме децата од лева и десна страна (со вредностите 1 и -15), така да сумата ни се зголемува за 41
 * Доколку смееме да избришеме три члена, ги бришеме членовите со вредности -20, -15 и -8. Вкупната сума ни се зголемува за 43.

Бидејќи изборот ни зависи од тоа колку членови треба да избришеме, не можеме со greedy да правиме избор. Не се сетив на овој пример кога почнав да ја решавам задачава, но бев изненаден како може да се добијат 80 поени со вакво решение. Мислам дека решението на оваа задача ќе се базира на динамичко, но сеуште ја немам размислувано или решавано во таа насока.

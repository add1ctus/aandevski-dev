Бидејќи овие неколку дена не учествував во онлајн натпревари (всушност и немаше многу), решив да објаснам една малку потешка задача од вообичаено, Селфи од МОИ 2014. Идејата за оваа задача ја добив уште на натпреварот, но добив само 30 од 100 поени заради недоволна оптимизација и губење на прецизност. Идејата на задачата не е толку тешка, колку што е тешка имплементацијата (решението е скоро 200 линии код), така да не би ја препорачал задачата за почетници.

[Линк до задачата](http://mendo.mk/Task.do?id=480)

Прво нешто што треба да знаеме е што е потребно за некој број да е „селфи број“? Текстот ни кажува дека цифрите 0,1 и 8 се симетрични сами со себе, додека 5 и 2 се заемно симетрични. Така да, доколку некој број содржи друга цифра освен овие, тој не е е селфи број. Доколку бројот се состои само од тие цифри, тогаш тој треба да е палиндром - со една забелешка. Доколку од една страна на бројот имаме 2, од друга страна треба да имаме 5 (или обратно). Така да иако бројот `8228` е палиндром, не го броиме како селфи број, додека броевите `8258` и `8528` ги броиме.

Постојат две brute force решенија (кои сами по себе би го надминале временскиот лимит):

 * Проверување на сите броеви од `p` до `k` (еден по еден) дали се селфи броеви
 * Генерирање на сите селфи броеви и проверување кои се во опсегот `[p,k]`

Со првото решение може да имаме вкупно 1,000,000,000,000,000,000 броеви за тестирање, што е крајно неоптимизирано, доколку земете во предвид дека треба да ги вадите цифрите една по една од секој од тие броеви.

Доколку ги генерираме сите броеви кои се состојат од цифрите 0,1,2,5,8, долги помеѓу 1 и 18 цифри тогаш треба да генерираме вкупно 6,657,201 броеви. Но сепак бидејќи на нас ни се потребни само палиндроми, можеме да ги генерираме броевите долги помеѓу 1 и 9 цифри и да ги пресликуваме за да добиваме броеви од 1 до 18 цифри. Така да вкупниот број на броеви што треба да ги генерираме е 120,852, што и не е толку голем број. Доколку ги исклучиме сите броеви што почнуваат со 0, овој број се намалува уште повеќе. Голема разлика од првобитните 1,000,000,000,000,000,000 што требаше да ги проверуваме, но сепак не е доволно оптимизирано бидејќи треба секоја комбинација да ја проверуваме дали е поголема од `P` и помала од `K`.

За додатна оптимизација може да се употреби динамичко програмирање, кое ќе елиминира многу броеви кои треба да се генерираат. Да погледнеме колку селфи броеви има со `N` цифри:

```
1 цифра - 3 броја (0, 1, 8)
2 цифри - 4 броја (11, 25, 52, 88)
3 цифри - 12 броја (101, 111, 181, 205, 215, 285, 502, 512, 582, 808, 818, 888)
4 цифри - 20 броја
5 цифри - 60 броја
...
```

Секако, не ги броев сите 60 5-цифрени броја рачно, туку има начин како да ги добиеме (за сите броеви освен 1 и 2 цифрените). Доколку имаме селфи броеви со 2 цифри, тогаш можеме да добиеме 3 цифрени селфи броеви така што во средината ќе додадеме една од цифрите 0, 1 или 8. Бидејќи можеме 3 броја да добиеме од секој број, тогаш `број на 3-цифрени броеви = број на 2-цифрени броеви * 3`. Истото важи за сите непарни броеви на цифри (добивање на 5-цифрени од 4-цифрени, итн). Доколку пак имаме 2-цифрени броеви и сакаме да ги добиеме сите 4-цифрени селфи броеви, тогаш тоа може да се постигне со додавање на еден од овие броеви во средина на бројот: `00`, `11`, `25`, `52`, `88`. Бидејќи имаме 5 различни броеви добиено, тогаш `број на 4-цифрени броеви = број на 2-цифрени броеви * 5`. Истото важи за сите парни броеви на цифри.

Според ова, со просто динамичко програмирање можеме да ја генерираме низата:

```
dp[2]=4;
for(int i=3;i<19;i++)
    if(i%2==0)
        dp[i]=dp[i-2]*5;
    else
        dp[i]=dp[i-1]*3;
```

Така да, на пример, кога би се внеле броевите `p=20` и `k=123,456,789,123,456,789`, тогаш ние само треба да ги пронајдеме сите 2-цифрени и 18-цифрени селфи броеви. Бројот на сите останати селфи броеви е збирот на сите броеви од `dp[3]` до `dp[17]`. Тука најлош случај би било кога треба да се генерираат сите 17 и 18 цифрени броеви, за што треба да ги генерираме сите комбинации од 8 и 9 цифри (кои би ги пресликале). Тоа се вкупно 59,049 9-цифрени броеви и 32,768 8-цифрени броеви. Но бидејќи при пресликување на 8-цифрените броеви добиваме 16-цифрени броеви, потребно е на сите да им додаваме по една цифра во средина (0, 1 или 8), така да имаме вкупно 98,304 проверки на 8-цифрени броеви, вкупно 157,353.

Сега, кога ја знаеме идејата доаѓа вистинскиот проблем: имплементацијата. За запишување на броевите имаме неколку избора:

 * `long long integer` - Лесно е да се провери дали некој број е помеѓу границите `p` и `k`, но споро се генерираат броевите (многу множење и делење).
 * `string` - Спора проверка на броеви (цифра по цифра почнувајќи од лево), но побрзо генерирање на броевите (само додаваме и одземаме букви од стрингот)
 * `vector<int>` - Исто така имаме спора проверка на броеви, но брзо генерирање. Бидејќи ја имаме опцијата `pop_back()` за бришење на последната цифра и никаде не претвораме `char` во `int` или обратно, овој метод е најдобар.

Со цел полесно пишување и снаоѓање во кодот, го поделуваме на повеќе функции:
 * `int broj_na_palindromi (int n)` - Враќа колку `n`-цифрени селфи броеви постојат во дадено ограниичување. Ги генерира сите `n/2` цифрени комбинации што не започнуваат со 0
 * `int mirror (vector<int> &v)` - Зема вектор со `n/2` цифри и го пресликува за да добие селфи број. Проверува дали тој селфи број е во ограничувањата. Доколку треба да проверува селфи броеви со непарен број на цифри, ги додава цифрите 0, 1 или 8 во броевите. Враќа број на селфи броеви што се во ограничувањата (0 или 1 за парни броеви, од 0 до 3 за непарни)
 * `bool test(vector<int> &v)` - Проверува дали добиениот број од `mirror` е во ограничувањата или не. Враќа `true` или `false`.
 * `int brojNaCifri (long long n)` - Проста функција за проверка колку цифри има некој број

Функцијата `broj_na_palindromi` се имплементира рекурзивно, така што ги генерира сите 1-цифрени комбинации, па на нив додава броеви за да направи 2-цифрени комбинации, итн додека не стигнеме до `n`-цифрена комбинација. За да не подаваме параметри на секое рекурзивно повикување, можеме да направиме еден глобален вектор кој ќе го користиме со таа функција.

Функцијата `mirror` е доста проста за имплементација. Додаваме цифри на крајот на векторот, повикуваме `test` функција и ги тргаме од крајот на векторот по проверката. Доколку треба да генерираме броеви со непарен број на цифри, тогаш ќе тестираме и пресликуваме 3 пати, така што додаваме една од цифите 0,1 или 8 на крајот па тогаш ги пресликуваме сите цифри освен последната.

За функцијата `test` потребно е да имаме уште 2 глобални вектора што го означуваат опсегот. На пример, доколку треба да ги пресметаме броевите од 20 до 1200, тогаш ги генерираме броевите во опсегот [20,99] и [1000,1200], а останатите ги добиваме со динамичко програмирање. Доколку опсегот е претставен со векторите `limit1` и `limit2`, тогаш векторот `v` треба да е помал од `limit2` ама поголем од `limit1`.

Функцијата за број на цифри е проста функција каде што го делиме бројот со 10 и броиме колку пати сме го поделиле. При тоа важно е бројот 0 да го броиме како број со 1 цифра.

Кога веќе ги знаеме сите функции, останува само `main` функцијата да се напише. Ги читаме броевите `a` и `b`, ги запишуваме нивните броеви на цифри во посебин променливи и ја пополнуваме низата `DP`. Го додаваме збирот од `DP[cifria+1]` до `DP[cifrib-1]` во резултатот. Сега имаме два избора:
 * `cifria==cifrib` - Во тој случај `limit1=a` и `limit2=b`, само е потребно да ги пополниме векторите и да повикаме функција.
 * `cifria!=cifrib` - Во тој случај ја повикуваме функцијата 2 пати, прво за `limit1=a`, `limit2=10^(cifria-1)-1`, а после за `limit1=10^(cifrib-1), limit2=b`

Одкога ќе го додадеме резултатот од функцијата во резултатот, го печатиме резултатот.

[Решение во C++](http://pastebin.com/x0y6EEAk)

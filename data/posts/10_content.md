Иако сеуште нема официјални информации за тоа кој се ќе учествува на државниот натпревар, би сакал да им честитам на сите што ќе бидат изберени. За останатите, не се разочарувајте. Побогати сте со една година искуство и можеби некое ново пријателство, кое многу значи (од лично искуство - сум имал натпревари со 0 поени). Искористете го ова како мотивација да вежбате и научите нешто ново, за да успеете наредниот натпревар. Знаењето кое ќе го стекнете ќе ви е многу корисно и за во иднина, не само за натпреварите (како студент можам да ви кажам дека со добри резултати на натпревариве можете да добивате супер оценки по програмирање на факултет).

За жал никој ја немаше решено последната задача, но би сакал исто така да ги спомнам Марија и Дамјан, единствените што успеаа да ја решат четвртата задача. Честитки! А сега, да ги разгледаме задачите...

## Штрајк
[Текст од задачата](http://mendo.mk/Task.do?id=533)

Во задачата ни се откриени само две работи: колку седмици трае регуларното полугодие (секогаш 18), и колку денови траел штрајкот (внесен како `N`, од 0 до 30). Кога завршува штрајкот, може веднаш да се започне со одработување на изгубените денови во сабота, а кога ќе поминат првобитните 18 седмици, тогаш ги обработуваме изгубените денови 6 дена во седмица.

Да решаваме чекор по чекор. За да знаеме колку денови ќе се одработат во првите 18 седмици, потребно е да знаеме кога сме започнале со одработување саботи. Доколку го поделиме бројот `N` со 5, ќе знаеме колку седмици имаме изгубено целосно (каде што сеуште траел штрајкот и не можеме да учиме во сабота). Така да можеме да одработиме `18-N/5` саботи. Доколку овој број е поголем или еднаков од бројот на изгубени денови (доколку `18-N/5 >= N`), тогаш можеме да ги одработиме сите изгубени денови во саботите кои се дел од школската година. Во тој случај, печатиме 0 (бидејќи нема да се продолжи школската година).

Во вториот случај, и покрај одработување саботи, сеуште имаме настава која треба да се одржи на крајот на школската година. Со `N-(18-N/5)` можеме да провериме уште колку денови треба да се одработат. Бидејќи работиме по 6 дена во седмица тогаш со `(N-(18-N/5))/6` можеме да добиеме колку дополнителни седмици ќе се потребни за одработување. При тоа, треба да внимаваме на едно нешто: дури и да имаме само 1 додатен ден за одработување, тоа се брои како цела седмица (така да бројот што ќе го добиеме треба да го заокружиме на најблискиот број поголем од добиениот). За тоа ја користиме `ceil` функцијата и делиме со 6.0 наместо 6 (за да добиеме резултат како децимален број). Го печатиме добиениот број.

[Решение во C++](http://pastebin.com/8PsJGNd3)

## Булевар

[Текст од задачата](http://mendo.mk/Task.do?id=538)

Малите броеви ни дозволуваат brute force решение. Правиме две низи од тип `boolean` кои ни ги означуваат парцелите на двете страни на булеварот. Ставаме `true` доколку можеме да ставиме нова зграда таму, во спротивно `false`. На почетокот сите вредности се `true`. Ги внесуваме зградите една по една и проверуваме на која страна се наоѓаат. Да замислиме дека зградите се подредени на овој начин:

```
1 2
3 4
5 6
7 8
9
```

За дадена зграда `X`, таа се наоѓа од левата страна доколку `X%2==1`, во спротивно се наоѓа од десната страна. За да откриеме на која позиција на таа страна се наоѓа, го делиме бројот со 2. Додатно, доколку зградата е од десната страна, одземаме еден од бројот (бидејќи почнуваме да броиме од нулта позиција). Сега кога веќе знаеме на која страна и на која позиција е зградата, треба да ги означиме сите полиња од `позиција-м` до `позиција+м` како зафатени на таа страна.

Кога веќе знаеме кои полиња се слободни, само е потребно да додадеме нови згради на слободните полиња. При тоа, секогаш кога ставиме нова зграда на позиција `X`, го зголемуваме бројачот за 1 и позициите од `X` до `X+M` ги означуваме како зафатени. Истото го правиме за двете страни. На десната страна имаме вкупно `n/2` парцели, но на левата страна има `n/2+n%2` парцели (доколку има непарен број на парцели, тогаш левата страна ќе има една парцела повеќе). Го печатиме бројачот.

[Решение во C++](http://pastebin.com/ZwArQYtZ)

## Топки

[Текст од задачата](http://mendo.mk/Task.do?id=539)

Неколку клучни забелешки:
 * Бидејќи веќе имаме сортирана низа, заради најмалку додавања на топки потребно е децата од левата страна да имаат повеќе топки од децата на десната страна, така да првите `m%n` деца ќе имаат `n/m+1` топки, а останатите ќе имаат `n/m` топки на крајот
 * Бидејќи ќе имаме повеќе топки од потребно на левата страна и помалку од потребно на десната страна, секогаш даваме топки од лево кон десно
 * Потребно е да го минимизираме растојанието на додавањата. Пример, доколку додаваме од позициите 1 и 2 кон позициите 3 и 4, тогаш се додава 1->3 и 2->4.

Можеме да направиме queue од парови каде што ќе ги ставаме сите топки што ги имаме и ќе забележуваме на која позиција се наоѓаат, внесувајќи дете по дете од левата страна. Веднаш искористуваме колку топки ни се потребни и ги задржуваме на таа позиција, а останатите ги оставаме во queue. Доколку немаме вишок топки останато, детето го вадиме од queue. Доколку имаме некое дете кое има помалку топки од потребното, тогаш земаме топки од првото дете од лева страна кое има вишок топки (првиот член во queue), се додека немаме доволно топки. Секогаш при земањето на вишок топки ги бришеме децата кои снемале вишок топки од queue.

За да додадеме топки од дете `X` до дете `Y`, потребно е да направиме `Y-X` додавања. Го наоѓаме најголемиот број `Y-X` за сите додавања што ќе ги направиме, и го печатиме најголемиот број.

Задачата би можела да се реши и без queue, така што ќе водиме евиденција кое е детето најлево што има вишок топки.

[Решение во C++](http://pastebin.com/H0PrqWFx)

## Монитор

[Текст од задачата](http://mendo.mk/Task.do?id=534)

Да замислиме дека имаме некоја функција `F(x,y)` = број на линии во правоаголник кој започнува од точките `x,y` и завршува во точките `x+k,y+k`. Ја проверуваме оваа вредност за сите `x,y` од `0,0` до `n-k,m-k` и го печатиме најмалиот број. Во најлош случај би требало да направиме највеќе 100,000,000 проверки, кои се изводливи во 1 секунда. Проблемот е во наоѓање на бројот на линии во тој замислен правоаголник, бидејќи ако тоа трае повеќе време, кога ја вршиме проверката 100,000,000 пати, лесно можеме да го надминеме временскиот лимит.

Клучот тука е меморизација - да пресметаме само еднаш колку линии имаме и да ги запишеме резултатите во некои променливи. Бидејќи се работи за највеќе 20,000 линии, тоа не би зафатило ни 1MB меморија, што е изводливо (меморискиот лимит е 64MB). На кој начин го правиме тоа?

Во низа `ver[n]` можеме да ги запишеме бројот на расипани линии, така што `ver[x]` = број на расипани колони од 0 до x. Исто така правиме за хоризонталните линии со низа `hor[m]`, каде што `hor[x]` = број на расипани редови од 0 до x. Доколку првиот ред ни е расипан, тогаш `hor[0]=1`, во спротивно, `hor[0]=0`. Истото важи и за вертикалните линии. Преостанатиот дел од низата можеме да го пополниме на следниов начин:

 * Доколку `x`-тиот ред/колона е расипан, тогаш `ver/hor[x]=ver/hor[x-1]+1`
 * Доколку `x`-тиот ред/колона не е расипан, тогаш `ver/hor[x]=ver/hor[x-1]`

Со ова можеме лесно да го добиваме бројот на линии во било кој правоаголник. Број на вертикални линии измеѓу колоните `a` и `b` е `ver[b]-ver[a-1]`. Така да `F(x,y) = ver[x+k-1]-ver[x-1] + hor[y+k-1] - hor[y-1]`. Ги проверуваме сите точки и печатиме најмал резултат на `F(x,y)`.

[Решение во C++](http://pastebin.com/xhd3LebQ)

# Автопат
[Текст од задачата](http://mendo.mk/Task.do?id=537)

Да замислиме граф со `K` темиња, означени од 1 до `K` каде што секое теме означува контролна точка. Две темиња се поврзани доколку го знаеме растојанието помеѓу нив. Бидејќи се работи за можни 10,000 полиња, не можеме графот да го претставиме како матрица и мора да користиме вектор од вектор од парови, каде што во вектор`[x]` ги имаме сите темиња поврзани со `x`, каде што првиот член на парот е бројот на поврзаното теме а вториот член на парот е далечината.

Доколку темето `a` е поврзано со `b` и темето `c` е поврзано со `b`, тогаш можеме да го откриеме патот помеѓу `a` и `c`. Така да треба да го изминеме графот со почеток од темето `t1`. Доколку успееме да стигнеме до `t2`, можеме да го добиеме решението. Во спротивно, печатиме -1. Тоа може да се постигне со DFS. Чуваме низа `dalecini` која означува колку е растојанието на секое теме од темето t1, исто така и низа `poseteno` која означува за која точка знаеме растојание.

Го започнуваме DFS-то од точката `t1`, и притоа го правиме следново. Доколку ја посетиме точката `X` од точката `Y`, тогаш растојанието на точката `Y` (растојанието на `X` го веќе имаме) е:

 * `dalecini[X]` + растојание од `X` до `Y` (доколку `Y > X`)
 * `dalecini[X]` - растојание од `X` до `Y` (доколку `X > Y`)

Притоа вреди да се спомне дека за сите точки помали од `t1`, далечината ќе е негативен број. За да го спречиме печатењето на негативен резултат доколку `t1` е поголемо од `t2`, ги заменуваме двете променливи во тој случај. Кога полето `t2` е посетено, DFS-то може да прекине и го печатиме резултатот. Но доколку DFS-то ги помине сите можни точки и сеуште не е точката `t2` посетена, тогаш печатиме -1.

[Решение во C++](http://pastebin.com/2tf7EeYm)

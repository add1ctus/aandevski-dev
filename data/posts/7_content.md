Интересно нешто кај американските државни натпревари е тоа што се отворени за сите учесници од целиот свет. Имаат 3 месечни натпревари и додатен US Open натпревар, според чии резултати ги покануваат најдобрите 16-24 ученици на 10-дневен тренинг камп каде што се избираат претставниците за Интернационалната Олимпијада по Информатика (ИОИ). Ова е интересно доколку сакате да видите колкави шанси би имале да ги претставувате САД на ИОИ, така да се одлучив да учествувам на овој натпревар.

Натпреварот е поделен во 3 дивизии(Bronze, Silver, Gold). Вашиот прв натпревар е во Bronze дивизијата. Промоција во наредната дивизија зависи од вашиот резултат во натпреварите. Системот е направен така да можат да даваат многу тешки задачи на најјаките кандидати за да се изберат најдобрите за кампот, но сепак постојат и лесни задачи за да ги мотивира почетниците.

Сега, за натпреварот. Бидејќи ги пропуштив првите 2 месечни натпревари (во Декември и Јануари), сега започнувам во бронзената дивизија, каде што задачите беа прилично лесни. Успеав за нешто помалку од еден час да ги решам сите задачи (натпреварот трае 4 часа), кои поминаа 100% (резултатите ги добивате веднаш одкако ќе пратите решение). Да ги погледнеме задачите.

## Censoring

[Текст од задачата](http://pastebin.com/6TmFLkyQ)

Во задачата имаме дадено некој стринг `S` со максимална должина од 100,000 карактери и друг стринг `T` со максимална должина од 100 карактери. Потребно е да ги избришеме сите појавувања на стрингот `T` во стрингот `S` и да го испечатиме резултатот. На пример, доколку `S=abcdef` и `T=cd`, резултатот ќе е `abef`. Временското ограничување е 2 секунди.

Интересно нешто е што при бришење на една инстанца на стрингот T, може да се појави друга. На пример, `S=abccddef` и `T=cd`. Кога ќе го избришеме стрингот `cd` кој се наоѓа на позициите 4 и 5(доколку броиме од 1), ќе го добиеме стрингот `abcdef`, каде што повторно го имаме стрингот `T`. Исто и тука резултатот ќе е `abef`.

Заради тоа е потребно секогаш кога ќе избришеме некој дел од стрингот да се вратиме назад во стрингот наместо да продолжиме да бараме од истата позиција. Ова може да се изведе со готови функции:

```
while( (position=input.find(censor)) != string::npos)
input.erase(position,censor.size());
```

Но ова пребарување секогаш започнува од почетокот на стрингот. Да кажеме дека имаме стринг од 100,000 карактери каде што во првите 50,000 карактери не се појавува стрингот `T`, а во втората половина стрингот `T` се појавува многу пати. При секое бришење на некој стринг `T`, овој алгоритам ќе започне да бара од почеток, што ќе ја зголеми временската сложеност многу.

Затоа е потребно да направиме наше пребарување, каде што доколку избришеме некој стринг, потребно е да се вратиме само `Т.size()-1` места назад, што е доволно да провериме дали бришењето на стрингот создало некои нови стрингови. За додатна оптимизација (иако програмот би поминал и на овој начин за 2 секунди), можеме да ги зачуваме должините на стринговите во посебни променливи наместо да ги проверуваме секогаш. Доколку одиме со овој пристап, тогаш мораме должината на стрингот `S` да ја намалуваме секогаш кога бришеме букви од него.

[Решение во C++](http://pastebin.com/WM3m2dVG)

## COW
[Текст од задачата](http://pastebin.com/ENCu8xv2)

Повторно работиме со стрингови. Овој пат, имаме дадено стринг со максимум должина 10,000 кој се состои од буквите `C`, `O` и `W`. Потребно е да пронајдеме колку пати се појавува зборот `COW` во тој стринг. Притоа, треба да ги броиме сите комбинации на буквите `C`, `O` и `W` (кои се во тој редослед), без разлика и да има други букви измеѓу нив. На пример, во стрингот `CWOW` зборот `COW` се појавува еднаш. Во стрингот `CCOOWW` зборот се појавува 8 пати.

За да го добиеме резултатот, го изминуваме стрингот буква по буква, и ги бележиме следниве променливи:
 * `c`: Колку букви `C` сме поминале од почетокот на стрингот
 * `co`: Колку различни комбинации `CO` би имале доколку следната буква е `O`
 * `result`: Колку различни комбинации `COW` имаме добиено до сега

Третата точка е резултатот кој го печатиме, а сега ќе видиме зошто ни се потребни првите 2. Доколку на `i`-тата позиција е внесена буквата `W`, треба да знаеме колку зборови формира таа. За тоа ни е потребно да знаеме колку букви `C` и `O` сме веќе поминале во интервалот `[1..i-1]`. Но за тие букви мора да знаеме колку пати буквата `C` е пред буквата `О`. Пример, во стринговите `OCW` и `COW`, кога ќе стигнеме до 3тата позиција и во двата случаја имаме по една буква `C` и `O` изминато, но само во вториот случај имаме збор `COW`. Така да потребно е да знаеме колку комбинации на буквите `CO` (во тој редослед) сме поминале. Секогаш кога сретнеме буква `W`, `result` променливата ја зголемуваме за `co`. Тоа ни е втората променлива.

Втората променлива можеме да ја добиеме со истата теорија. Доколку сретнеме буква `O` на `i`-тата позиција, тогаш треба да знаеме колку комбинации `CO` можеме да постигнеме со таа буква. Одговорот е бројот на буквите `C` кои се веќе поминати во интервалот `[1..i-1]`. Така да секогаш кога ќе сретнеме буква `O`, променливата co ја зголемуваме за `c`.

Првата променлива е јасна сама по себе. Секогаш кога ќе сретнеме буква `C`, променливата ја зголемуваме за еден.

[Решение во C++](http://pastebin.com/jv0iEX4g)

## Cow hopscotch

[Текст од задачата](http://pastebin.com/r4ZgJrP9)

Додека првите две задачи ги решив со ad hoc, третата бараше основни алгоритми. Во овој случај, требаше да знаете теорија на графови и DFS (или пребарување по широчина). Имате дадено матрица (со максимални димензии 15х15) која се содржи од црвени и сини полиња (означени со `R` или `B` карактери). Постои игра во која што се движите од горниот лев агол кон долниот десен агол, така да:
 * Доколку се наоѓате на колона `X`, смеете да скокнете само кон сите колони поголеми од `X`
 * Доколку се наоѓате на редицата `X`, смеете да скокнете само кон сите редици поголеми од `X`
 * Смеете да скокнете само на полиња со различна боја од полето на кое стоите

Така да мора секогаш да се движиме во таа насока (доле, десно), и да скокаме наизменично помеѓу црвени и сини полиња. Од вас се бара да го најдете бројот на начини (различни патови) за да стигнете од почетокот до крајот на оваа матрица.

Доколку имате веќе решавано задачи со DFS, решението е просто. Доколку се наоѓате на точка `x,y`, следниот чекор го правите на било која точка `a,b` каде:
 * `a > x`
 * `b > y`
 * `boja[x][y] != boja[a][b]`

При тоа не водиме евиденција на тоа кои полиња се посетени (бидејќи за да најдеме број на различни начини да стигнеме до крајот, треба исти полиња да посетуваме повеќе пати), и секогаш кога стигнеме до крајот, го зголемуваме резултатот за 1. Тоа може да го направиме со глобална променлива или пак да го враќаме рекурзивно резултатот. Било кој начин ќе работи добро, во прашање е личен вкус. Јас го избрав вториот начин.

[Решение во C++](http://pastebin.com/VR3ENRdr)

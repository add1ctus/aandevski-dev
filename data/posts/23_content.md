*Note to self: Никогаш не користи cin/cout наместо scanf/printf. Може да те чини 1000+ поени.*

Уште еден релативно лесен натпревар за втората дивизија со 4 задачи кои носат помалку од 2000 поени. Успеав првите 3 да ги решам за 18 минути (при што првата ја решив за 1 минут, нов личен рекорд). Четвртата задача, иако точна, не поминуваше на временскиот лимит заради користење на cin/cout. Учиме на грешките.

## A - Soldier and Bananas

[Линк до задачата](http://codeforces.com/problemset/problem/546/A)

Многу краток текст (што е реткост) кој ја објаснува задачата на прост начин. Потребно е само да го направите тоа што се бара: да ги соберете цените на сите банани (со помош на `for` циклус) и да проверите дали фалат уште пари или имате доволно. Истото може и да се направи така што од променливата со пари ги одземате цените на бананите. Доколку бројот е помал од 0, значи ви фалат пари, во спротивно, печатите 0.

```
#include <iostream>

using namespace std;

int main()
{
    int number,dollars,k;
    cin>>k>>dollars>>number;
    for(int i=1;i<=number;i++)
        dollars-=k*i;
    if(dollars>0)
        cout<<0;
    else
        cout<<dollars*-1;
    return 0;
}
```

## B - Soldier and Badges

[Линк до задачата](http://codeforces.com/problemset/problem/546/B)

Повторно лесна задача која има повеќе начини за решавање. Го користиме фактот дека можеме само да ги зголемуваме броевите, но не и намалуваме. Започнуваме од најмалиот број (користам priority queue за да не се мачам со сортирање цело време) и користам додатна мапа `<int, bool>` за да забележам кој број го веќе имам земено (бидејќи не смееме да имаме дупликат броеви). Го земаме најмалиот број од queue-то. Доколку тој број прв пат се појавува, само забележуваме `true` во мапата. Во спротивно, го зголемуваме бројот се додека не стигнеме до некој број што не се појавува во мапата. Бележиме колку пати зголемуваме некој број, го печатиме тој број на крај.

```
#include <iostream>
#include <queue>
#include <vector>
#include <functional>
#include <map>

using namespace std;

int main()
{
    priority_queue<int, vector<int>, greater<int> > Q;
    int n;
    cin>>n;
    for(int i=0;i<n;i++)
    {
        int temp;
        cin>>temp;
        Q.push(temp);
    }
    map<int, bool> found;
    int result=0;
    while(!Q.empty())
    {
        int top=Q.top();
        Q.pop();
        while(found[top])
        {
            top++;
            result++;
        }
        found[top]=true;
    }
    cout<<result;
    return 0;
}
```

## C - Soldier and Cards

[Линк до задачата](http://codeforces.com/problemset/problem/546/C)

Да го искористиме фактот дека постојат највеќе 10 карти. Во најлош случај потребни се 106 „борби“ за да има победник. Доколку има повеќе од 106 борби, значи резултатот е -1. Според начинот на кој играта се игра, може да користите 2 queue за двата играчи, каде што ги додавате картите. Ја вршиме објаснетата операција (споредување на првите 2 карти, ги ставаме на крај на играчот со поголема карта) се додека не се испразни некој шпил или бројот на операции е поголем од 106 (јас во мојот код ставив 10,000,000 заради безбедност, лол). На крајот само го печатиме резултатот.

```
#include <iostream>
#include <queue>

using namespace std;

int main()
{
    int n;
    cin>>n;
    queue<int> first,second;
    cin>>n;
    for(int i=0;i<n;i++)
    {
        int temp;
        cin>>temp;
        first.push(temp);
    }
    cin>>n;
    for(int i=0;i<n;i++)
    {
        int temp;
        cin>>temp;
        second.push(temp);
    }
    int stepCounter=0;
    while(stepCounter<10000000 && !first.empty() && !second.empty())
    {
        if(first.front()>second.front())
        {
            first.push(second.front());
            first.push(first.front());
        }
        else
        {
            second.push(first.front());
            second.push(second.front());
        }
        first.pop();
        second.pop();
        stepCounter++;
    }
    if(first.empty())
        cout<<stepCounter<<" "<<2<<endl;
    else if(second.empty())
        cout<<stepCounter<<" "<<1<<endl;
    else
        cout<<-1;
    return 0;
}
```

## D - Soldier and Number Game

[Линк до задачата](http://codeforces.com/problemset/problem/546/D)

Интересна и предизвикувачка задача. Да разгледаме прво според која логика вториот војник би ги бирал броевите. Бидејќи при секој избор на број ние всушност го делиме дадениот број со нашиот број, значи дека ние дадениот број го делиме на помали делители. Бидејќи целта ни е да ја извршиме таа операција што повеќе пати, потребно е да го разложиме дадениот број на што повеќе броеви. Максималното разложување се постигнува кога бројот ќе се разложи на прости броеви (кои понатаму не можеме да ги разложиме). Така да за даден број `x`, потребно е да знаеме од колку прости броеви се содржи.

Но да го разгледаме начинот на внесување на броеви. Знаеме дека факториелот се пресметува како:

```
a! = 1 * 2 * 3 * 4 .... * a
```

Бидејќи имаме делење на два факториела, имаме повторување на дел од множителите, кои што можеме да ги скратиме. Да земеме за пример `a=7` и `b=4`.

```
a! / b! = 1 * 2 * 3 * 4 * 5 * 6 * 7 / 1 * 2 * 3 * 4 = 5 * 6 * 7
```

Што значи дека на нас ни е потребно само да ги разложиме броевите 5, 6 и 7. Но бидејќи се работи за големи броеви (што ако треба да ги собираме сите множители од 1 до 5,000,000, милион пати?), заради оптимизација користиме динамичко програмирање (Range Sum Query). Користиме низа `int DP` каде што `DP[x]` означува колку прости множители имаат сите броеви од 1 до x. Со ова, доколку сакаме да ги добиеме множителите на сите броеви од 5 до 7 потребно е само да пресметаме `DP[7] - DP[4]`.

Како ја пополнуваме оваа низа? Најпрвин користиме Ератостеново сито (гуглајте Sieve of Eratosthenes доколку ова не ви звучи познато) за да добиеме две работи:

 * Листа на сите прости броеви (доколку е прост значи има само еден множител)
 * Некој множител на сите останати проеви

Зошто ни е второто потребно? Да го земеме за пример бројот 20. Тој може да се претстави како 2 * 10, што значи дека `DP[20] = 1 + DP[10]`. Така да првично ја пополнуваме `DP` низата така што на сите места на прости броеви ставаме 1, а на останатите ставаме некој прост број кој може да го подели тој број.

Потоа почнувајќи од најмалиот, сите елементи ги заменуваме со вистинската вредност на `DP` (број на прости множители), така што доколку сретнеме број различен од 1, на негово место ставаме `1+DP[x/DP[x]]`. Се што преостанува е да ја претвориме оваа низа во RSQ така што за сите `DP` правиме `DP[x]=DP[x-1]+DP[x]`.

На крајот само ги внесуваме сите броеви и ја печатиме разликата `DP[a]-DP[b]`.

```
#include <stdio.h>
#include <cstring>

using namespace std;

int DP[5000001];
bool isPrime[5000001];

int main()
{
    for(int i=0;i<5000001;i++)
        DP[i]=1;
    memset(isPrime,true,5000001);
    isPrime[0]=isPrime[1]=false;
    for(int i=2;i<2236;i++)
    {
        if(isPrime[i])
        {
            DP[i]=1;
            for(long long j=i*i;j<5000001;j=j+i)
            {
                isPrime[j]=false;
                DP[j]=i;
            }
        }
    }

    for(int i=2;i<5000001;i++)
        if(DP[i]!=1)
            DP[i]=1+DP[i/DP[i]];

    for(int i=2;i<5000001;i++)
        DP[i]=DP[i-1]+DP[i];

    int tests,a,b;
    scanf("%d",&tests);
    while(tests--)
    {
        scanf("%d%d",&a,&b);
        printf("%d\n",DP[a]-DP[b]);
    }

    return 0;
}
```

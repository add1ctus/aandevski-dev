Досега најлесниот Codeforces натпревар на кој што сум учествувал. Од 5-те задачи, 3 се решаваа со greedy додека една имаше ad hoc решение. И покрај 4 решени задачи едвај добив +20 рејтинг заради изгубеното време на третата задача (50 минути и 4 погрешни решение заради глупа грешка).

## A - Toy Cars

[Линк до задачата](http://codeforces.com/problemset/problem/545/A)

Мислам дека нема потреба од многу објаснување за оваа задача. Ја читаме матрицата, и доколку во `i`-тиот ред сретнеме број 1 или 3 значи дека `i`-тиот автомобил не е добар. Исто така, доколку во `j`-тата колона сретнеме број 2 или 3, значи дека `j`-тиот автомобил не е добар. Ова го бележиме во `boolean` низа (иницирана на `true`). Додатно чувам променлива `counter` која ја намалувам секогаш кога ќе ставам некоја `boolean` вредност од `true` на `false` (бидејќи треба да се испечати исто така и бројот на добри автомобили).

```
#include <iostream>
#include <cstring>

using namespace std;

int main()
{
    int n;
    cin>>n;
    bool good[n];
    memset(good,true,n);
    int temp;
    int counter=n;
    for(int i=0;i<n;i++)
        for(int j=0;j<n;j++)
        {
            cin>>temp;
            if(temp<=0)
                continue;
            if(temp==1 || temp==3)
            {
                if(good[i])
                    counter--;
                good[i]=false;
            }
            if(temp==2 || temp==3)
            {
                if(good[j])
                    counter--;
                good[j]=false;
            }
        }
    cout<<counter<<endl;
    for(int i=0;i<n;i++)
        if(good[i])
            cout<<i+1<<" ";
    return 0;
}
```

## B - Equidistant String

[Линк до задачата](http://codeforces.com/problemset/problem/545/B)

За дадените два стринга `a` и `b`, далечината ја пресметувате така што ги изминувате стринговите и проверувате на кои позиции `a[i]!=b[i]`. Доколку далечината на двата стринга е непарен број, тогаш печатиме `impossible` бидејќи не постои стринг што има еднаква далечина со двата стринга (секогаш ќе е поблиску до еден стринг). Доколку бројот е парен, тогаш можеме да направиме нов стринг `p`, така што на сите места каде што `a[i]==b[i]`, ја ставаме таа буква. На преостанатите места, на една половина од нив ќе ја ставиме буквата од `а`, на другата половина буквата од `b`.

```
#include <iostream>
#include <string>

using namespace std;

int main()
{
    string a,b;
    cin>>a>>b;
    int distance=0;
    for(int i=0;i<a.size();i++)
        if(a[i]!=b[i])
            distance++;
    if(distance%2==1)
    {
        cout<<"impossible";
        return 0;
    }
    distance/=2;
    string result;
    for(int i=0;i<a.size();i++)
        if(a[i]==b[i])
            result+=a[i];
        else if(distance)
        {
            result+=a[i];
            distance--;
        }
        else
            result+=b[i];
    cout<<result;
    return 0;
}
```

## C - Woodcutters

[Линк до задачата](http://codeforces.com/problemset/problem/545/C)

Задача која што за време на натпреварот ја решив со динамичко (и изгубив многу поени заради грешка во печатење на резултатот), а има многу просто greedy решение.

Почнуваме од лево и ги бутаме дрвјата едно по едно. Првото дрво секогаш го бутаме на лева страна (бидејќи таму нема да смета на никое друго дрво). Бидејќи првото дрво веќе е бутнато, тогаш доколку го бутнеме второто на лево, знаеме дека нема да смета на првото. Истото правило важи и за сите останати дрвја (доколку можеме сите да ги бутнеме на лево, така правиме). Но што се случува кога не може да се бутне дрвото на лево? Доколку го бутнеме на десно, тогаш постои шанса да смета на дрвото од десно (да не можеме да го бутнеме на лево). Но како и да е, сме бутнале едно дрво а сме спречиле друго да не се бутне (кое дрво и да бутнеме, пак сме бутнале 1 дрво, не прави разлика), така да можеме слободно да бутнеме на десно доколку лево не можеме.

Чуваме две низи, `position[i]` (што означува позиција на `i`-тото дрво) и `height[i]` (што означува висина на `i`-тото дрво) и `int` бројач што ни означува колку дрва сме бутнале. Бидејќи првото дрво секогаш можеме да го бутнеме на лево, бројачот почнува од 1 (и `for` циклусот го скокнува првото дрво). За сите наредни дрва (освен последното, кое секогаш можеме десно да го бутнеме), проверуваме дали `position[i]-height[i] > position[i-1]` (дали доколку се бутне дрвото на лево, ќе удри во дрвото од негова лева страна). Доколку овој услов е исполнет, тогаш го зголемуваме бројачот за 1. Доколку не е исполнет, тогаш проверуваме `position[i]+height[i] < position[i+1]` (дали доколку бутнеме на десно, ќе удри во дрвото од десна страна). Доколку овој услов е исполнет, тогаш го зголемуваме бројачот, но и на position`[i]` ја додаваме вредноста од `height[i]`, за да не дојде до преклопување доколку две соседни дрва бутнеме едно кон друго. Се што преостанува е на крајот да додадеме +1 на резултатот за последното дрво кое секогаш го бутаме на десно. Но доколку `n==1`, тогаш не додаваме +1 бидејќи ќе ни даде погрешен резултат.

```
#include <iostream>

using namespace std;

int main()
{
    int positions[100000];
    int heights[100000];
    int n;
    cin>>n;

    for(int i=0;i<n;i++)
        cin>>positions[i]>>heights[i];

    int fallenTrees=1;

    for(int i=1;i<n-1;i++)
    {
        if(positions[i]-heights[i]>positions[i-1])
            fallenTrees++;
        else if(positions[i]+heights[i]<positions[i+1])
        {
            fallenTrees++;
            positions[i]+=heights[i];
        }
    }

    if(n>1)
        fallenTrees++;

    cout<<fallenTrees;

    return 0;
}
```

## D - Queue

[Линк до задачата](http://codeforces.com/contest/545/problem/D)

Идејата е секогаш да служиме гости за кои треба највеќе време. Доколку имаме двајца со време 1 и 2, тогаш доколку прво го послужиме гостинот со време 2, тогаш гостинот со време 1 ќе е незадоволен. Ја сортираме низата, и почнуваме од гостите кои бараат најмалку време. Чуваме посебна променлива за тоа колку време поминало, и доколку послужиме некој гостин (времето му е помало од изминатото време), тогаш го зголемуваме изминатото време за неговото време. Во посебна променлива бележиме колку гости сме послужиле вкупно и го печатиме тој број.

```
#include <iostream>
#include <algorithm>

using namespace std;

int main()
{
    ios_base::sync_with_stdio(false);
    long long arr[100000];
    int n;
    cin>>n;
    for(int i=0;i<n;i++)
        cin>>arr[i];
    sort(arr,arr+n);
    long long time=arr[0];
    int counter=1;
    for(int i=1;i<n;i++)
        if(arr[i]>=time)
        {
            counter++;
            time+=arr[i];
        }
    cout<<counter;
    return 0;
}
```

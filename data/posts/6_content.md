Мразам временски зони. Додека Codeforces натпреварите се во слична временска зона со нашата, неретко се случува да седам до 5 сабајле за да учествувам во Topcoder SRM натпревар. Заради тоа и некогаш ги мразев Topcoder натпреварите, се додека не учествував во CodeChef LunchTime. Причината? Станување во 6:15 сабајле за да решавам задачи.

Lunchtime е натпревар наменет за сите оние кои би сакале да учествуваат на IOI (задачите се приближно на тоа ниво, со исклучок на една лесна задача). Завршив 114-то од 1355 учесника, решавајќи ги само првите две задачи (при што втората не поминуваше целосно заради некоја грешка со `min` функцијата). Од другите две задачи кои не ги решив, едната беше математичка (типично за CodeChef), каде што се бараше работа со огромни броеви (потребно беше разложување), додека другата беше со декомпозиција на дрва (дури и текстот на задачата не ми беше разбирлив при прво читање, и не ја отворив подоцна, иако беше сменет текстот во текот на натпреварот). И двете беа решени од само 25 учесника.

Да ги разгледаме задачите кои успеав да ги решам:

## Lucky four
[Текст од задачата](http://www.codechef.com/LTIME21/problems/LUCKFOUR)

Стандардно како и секаде, првата задача е полесна за да се намали бројот на учесници со 0 поени (да ги мотивира сите да решаваат). Во оваа задача имавме дадено `N` броеви, и за секој број потребно беше да изброиме колку пати се појавува цифрата 4 во него и да испечатиме. За целосни поени, задачата мораше да работи со 100,000 броеви во опсегот од 1 до 1,000,000,000. Стандардно временско ограничување од 1 секунда.

Грешка што неискусните „решавачи на проблеми“ би ја направиле е да го читаат бројот како `integer` вредност. Во тој случај, потребно е цело време да го делиме бројот со 10 и да го проверуваме остатокот за да ги провериме сите цифри. Со 100,000 10-цифрени броеви овој пристап и не е најоптималниот. Подобро решение е внесување на броевите како `string`-ови, и проверување на стрингот карактер по карактер.

Секако, ние правиме ист број на проверки и во двата случаи (мора да ги провериме сите цифри), но сепак проверката `if(input[i]=='4')` работи многу побрзо од делење на големи броеви. Просто за кодирање, го читаме бројот, проверуваме колку пати се појавува '4' во него со `for` циклус и печатиме.

[Решение во C++](http://www.codechef.com/viewsolution/6336555)

## The Warehouse
[Текст од задачата](http://www.codechef.com/LTIME21/problems/WPROB

На оваа задача потрошив значително повеќе време од нормално само за да ја упростам. Очигледно ненаспиено решавање на задачи не е најдобрата идеја, бидејќи потрошив 20-тина минути само читајќи го текстот повторно и повторно, без никаков напредок.

Имаме магацин на некоја фабрика за маици која произведува само црвени, зелени и сини маици, означени со `r`, `g` или `b`. `N` (нумерирани од 1 до `N`) маици се произволно наместени во низа и нашата цел е да ги наместиме така да го минимизираме бројот на соседни маици со различни бои за најкратко време. Притоа дозволено е да користиме една од овие 3 операции:

 * Маицата со реден број `X` ја ставаме на почетокот на низата за `X-1` секунди
 * Маицата со реден број `X` ја поместуваме на лево, после `Y` маицата за `X-Y-1` секунди
 * Маицата со реден број `X` ја поместуваме на десно, после `Y` маицата за `Y-X` секунди

За даден стринг кој го означува почетниот редослед, најдете го најбрзото можно решение (најмалку секунди).

Интересно е како успеаа претерано проста задача да ја направат комплицирана само со текстот кој ја опишува. Минимизација на бројот на соседни маици со различни бои се всушност добива кога сите маици од иста боја ги ставиме една до друга. На пример, од `RRGBRB` да добиеме `RRRGBB`. Исто така доколку внимателно ги размислите операциите кои ни се дозволени, можеме да приметиме дека всушност ни е дозволено маиците да ги преместуваме лево и десно колку сакаме, каде што за 1 поместување се губи 1 секунда.

Имаме 6 различни начини на подредување на маиците според боите:
 * Црвени, Сини, Зелени
 * Црвени, Зелени, Сини
 * Сини, Црвени, Зелени
 * Сини, Зелени, Црвени
 * Зелени, Црвени, Сини
 * Зелени, Сини, Црвени

Ги пробуваме сите 6 начина и наоѓаме за кое подредување е потребно најмалку време и го печатиме тоа време.

Да го земеме за пример првиот редослед. Ги гледаме маиците една по една од почетокот на низата (го изминуваме стрингот буква по буква). Чуваме посебни бројачи кои ни означуваат која маица колку пати сме ја сретнале досега. Да замислиме низа `brojac`. Доколку добиеме црвена маица, тогаш таа треба да се помести во лево за `brojac[sini] + brojac[zeleni]` места за да биде на почетокот на стрингот (заедно со другите црвени маици). Доколку добиеме сина маица, треба да се помести во лево за `brojac[zeleni]` места за да биде во средина на стрингот (заедно со другите сини маици). Зелените маици треба да се на крајот, така да доколку добиеме таква маица, не ја поместуваме воопшто.

![Црвената маица ја поместуваме за 2 места (brojac[sini]+brojac[zeleni])](https://aandevski.files.wordpress.com/2015/02/untitled-11.png)

Во оваа задача само се бара најкраткото време на поместување, така да нема потреба да ги заменуваме маиците во стрингот, доволно е само да ги броиме секундите. Доколку изминеме `i` маици, знаеме дека тие секогаш ќе се подредени.

За секој внесен стринг (може до 10 стринга да се внесат), ги проверуваме сите 6 комбинации и го печатиме времето на најбрзата.

[Решение во C++](http://www.codechef.com/viewsolution/6336477)

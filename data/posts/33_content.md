[Задачава](http://mendo.mk/algoritmi/Task.do?competition=258&id=421) ме мачи уште од националниот ACM натпревар кој беше одржан уште во септември, кога остана нерешена по повеќе од 10 погрешни решенија пратени од повеќе тимови. Уште од кога ја видов задачата на лабораториските вежби знаев дека е нерешлива за нас (фактот дека повторно не добив никаква идеја по скоро саат размислување го потврди тоа), но по доста гуглање и анализирање на решенија успеав да ја разберам идејата за да ја решам.

## Оптимално решение

Грешката што ја правеа сите тимови на ACM е што пробувавме со greedy избор да го додадеме топот кој чини најмалку, што се испостави дека е погрешно. Решението се наоѓа на спротивна страна - бирање кој топ ќе го додадеме последен.

Идејата се базира околу фактот дека доколку `А` и `B` се двата топа кои се поставени најдалеку на таблата, тогаш во идеалниот редослед на поставување на топовите еден од овие топови ќе е последно поставен. Тоа можеме да го докажеме на следниов начин. Да претпоставиме дека во идеалниот редослед на поставување топот `A` е поставен пред топот `B` (`A` и `B` се двата најодалечени топови). Доколку топот `B` го ставиме на крајот на овој редослед, тогаш цената на секој топ што се наоѓал после `B` или би се намалила или би останала иста. Ова се забележува бидејќи за секој топ `X` што бил после `B`, доколку порано цената му била `max(B, max од сите останати топови пред X)` сега цената е само `max` од сите останати топови пред `X`. Исто така и цената на `B` не може да се зголеми, бидејќи во секој случај таа цена ќе е `dist(A,B)` (бидејќи `A` е пред `B`). Според ова заклучуваме дека за најодалечените топови `A` и `B` секогаш барем еден од нив ќе е последно додаден во низата.

Од ова лесно можеме да ја забележиме рекурентната релација на проблемов. Доколку имаме `n` топови означени со `A1`, `A2`, `A3`... `An`, при што (да претпоставиме дека) `A1` и `A2` се најодалечените топови, тогаш решение(`A1`, `A2`, `A3`... `An`) = `min(решение(A2, A3... An), решение(A1, A3... An))`. Бидејќи е очигледно дека потпроблемите ќе се повторуваат, решението се добива со динамичко програмирање.

## Ротација

Да беше само толку од задачава, би била ептен лесна. Проблемот со горенаведеното решение е што немаме начин да претставиме такви состојби. Доколку состојбите би ги забележувале според тоа кои топови останале (како што е направено погоре), тогаш би имале `2^64` состојби, што не можеме да ги претставиме во меморија ниту да ги пресметаме во разумно време. Додатно би го имале и проблемот на проверување кои топови се најодалечени за секоја состојба, што би ја додатно зголемила сложеноста.

![Горе: оргинална матрица, долу: ротирана матрица](https://aandevski.files.wordpress.com/2016/02/matrix1.jpg)

Наредната идеја е таа што ја упростува задачата доволно за да можеме да ја претставиме во помал број на состојби. Исто така е идејата што ретко на кого би му текнала (само 14 учесника од прва дивизија ја решиле задачава на Topcoder за време на натпревар). Доколку ја ротирате матрицата за 45 степени, задачава добива друга смисла.

Како што можете да забележите од сликава, топовите кои беа најдалеку во оргиналната матрица (во спротивни агли од матрицата) сега се наоѓаат во ист ред или колона, но на два различни краја на матрицата. Ротацијава всушност ни овозможува многу лесно да го добиеме Manhattan растојанието помеѓу два топа. За топовите `A(x1,y1)` и `B(x2,y2)` растојанието е `max(|x2-x1|, |y2-y1|)`

Сега кога далечиниве ни се претставени вака, многу полесно можеме да го претставуваме динамичкото. Доколку на пример имаме топови во два спротивни агли (да кажеме првиот и последниот ред од новодобиената матрица), тогаш доколку го исфрлиме последниот ред од матрицата ние всушност сме го избршале последниот топ. Но што се случува доколку има повеќе топови во еден ред или колона што сакаме да ја избришеме? Во тој случај, можеме сите топови од тој ред да ги избришеме, бидејќи за сите знаеме дека ја имаат истата (максимална) далечина и евентуално сите би требало да ги избришеме едно по друго (во било кој редослед).

Ова ни помага значително, бидејќи сега состојбите ќе бидат сите можни под-матрици од матрицата наместо сите можни комбинации на топови. Бидејќи новата матрица ни е со големина `15х15`, се работи за `15*15*15*15` = `50,625` можни состојби, за разлика од `2^64` состојби кои ги имавме со првата идеја.

## Претставување на динамичкото

Решението го правам како top-down динамичко со меморизација, каде секоја состојба ни е претставена со 4 броеви: `x1, y1` (почетокот на под-матрицата) и `x2,y2` (крајот на под-матрицата). Притоа, доколку `x1 == y1` и `x2 == y2`, тогаш сме стигнале до едно поле кое или ќе е празно, или ќе е топ кој се става со цена 0, така да во тој случај враќаме 0. Со ова го имаме зададено крајниот случај на рекурзијата.

Во спротивно, го наоѓаме парот на топови со најдолго растојание помеѓу нив и ги бришеме нивните редови или колони (во зависност од тоа според која димензија е најдолгото растојание). „Бришењето“ го правиме така што повикуваме нова рекурзија која не го вклучува тој ред или колона. Рекурзијата ја повикуваме и за двата топа и го бираме подобриот резултат. При тоа, на резултатот од рекурзијата го додаваме резултатот од додавањето на топот кој го „бришеме“.

## Пишување на код

За почеток го читаме input-от кој можеме веднаш да го ротираме и да го запишеме во `15х15` матрица од `boolean` (каде што со `true` означуваме каде има топ). Исто така матрицата за меморизација на динамичко ја иницираме на -1. Тоа ќе ни ги означува состојбите за кои не сме пресметале резултат сеуште.

```
memset(DP,-1,sizeof(DP));
char input;
for(int i = 0 ; i < 8 ; ++i)
    for(int j = 0 ; j < 8 ; ++j)
        {
            scanf(" %c",&input);
            if(input == '#')
                rook[i+j][j-i+7] = true;
        }
```

Внатре во рекурзијата, прво што треба да провериме е дали сме стигнале до краен случај (`1х1` матрица) или пак резултатот за некоја под-матрица е веќе пресметан. Доколку е потребно да направиме пресметка, тогаш резутлатот за таа под-матрица го иницираме на некоја голема вредност (за да можеме после со min да добиеме подобра вредност).

```
int solve(int x1, int x2, int y1, int y2) {
    if(x1 == x2 && y1 == y2)
        return DP[x1][x2][y1][y2] = 0;
    if(DP[x1][x2][y1][y2] != -1)
        return DP[x1][x2][y1][y2];
    DP[x1][x2][y1][y2] = 999999;
```

Пишуваме посебен код за одземање на ред/колона од сите 4 страни, со што повикуваме 4 нови рекурзии. Но бидејќи со секоја рекурзија одземаме по само еден ред/колона, потребно е да го направиме тоа за редот/колоната каде што би се наоѓал топот со најголема далечина. Затоа ги проверуваме разликите помеѓу `x1,x2` и `y1,y2` координатите. Доколку разликата помеѓу еден пар координати е поголема од разликата помеѓу друг пар координати, тогаш од таму би требало да одземаме редови/колони (заради веројатноста дека таму е најголемата разлика). Доколку разликата е еднаква, тогаш пробуваме да одземеме ред/колона од сите 4 страни. При одземање на страна, со `for` циклус проверуваме колку топови имало на страната што сме ја одземале и го додаваме тоа на резултатот од рекурзијата (додаваме колку би чинело да се додаде секој од тие топови, што е `x2-x1` доколку далечината е хоризонтална или `y2-y1` доколку далечината е вертикална.

```
int sum;

if(y2 - y1 >= x2 - x1)
{
    //Take top out
    sum = solve(x1,x2,y1+1,y2);
    for(int i = x1 ; i <= x2 ; ++i)
        if(rook[i][y1])
            sum += y2-y1;
    DP[x1][x2][y1][y2] = min(DP[x1][x2][y1][y2], sum);

    //Take bot out
    sum = solve(x1,x2,y1,y2-1);
    for(int i = x1 ; i <= x2 ; ++i)
        if(rook[i][y2])
            sum += y2-y1;
    DP[x1][x2][y1][y2] = min(DP[x1][x2][y1][y2], sum);
}

if(x2 - x1 >= y2 - y1)
{
    //Take left out
    sum = solve(x1+1,x2,y1,y2);
    for(int i = y1 ; i <= y2 ; ++i)
        if(rook[x1][i])
            sum += x2-x1;
    DP[x1][x2][y1][y2] = min(DP[x1][x2][y1][y2], sum);

    //Take right out
    sum = solve(x1,x2-1,y1,y2);
    for(int i = y1 ; i <= y2 ; ++i)
        if(rook[x2][i])
            sum += x2-x1;
    DP[x1][x2][y1][y2] = min(DP[x1][x2][y1][y2], sum);
}

return DP[x1][x2][y1][y2];
```

Со оваа функција ја решаваме целата задача. Се што преостанува е да ја повикаме функцијата `solve` со параметри `0,14,0,14` (што ќе ја опфати целата матрица, инклузивно). [Линк](http://pastebin.com/2qSKuM58) до комплетниот код

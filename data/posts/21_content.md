Уште еден во низата лоши натпревари за мене (се надевам и последен), повторно назад во втора дивизија. Изгубив неколку минути на првата задача бидејќи погрешно ја сфатив, додека во втората задача заради погрешни ограничувања (сум напишал 100000 наместо 1000000) ја решив дури еден саат подоцна од потребно, по 3 погрешни одговори пратено. За да биде уште полошо, третата задача која имаше просто greedy решение се обидував да ја решам со binary search, што ми даваше погрешни резултати за некои примери. Ги средив решенијата на првите три задачи и ги поправив грешките, во продолжение можете да ги најдете решенијата.

## A - Cutting Banner

[Линк до задачата](http://codeforces.com/problemset/problem/538/A)

Да го искористиме фактот дека стрингот може да е највеќе 100 букви долг, што е доста мал број. Знаеме дека треба да избришеме само еден дел од стрингот. Да го означиме со `i` почетокот на делот што го бришеме, а со `j` крајот на делот што го бришеме. Бидејќи `i` и `j` можат да бидат помеѓу 0 и 99, во најлош случај имаме 100*100 = 10,000 можни начини да избришеме некој дел од дадениот стринг. Можеме да ги провериме сите и да видиме дали при некое бришење, остатокот е `CODEFORCES`.

Доколку го бришеме делот од `i` до `j`, тогаш ни останува делот од 0 до `i` и од `j+1` до крај. Тие два дела можеме да ги добиеме со функцијата `substr`. Кога на `substr` даваме еден параметар `x`, тогаш таа ни го враќа стрингот од позиција `x` до крајот. Кога на `substr` му дадеме два параметри `x` и `y`, тогаш добиваме стринг кој почнува од позиција `x` и е долг `y` букви. Така да стрингот без избришаниот дел би го добиле со `substr(0,i) + substr(j+1)`. Проверуваме дали некогаш овој стринг ќе е еднаков на `CODEFORCES`, со што ја решаваме задачата.

```
#include <iostream>
#include <string>

using namespace std;

int main()
{
    string input;
    cin>>input;
    for(int i=0;i<input.size();i++)
        for(int j=i;j<input.size();j++)
            if(input.substr(0,i)+input.substr(j+1)=="CODEFORCES")
            {
                cout<<"YES";
                return 0;
            }
    cout<<"NO";
    return 0;
}
```

## B - Quasi Binary

[Линк до задачата](http://codeforces.com/problemset/problem/538/B)

Доколку ја имате решено задачата „Палиндроми“ од државниот натпревар во 2014, тогаш сигурно ќе ви е јасна оваа задача, која дури е и малку полесна од таа. Решението е обично knapsack динамичко, при што памтиме кој предмет кога го земаме. Во овој случај, големината на ранецот е бројот `n`, а предметите што можеме да ги ставаме во ранецот се сите квазибинарни броеви. Се бара пополнување на ранецот со најмал број на предмети.

Правиме низа `DP[n+1]` каде што `DP[x]` - колку најмалку квазибинарни броеви се потребни за да се претстави бројот `x`. Во викито на Мендо како и низ многу други места по интернет можете да најдете добри објаснувања за knapsack динамичко, така да тој дел нема да го објаснувам, туку само ќе го напишам кодот. Додатно, за да меморираме кој квазибинарен број сме го избрале на позиција `x`, имаме додатна низа `taken[n+1]`. Во векторот `qb` ни се ставени сите квазибинарни броеви.

```
for(int i=2;i<=needednumber;i++)
    for(int j=0;j<qb.size() && i-qb[j]>=0;j++)
        if(DP[i]>DP[i-qb[j]]+1)
        {
            DP[i]=DP[i-qb[j]]+1;
            taken[i]=qb[j];
        }
```

Но како го пополнуваме векторот `qb`? Сите 2-цифрени квазибинарни броеви можеме да ги добиеме врз основа на едноцифрените, така што на секој едноцифрен број ќе му додадеме 0 и 1 на крајот за да добиеме нов број. Истото важи и за сите други. Од броевите `10` и `11` можете да ги добиете броевите `100`,`101`,`110` и `111`, што се сите 3-цифрени квазибинарни броеви. Ова се повторува се додека не ги добиеме сите 6 цифрени броеви, на кои сами ќе го додадеме `1000000` (единствениот 7-цифрен број кој ни е потребен). За почеток, во векторот ги имаме броевите `0,1,10,11` во векторот. За да ги добиеме 3-цифрените броеви, вршиме додавање на броевите од позиција 2 до 3 (двата двоцифрени броја). За 4-цифрени броеви, вршиме додавање на броевите од позиција 4 до 7 (сите 3-цифрени броеви). Првиот број секогаш се дуплира, додека вториот секогаш се дуплира и му се додава 1.

```
vector<int> qb;

qb.push_back(0);
qb.push_back(1);
qb.push_back(10);
qb.push_back(11);

for(int i=0;i<=1000000;i++)
    DP[i]=9999;

DP[0]=DP[1]=DP[10]=DP[11]=DP[1000000]=1;
taken[1]=1;
taken[10]=10;
taken[11]=11;
taken[1000000]=1000000;

int limitlevo=2,limitdesno=3;

for(int cifri=2;cifri<6;cifri++)
{
    for(int i=limitlevo;i<=limitdesno;i++)
    {
        qb.push_back(qb[i]*10);
        DP[qb.back()]=1;
        taken[qb.back()]=qb.back();
        qb.push_back(qb[i]*10+1);
        DP[qb.back()]=1;
        taken[qb.back()]=qb.back();
    }
    limitlevo*=2;
    limitdesno*=2;
    limitdesno++;
}
qb.push_back(1000000);
```

Се што преостанува е да го испечатиме резултатот кој се наоѓа во `DP[needednumber]` и да го реконструираме со помош на низата taken.

```
    cout<<DP[needednumber]<<endl;
    while(needednumber!=0)
    {
        cout<<taken[needednumber]<<" ";
        needednumber-=taken[needednumber];
    }
```

## C - Tourist's Notes

[Линк до задачата](http://codeforces.com/problemset/problem/538/C)

Доколку за претходната задача најдовме слична задача од Мендо, овој пат може да се најде слична задача од Codeforces. Два натпревари порано, во [Codeforces Round #298](https://aandevski.wordpress.com/2015/04/13/codeforces-round-298/), втората задача со иста идеја како оваа, со тоа што оваа е малку покомплицирана.

Бидејќи се работи за ограничувања до `10^8`, мора да користиме мапи, каде што `mapa[x] = височина на точка x`. Почнувајќи од вториот член, секогаш го проверуваме внесениот член со последниот внесен. Доколку абсолутната разлика на висните е поголема од далечината помеѓу тие две точки, тогаш можеме веднаш да испечатиме `IMPOSSIBLE` и да го прекинеме програмот. Доколку итераторот `mapa.end()` го означува крајот на мапата, тогаш со `--mapa.end()` можеме да го добиеме последниот член во мапата.

```
map<int, int> height;
int days,known;
cin>>days>>known;
map<int, int>::iterator it;
for(int i=0;i<known;i++)
{
    int d,h;
    cin>>d>>h;
    if(!height.empty())
        if(!eval((--height.end())->first,d,(--height.end())->second,h))
        {
            cout<<"IMPOSSIBLE";
            return 0;
        }
    height[d]=h;
}
```

Заради уредност на кодот користам функција `eval`, која што проверува дали абсолутната вредност помеѓу висините е поголема од далечината.

```
bool eval(int d1, int d2, int h1, int h2)
{
    if(h1>h2)
        swap(h1,h2);
    if(h2-h1>d2-d1)
        return false;
    return true;
}
```

Доколку не испечатиме `IMPOSSIBLE`, тогаш треба да ја најдеме максималната височина. Бидејќи се работи за огромни броеви, начинот на кој ја решивме задачата `B` од натпреварот #298 не можеме да го употребиме тука. Пооптимизиран начин би било така што првин проверуваме колку време треба за да ги изедначиме двете точки (од пониската точка да стигнеме до висината на повисоката). Кога веќе двете точки се на иста висина, знаеме дека просторот помеѓу нив го поделуваме на две половини: една каде што висината расте, една каде што висината опаѓа. На овој начин можеме да стигнеме до максималната висина, но повторно да се вратиме на потребната висина.

```
for(it=++height.begin();it!=height.end();it++)
{
    int distances[2]={(--it)->first,(++it)->first};
    int heights[2]={(--it)->second,(++it)->second};
    int dist=distances[1]-distances[0];
    if(heights[0]>heights[1])
    {
        dist-=heights[0]-heights[1];
        maksimum=max(maksimum,dist/2+heights[0]);
    }
    else
    {
        dist-=heights[1]-heights[0];
        maksimum=max(maksimum,dist/2+heights[1]);
    }
}
```

Се што преостанува е да го пресметаме просторот помеѓу 0 и првата точка и помеѓу последната точка и крајот.

```
maksimum=max(maksimum,height.begin()->second+height.begin()->first-1);
maksimum=max(maksimum,days-(--height.end())->first+(--height.end())->second);
```

Ја печатиме променливата `maksimum`.

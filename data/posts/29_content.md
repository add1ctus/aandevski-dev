Конечно назад во прва дивизија. Интересен натпревар со уште поинтересни задачи и многу хакирање. Успеав да ги решам првите 3 задачи и да извадам додатни 750 поени со хакирање што ме стави на 43-тото место, едно повисоко од мојот најдобар резултат (44-то). За жал покрај септемвриската испитна сесија немам време да ги решам останатите две задачи, така да на кратко само ќе ги објаснам првите 3 задачи кои ги решив.

## A - Elections

[Линк до задачата](http://codeforces.com/problemset/problem/570/A)

Ептен проста задача каде што само се бара да го имплементирате тоа што ви е објаснето. Потребно е да најдете најголем број во низа повеќе пати. Доколку има повеќе такви броеви, го земате оној со најмал индекс. Внимавајте на ограничувањата: постои тест пример каде сите кандидати во сите градови имаат 0 гласови. Во тој случај, првиот кандидат треба да е победник.

```
int n,m,temp,biggest,biggestindex;
scanf("%d%d",&n,&m);
int votes[100];
memset(votes,0,sizeof(votes));
for(int i=0;i<m;++i)
{
    biggest=0;
    biggestindex=0;
    for(int j=0;j<n;++j)
    {
        scanf("%d",&temp);
        if(temp>biggest)
        {
            biggest=temp;
            biggestindex=j;
        }
    }
    votes[biggestindex]++;
}
biggest=0;
biggestindex=0;
for(int i=0;i<n;++i)
    if(votes[i]>biggest)
    {
        biggest=votes[i];
        biggestindex=i;
    }
printf("%d",biggestindex+1);
```

## B - Simple Game

[Линк до задачата](http://codeforces.com/problemset/problem/570/B)

Мислам дека играта не е комплицирана за да ја разберете, така да ќе преминам веднаш на решението. Фактот дека вашиот противник ги добива сите броеви што се на еднакво растојание. Така да најдобра идеја е нашиот број да е претходник или следбеник на бројот на противникот. Ги проверуваме и двата случаи и бележиме кој број би ни дал повеќе поени и го избираме тој број. Специјален случај е каде `N=1`, при што и двата играчи го бираат истиот број.

```
    int n,m;
    scanf("%d%d",&n,&m);
    if(n==1 && m==1)
        printf("1");
    else if(m-1>=n-m)
       printf("%d",m-1);
    else
        printf("%d",m+1);
```

## C - Replacement

[Линк до задачата](http://codeforces.com/problemset/problem/570/C)

Задачава на прв поглед многу ме потсети на задачата D од [Codeforces #Pi натпреварот](https://aandevski.wordpress.com/2015/08/08/codeforces-round-pi/). Но всушност се работи за многу попроста задача. За да провериме колку операции ќе се извршат за даден стринг, нема потреба за да ги заменуваме подстринговите туку доволно е само да изброиме колку точки се наоѓаат една до друга, т.е. колку пати `..` стрингот се појавува.

```
int n,m;
scanf("%d%d",&n,&m);
char s[n+1];
scanf("%300001s",s);
int totalOperations=0;

for(int i=1;i<n;++i)
    if(s[i]=='.' && s[i-1]=='.')
        totalOperations++;
```

Но со стринг од 300,000 букви и 300,000 операции, тој алгоритам би работел со `O(N^2)` сложеност што е премногу. Клучната забелешка е што нема потреба целиот стринг да го проверуваме при секоја измена на буква, туку само буквите околу таа изменета буква. За секоја промена на буква, ги имаме следниве случаи:

 * Буквата не е променета. На место каде што стоела точка е повторно ставена точка или на место каде што стоела буква е повторно ставена буква (може да е различна од претходната) - во овој случај го печатиме истиот резултат од претходно бидејќи тој не е сменет
 * На место на буква е ставена точка - во овој случај проверуваме колку нови подстрингови `..` сме добиле со оваа промена. Поточно, проверуваме дали на позициите -1 и +1 имаме точка. Го зголемуваме резултатот за секоја сретната точка.
 * На место на точка е ставена буква - во овој случај го правиме обратното. Проверуваме колку подстрингови `..` сме растуриле, така да го намалуваме резултатот за секоја сретната точка на позициите -1 и +1.

Потребно е само да внимавате да не излезете надвор од меморија при проверување на позициите +1 и -1.

```
for(int i=0;i<m;++i)
{
    int position;
    char letter;
    scanf("%d %c",&position,&letter);
    if(!((letter!='.' && s[position-1]!='.') || (letter=='.' && s[position-1]=='.')))
    {
        s[position-1]=letter;
        if(letter=='.')
        {
            if(position-2>=0 && s[position-2]=='.')
                totalOperations++;
            if(position<n && s[position]=='.')
                totalOperations++;
        }
        else
        {
            if(position-2>=0 && s[position-2]=='.')
                totalOperations--;
            if(position<n && s[position]=='.')
                totalOperations--;
        }
    }
    printf("%d\n",totalOperations);
}
```

Доколку ве интересираат останатите задачи, мислам дека D се решава со дрва додека E се решава со динамичко. Веројатно ќе ги решам во септември откако ќе заврши испитната сесија.

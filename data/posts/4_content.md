**Едит:** Имав грешка во втората задача, поправено.

По 7 години натпреварување, ова ми е првата година како не учествувам на циклус натпревари по информатика. Иако не учествував, не можев да не ги разгледам задачите и да пробам да ги решам. Генерално интересен натпревар, со интересни задачи (посебно третата, која бараше неколку внимателни обзервации), кои сепак не бараа некое напредно знаење од алгоритми, само креативност. Ова беа моите решенија за првите 4 задачи. Последната задача е напишана како [посебен пост](https://aandevski.wordpress.com/2015/02/22/%D0%BC%D0%B5%D0%BD%D0%B4%D0%BE-%D0%B2%D0%B5%D0%BB%D0%BE%D1%81%D0%B8%D0%BF%D0%B5%D0%B4%D1%81%D0%BA%D0%B0-%D0%BF%D0%B0%D1%82%D0%B5%D0%BA%D0%B0/).

## Пуфи и Стојче

[Текст од задачата](http://mendo.mk/Task.do?competition=218&amp;id=532)

Генерално лесна задача, каде што ни се дадени 3 броја и ние треба да ги собереме и да видиме колку треба да се додаде на тој број за да биде делив со 3. Потребни ни беа 3 променливи, и го проверуваме остатокот на нивниот збир при делење со 3 (со модул). Потребни ни беа 3 if-а.
 * Доколку остатокот е 0, веќе е делив бројот со 3, не додаваме ништо
 * Доколку остатокот е 1, треба да додадеме уште 2 за да добиеме број делив со 3
 * Доколку остатокот е 2, треба да додадеме уште 1 за да добиеме број делив со 3

[Решение во C++](http://pastebin.com/ZuUy5Qyd)

Исто така можеше ова да се реши и со печатење на следнава формула: `(3-(x+y+z)%3)%3`

## Бакшиш

[Текст од задачата](http://mendo.mk/Task.do?competition=218&amp;id=528)

Навидум лесна задача, но има доста простор за грешки. Клучна забелешка е тоа што имаме само 100 милисекунди за пресметување на одговорот, и со броеви од 1 до 2,000,000,000, не смееме да користиме било какви циклуси, туку мора математички да го пресметаме резултатот.

Еден начин да го направиме тоа е да ги најдеме опсегот во кој треба да пресметаме колку броеви деливи со 5 има. Од двете страни опсегот го ограничуваме според процентот на бакшишот - 5% и 10%. Но од десната страна, доколку бакшишот е поголем од буџетот што го имаме, тогаш десната граница ни е буџетот.

Доста простор за грешка има при пресметување на бакшишот, кој треба да е помеѓу 5% и 10% *од вкупната сума*, а не од износот на сметката. Да разјасниме. Доколку бакшишот е 5% од вкупната сума, тогаш во формулата

```
цена на сметка + бакшиш = вкупна сума
```
заменуваме

```
цена на сметка + 5/100 вкупна сума = вкупна сума
цена на сметка = вкупна сума - 5/100 вкупна сума
цена на сметка = 95/100 вкупна сума
цена на сметка = 19/20 вкупна сума
цена на сметка / (19/20) = вкупна сума
20 * цена на сметка / 19 = вкупна сума
```

Со последната формула знаеме колку е вкупната сума што треба да ја платиме при 5% бакшиш. На ист начин ја добиваме и формулата за сумата при 10% бакшиш, што изнесува `10 * цена на сметка / 9`. Ги запишуваме овие два броја во две посебни променливи, притоа заокружувајќи го првиот број кон следбеникот (со `ceil`), а вториот кон претходникот (со `floor`), и го споредуваме вториот број со буџетот кој го имаме. Доколку буџетот е помал, тогаш вториот број е еднаков на буџетот.

Сега кога го имаме опсегот, за да го пресметаме резултатот прво е потребно да ги заокружиме двата броја на некој број делив со 5. Доколку првиот број не е делив со 5, треба да го зголемиме за да биде делив со 5 (слично нешто како првата задача?), т.е. да му додадеме `5-(X%5)` (каде што `X` е тој број). Додека кај вториот број, потребно е да го намалиме (за да не надминеме 10% бакшиш или буџет), т.е. да му одземеме `X%5`.

Доколку сме ги запишале двата броја во `mincena` и `makscena` променливите, сега за печатење на решението, имаме 2 случаја :
 * `mincena` > `makscena`. Во овој случај буџетот не ни дозволува да платиме никаков бакшиш, така да печатиме 0.
 * `mincena` <= `makscena`. Во овој случај можеме да платиме барем еден бакшиш. Со `makscena-mincena` ќе го добиеме бројот на различни вредности измеѓу овие 2 броја, но бидејќи ни се потребни само вредностите деливи со 5, го делиме овој број со 5 и додаваме 1 (за да ја броиме и првата вредност во опсегот).

[Решение во C++](http://pastebin.com/FcwTUaMs)

## Електрични светилки
[Текст од задачата](http://mendo.mk/Task.do?competition=218&amp;id=529)

Мојата омилена задача во овој натпревар. Имаме `N` светилки нумерирани од 1 до `N` кои можат да се вклучени или исклучени. Се внесува нивната почетна состојба, ние треба да ги исклучиме сите. За да го направиме тоа, имаме `N` прекинувачи, каде што `i`-тиот прекинувач ги гаси сите светилки деливи со `i` (прекинувач 2 ги гаси светилките 2,4,6...).

Потребни све 2 клучни забелешки тука :
 * Доколку притиснеме еден ист прекинувач два пати, исто како да не сме го притиснале. Така да за секој прекинувач треба само еднаш да провериме дали сме го притиснале или не.
 * Бидејќи нема броеви помали од `X` кои се деливи со `X`, знаеме дека кога ќе го притиснеме `X`-тиот прекинувач дека само ќе ја смениме `X`-тата светилка и можеби некои поголеми од `X` (но никогаш помали!)

Според ова можеме да почнеме од најмалата светилка / најмалиот прекинувач, и една по една да ги менуваме доколку има потреба. При тоа, доколку го притиснеме `X`-тиот прекинувач, треба да ја извршиме промената и за целата низа од `X` до `N` за сите броеви деливи со `X`.

[Решение во C++](http://pastebin.com/y18Sytg3)

## Роденденски прослави

[Текст од задачата](http://mendo.mk/Task.do?competition=218&amp;id=530)

Или погрешно ја имам сфатено задачата, или не заслужува да е 4та задача со 90 поени. Имаме `N` пријатели и дадени нивни родендени (ден и месец). Треба да провериме во кој месец ќе има највеќе прослави. Доколку има двајца или повеќе родени на ист датум, се брои како една прослава (слават заедно).

Прво решение кое би им текнало на сите е да изброиме кој месец највеќе пати се појавува и да го испечатиме. Доколку има повеќе месеци со ист број на родендени, ги печатиме сите. Но проблемот е во тоа што родендени од ист датум се бројат како еден, така да треба да забележуваме кои датуми се веќе изброени.

Тоа можеме да го направиме со boolean матрица со димензии `[31][12]` (денови и месеци), каде што ќе забележуваме `true`/`false` дали во некој ден сме веќе избројале роденден. При внесување на броевите, проверуваме за секој дали е веќе прочитан. Доколку е прочитан, не правиме ништо, но доколку не е, тогаш го зголемуваме бројачот за тој месец и го бележиме како прочитан.

На крајот само треба да ги испечатиме месеците со најголем број на родендени. Заради големиот број на внесени броеви (600,000), пожелно е да се користи `scanf` наместо `cin`, или пак `ios_base::sync_with_stdio(false);` за да работи побрзо `cin`-от.

[Решение во C++](http://pastebin.com/0kTmnVyB)

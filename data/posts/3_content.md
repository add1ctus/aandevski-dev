Последниот натпревар на кој учествував е Topcoder SRM 650 во прва дивизија, каде што целта ми е да ја решам првата задача (од трите вкупно), со што скоро секогаш добивам рејтинг (освен ако не ја решам премногу споро). За среќа, овој натпревар имаше невообиачено лесна задача, но затоа втората (само 12 точни решенија) и третата (само едно точно решение - Endagorion од Русија) беа претешки. Заради тежината на првата задача, успеав да ја решам за неполни 12 минути со кое го освоив 76-тото место, што е мојот најголем успех на Topcoder (и ми донесе повеќе од 100 рејтинг!!!). Да не одложувам повеќе, ова е објаснувањето на задачата која ја решив.

## 250 - Taro filling a string
[Текст од задачата](http://community.topcoder.com/stat?c=problem_statement&amp;pm=13669&amp;rd=16314)

Во задачата се збори за некој стринг од должина `N`, кој е исполнет само со карактери `A` и `B`. Не ни е даден целиот стринг, туку само буквите на неколку места (на пример, за стринг со должина 10 карактера, вас можат само да ви кажат дека 4тата буква е А). Максималната должина на стрингот е 1,000,000,000, и највеќе 50 букви ќе ви се веќе откриени. Од вас се бара да ги пополните останатите букви, така да го минимизирате бројот на исти букви една до друга. Така да доколку ни е даден стрингот `A__B`, лош стринг е `AABB`, а добар стринг е `ABAB`. Во некои случаи (како на пример `A_BA_`) е неизбежно да имаме две исти букви една до друга, така да треба да го минимизираме тој број (тука решението е `ABBAB` или `AABAB`). Но во задачата не ни се бара да го испечатиме стрингот како резултат, туку да испечатиме колку различни начини има за оптимално пополнување на стрингот, по модул 1,000,000,007 (да го испечатиме остатокот при делење на резултатот со овој број).

Задачата можеме да ја поделиме на повеќе подпроблеми - полиња измеѓу две дадени букви. Пример за стрингот `__A__BA_`, имаме 3 различни такви полиња. Потребно е да најдеме за секое такво поле колку различни начина имаме на оптимално пополнување, и потоа сите броеви да ги помножиме, со што би го добиле резултатот.

Прво нешто што можеме да заклучиме е дека полињата од лево и десно секогаш имаат само еден начин за оптимално пополнување, каде што нема ни една буква една до друга. Така да за `__A`, мора да пополниме со `ABA`. Исто така и `_A_` мора да пополниме со `BAB`. Другите решенија не се оптимални. Кога тие ги решиме, остануваат само полињата ограничени од две страни, како `A__B`. Кај нив имаме 4 случаи:

* Двете букви од страна се исти и имаме непарен број на празни места
* Двете букви од страна се различни и имаме парен број на празни места
* Двете букви од страна се различни и имаме непарен број на празни места
* Двете букви од страна се исти и имаме парен број на празни места

За првите два случаја секогаш имаме само еден начин на оптимално пополнување. За првиот случај, за `A_A` оптималното е `ABA`. За `A___A` оптималното е `ABABA`. Исто и за вториот, `A__B` има единствено решение `ABAB` и `B____A` има единствено решение `BABABA`.

Така да остануваат два случаи. Доклку земеме за пример `A_B` од третиот случај, двете можности се `ABB` и `AAB`, што значи дека мора да имаме најмалку еден пар исти букви што се заедно. Истото се случува и кај четвртиот пример со пример `A__A`, каде што валидните решенија се `AABA`, `ABBA`, `ABAA`, сите со по еден пар исти букви. Секако, постои и решението `AAAA`, но тоа не е оптималното во овој случај. Со 1 празно место имавме 2 можни пара, со 2 празни места 3 можни пара, итн. Така да за секое поле со `X` празни места од третиот и четврт случај, имаме можни `X+1` начини за оптимално пополнување.

Така да потребно е низите да ги сортираме прво, и потоа да ги изминуваме сите парови, мерејќи го местото меѓу нив и проверувајќи дали имаат само 1 начин или повеќе. Доколку имаме повеќе начини, ги додаваме во производот. Важно е при секое додавање да направиме и модул на производот, за да не добиеме преголем број кој би излегол надвор од опсегот на `long long`.

[Решение во C++](http://community.topcoder.com/stat?c=problem_solution&amp;rm=325209&amp;rd=16314&amp;pm=13669&amp;cr=23148678)

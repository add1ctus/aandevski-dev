По колоквиумската пауза повторно почнувам со учество на Topcoder и Codeforces натпревари, и првиот на листа е Codeforces #298. Успеав да решам 3 задачи (и четвртата откако заврши натпреварот) со што го обезбедив 118-тото место од 2300+ учесника, што ме врати повторно во првата дивизија! Невообичаено за Codeforces, првите 3 задачи имаа ad hoc решенија и беа доста лесни. Ова се моите решенија:

## A - Exam

[Линк до задачата](http://codeforces.com/problemset/problem/534/A)

За даден број `N`, од вас се бараше да направите што поголема пермутација од броевите од 1 до `N`, така што сите соседни броеви не се еден до друг во пермутацијата. Можеме да го искористиме фактот дека доколку два броја имаат иста парност (двата се непарни или пак двата се парни), тогаш тие сигурно не се соседни. Така да ги печатиме прво ситеепарни броеви од 1 до `N`, па потоа сите непарни од 2 до `N`.

Простор за грешка има кога `N=2` или 3. Во случај кога `N = 2`, не можеме да направиме пермутација од 2 броја (бидејќи 1 и 2 се соседни). Во случај кога `N = 3`, не можеме да направиме пермутација од 3 броја (било која пермутација ќе има два соседни броја еден до друг). За да се среди ова, само додаваме 2 `if`-а за `n==2` и `n==3`.

```
#include <iostream>

using namespace std;

int main()
{
    int n;
    cin>>n;

    if(n==2)
        cout<<1<<endl<<1;
    else if(n==3)
        cout<<2<<endl<<"1 3";
    else
    {
        cout<<n<<endl;
        for(int i=2;i<=n;i+=2)
            cout<<i<<" ";
        for(int i=1;i<=n;i+=2)
            cout<<i<<" ";
    }

    return 0;
}
```

## B - Covered Path

[Линк до задачата](http://codeforces.com/problemset/problem/534/B)

За некое возење на автомобил вие имате дадено три вредности:
 * `v1` - брзината на почетокот на возење во m/s
 * `v2` - брзината на крајот на возење во m/s
 * `t` - време на возење во секунди

Доколку знаете дека автомобилот може да се забрза највеќе `d` m/s во една секунда, која е најголемата должина што тој автомобил би можело да ја измине?

За да изминеме што поголема должина, потребно е да ја максимизираме брзината секогаш. Идеално, брзината би ја зголемувале за `d` секогаш. Но бидејќи мора да го завршиме возењето со брзина `v2`, не можеме да ја зголемуваме брзината засекогаш, ќе треба во текот на возењето да ја намалуваме доколку треба. Па, како знаеме кога да треба да се намали брзината?

![Тест пример со t=4, v1=5, v2=6, d=2](https://aandevski.files.wordpress.com/2015/04/screenshot_15.png)

Да замислиме дека имаме две посебни возења: едно кое почнува со брзина `v1` и се зголемува до брзина `X`, и второ кое започнува со брзина `X` и завршува со брзина `v2`. Тие две возења можеме да ги претставиме како отсечки.

Местото каде што се сечат тие две отсечки е местото каде што треба да почнеме да ја намалуваме брзината.

Како ова најлесно може да се изведе во код? Чуваме две посебни низи за двете возења, каде што бележиме која е брзината на тоа возење во секоја секунда. Резултатот го добиваме така што за секоја секунда ја земаме помалата вредност од двете низи. Ја печатиме сумата на овие вредности.

```
#include <iostream>

using namespace std;

int main()
{
    int v1,v2,t,d;
    cin>>v1>>v2>>t>>d;

    int sum=0;

    int fromstart[t],fromend[t];

    fromstart[0]=v1;
    fromend[t-1]=v2;

    for(int i=1;i<t;i++)
        fromstart[i]=fromstart[i-1]+d;

    for(int i=t-2;i>=0;i--)
        fromend[i]=fromend[i+1]+d;

    for(int i=0;i<t;i++)
    {
        if(fromstart[i]<fromend[i])
            sum+=fromstart[i];
        else
            sum+=fromend[i];
    }

    cout<<sum;

    return 0;
}
```

## C - Polycarpus' Dice

Имате дадено `N` коцки за фрлање (со `X` страни, и броевите од 1 до `X` на секоја страна). Коцките може да имаат различен број на страни (за пример, може да имате една коцка со 6 страни и 2 коцки со 3 страни). За некое фрлање, вие знаете кои коцки се користени и колку е збирот од фрлањето. Бидејќи не можете со сигурност да одредите кои коцки се паднале (на пример доколку збирот е 6 а вие имате 2 коцки со 6 страни, фрлањето би можело да биде 1+5, 2+4 или 3+3), од вас се бара да одредите за секоја коцка кои броеви не се паднале (во претходниот пример, за ни една коцка не може да се падне бројот 6).

Да разгледаме внимателно, кога поточно не може да се падне некој број за некоја коцка? Има два случаи:

 * Кога го надминувате збирот. На пример доколку збирот е 4, а вие имате 3 коцки, тогаш максимумот што може да ви се падне на секоја коцка е 2 (бидејќи другите две коцки би имале 1, и `2+1+1=4`). Најголемиот број што може да ви се падне со некоја коцка е `S-N+1` (бидејќи било кој друг би го надминал збирот)
 * Кога не го достигате збирот. На пример, имате збир 8 и 3 коцки со 3 страни. Не можете збирот да го добиете доколку ви се падне 1 на некоја коцка (бидејќи `1+3+3<8`). Најмалиот број што може да ви се падне со некоја коцка е `S - (сума на сите коцки - број на страни на коцка)`. Било кој друг број (помал од тој) и нема да добиете збир `S`.

Кога веќе знаеме за сите коцки која е најмалата и најголемата вредност, преостанува да видиме кои вредности од коцката не ги користиме. Доколку имате коцка со 6 страни, каде што најмалата довзолена вредност е 2 а најголемата 4, тогаш страните 1, 5 и 6 не ги користите = вкупно 3 страни. Тоа се добива со : `број на страни - најголема вредност + најмала вредност - 1`

```
#include <iostream>

using namespace std;

int main()
{
    long long n,A;
    cin>>n>>A;

    long long sum=0;

    long long arr[n];
    for(int i=0;i<n;i++)
    {
        cin>>arr[i];
        sum+=arr[i];
    }


    for(int i=0;i<n;i++)
    {
        int lowest=max(1LL,A-(sum-arr[i]));
        int highest=min(arr[i],A-(n-1));
        cout<<arr[i]-highest+lowest-1<<" ";
    }

    return 0;
}
```

## D - Handshakes

[Линк до задачата](http://codeforces.com/problemset/problem/534/D)

Интересна задача која успеав многу да ја искомплицирам за време на натпреварот и не видов просто DFS решение. Имате дадено `N` студенти кои влегувале во соба еден по еден. Секогаш кога некој ќе влезе, тој се поздравува со сите слободни студенти. Кога студентите се внатре, тие можат да направат тим од тројца и да решаваат задачи. Кога студенти решаваат задачи, тогаш новите студенти што влегуваат не се поздравуваат со нив.

Имате дадено низа што означува кој студент колку пати се поздравил при влегување. Од вас се бара да го испечатите редоследот на влегување на студентите (доколку постои таков). Првиот студент што влегува не се поздравува со никого, потоа вториот се поздравува со еден студент, па третиот со два студента, итн. Доколку тие направат тим, тогаш може да влезе некој што се поздравува со 0 студенти. Доколку не направат тим, тогаш може да влезе некој што се поздравува со 3 студенти. Ја сфаќате идејата.

Ова можеме да го претставиме како граф, на тој начин што секогаш кога ќе влезе некој студент со `X` поздравувања, после него треба да влезе некој студент со `X+1` поздравувања. Се додека има студенти кои го задоволуваат ова барање, студентите влегуваат и бележиме кој кога влегува. Кога веќе нема студент со `X+1` поздравувања, тогаш проверуваме дали има студент со `(X+1)-3` поздравувања (што би значело дека студентите внатре направиле еден тим. Доколку повторно нема, тогаш пак одземаме 3 студенти, се додека не најдеме некој студент, или пак додека не стигнеме до негативен број (кога ќе знаеме дека не постои решение).

За да не пребаруваме цело време низ низата од студенти, користиме вектор од вектори, така што во `vec[i]` ги имаме сите студенти кои се поздравиле `i` - пати.

За пуштено dfs од `x` поздравувања, доколку постои студент во векторот `vec[x]`, го вадиме од векторот, го запишуваме во резултатот и повикуваме dfs за `x+1`. Доколку не постои, тогаш повикуваме dfs за `x-3` (освен ако `x-3` е негативен број). Кодот сам ќе си заврши или кога ќе ги внесе сите студенти, или кога ќе стигне до негативен број и ќе се врати назад. Како знаеме кога е најден резултатот, а кога не? Векторот со резутлат треба да има вкупно `N` членови внатре. Доколку има помалку, тогаш не сме ги ставиле сите студенти - не постои резултат.

```
#include <iostream>
#include <vector>

using namespace std;

vector<int> output;
vector<vector<int> > graph(200001);

void dfs(int shakes)
{
    if(graph[shakes].empty())
    {
        if(shakes-3<0)
            return;
        dfs(shakes-3);
    }
    else
    {
        output.push_back(graph[shakes].back());
        graph[shakes].pop_back();
        dfs(shakes+1);
    }
}

int main()
{
    int n;
    cin>>n;

    for(int i=1;i<=n;i++)
    {
        int temp;
        cin>>temp;
        graph[temp].push_back(i);
    }

    dfs(0);

    if(output.size()==n)
    {
        cout<<"Possible"<<endl;
        for(int i=0;i<n;i++)
            cout<<output[i]<<" ";
    }
    else
        cout<<"Impossible";

    return 0;
}
```
